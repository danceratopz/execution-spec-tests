{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Execution Spec Tests","text":"<p>ethereum/execution-spec-tests is both a collection of test cases and a framework to generate tests for Ethereum execution clients. The test cases, also known as test fillers, are implemented in Python.</p> <p>The framework collects and executes the test cases in order to generate test fixtures (JSON) which can be consumed by any execution client to verify their implementation of ethereum/execution-specs. Currently, the fixtures, which define state transition and block tests, are generated by the framework using the <code>t8n</code> and <code>b11r</code> commands from the ethereum/go-ethereum <code>evm</code> command-line tool. Other implementations of the <code>t8n</code> and <code>b11r</code> can be added in the future.</p> <pre><code>---\ntitle: Test Fixture Generation with execution-spec-tests\n---\nflowchart LR\n  style C stroke:#333,stroke-width:2px\n  style D stroke:#333,stroke-width:2px\n  style G stroke:#F9A825,stroke-width:2px\n  style H stroke:#F9A825,stroke-width:2px\n\n  subgraph ethereum/go-ethereum\n    C[&lt;code&gt;evm t8n / evm b11r&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/solidity\n    D[&lt;code&gt;solc&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/EIPs\n    E(&lt;code&gt;EIPS/EIP-*.md&lt;/code&gt;\\nSHA digest via Github API)\n  end\n\n  subgraph \"ethereum/execution-spec-tests\"\n    A(&lt;code&gt;./fillers/**/*.py&lt;/code&gt;\\nPython Test Cases)\n    B([&lt;code&gt;$ pytest ./fillers/&lt;/code&gt;\\nPython Framework])\n  end\n\n  subgraph Test Fixture Consumers\n    subgraph ethereum/hive\n      G([&lt;code&gt;$ hive ...&lt;/code&gt;\\nGo Test Framework])\n    end\n    H([Client executables])\n  end\n\n  C &lt;-.-&gt; B  \n  D &lt;-.-&gt; B\n  A --&gt; B\n  E &lt;-.-&gt; |retrieve latest spec version\\ncheck tested spec version| B\n  B --&gt;|output| F(&lt;code&gt;./out/**/*.json&lt;/code&gt;\\nJSON Test Fixtures)\n  F --&gt;|input| G\n  F --&gt;|input| H</code></pre> <p>The generated test fixtures can be used:</p> <ol> <li>Directly by client teams' test frameworks, and,</li> <li>In the integration tests executed in the ethereum/hive framework.</li> </ol>"},{"location":"#relationship-to-ethereumtests","title":"Relationship to ethereum/tests","text":"<p>This collection of tests is relatively new (test case development started Q4, 2022) and mainly targets recent and upcoming Ethereum specification changes. It does not replace, but rather complements the existing tests in ethereum/tests.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The motivation to implement test cases in ethereum/execution-spec-tests is:</p> <ol> <li>To implement test cases as code and ensure that changes, due to spec changes, for example, can be easily made. Moreover, changes are easily understandable and available in version control.</li> <li>To avoid the 2-step approach often used in ethereum/tests:<ol> <li>Code (often unavailable) -&gt; Test case (YAML).</li> <li>Test case (YAML) -&gt; Fixtures (JSON).</li> </ol> </li> </ol> <p>Contributing</p> <p>Contributions via PR are welcome!</p>"},{"location":"navigation/","title":"Navigation","text":"<ul> <li>Overview</li> <li>Getting Started<ul> <li>Quick Start</li> <li>VS Code Setup</li> <li>Repository Overview</li> <li>Executing Tests at a Prompt</li> <li>Executing Tests in VS Code</li> <li>Executing Tests for Features Under Development</li> </ul> </li> <li>Writing Tests<ul> <li>Code Standards</li> <li>Types of Test</li> <li>Adding a New Test</li> <li>Writing a New Test</li> <li>Referencing an EIP Spec Version</li> <li>Verifying Changes Locally</li> </ul> </li> <li>Tutorials<ul> <li>State Transition Tests</li> </ul> </li> <li>Getting Help</li> <li>Developer Doc<ul> <li>Documentation</li> </ul> </li> <li>Library Reference<ul> <li>EVM Transition Tool Package</li> <li>EVM Block Builder Package</li> <li>Ethereum Test Tools Package</li> <li>Ethereum Test Forks Package</li> <li>Pytest Plugins</li> </ul> </li> <li>Test Case Reference<ul> <li>EIPs<ul> <li>EIP-3651</li> <li>EIP-3855</li> <li>EIP-3860</li> <li>EIP-4844<ul> <li>Test Cases</li> <li>datahash_opcode</li> <li>excess_data_gas</li> </ul> </li> </ul> </li> <li>example<ul> <li>acl_example</li> <li>yul_example</li> </ul> </li> <li>security<ul> <li>selfdestruct_balance_bug</li> </ul> </li> <li>VM<ul> <li>dup</li> <li>chain_id</li> </ul> </li> <li>withdrawals<ul> <li>withdrawals</li> </ul> </li> </ul> </li> </ul>"},{"location":"dev/","title":"Developer Documentation","text":"<p>This documentation is aimed at maintainers of <code>execution-spec-tests</code> but may be helpful during test case/filler development:</p> <ul> <li>generating documentation.</li> </ul>"},{"location":"dev/docs/","title":"Documentation","text":"<p>The <code>execution-spec-tests</code> documentation is generated via <code>mkdocs</code> and hosted remotely on readthedocs.io.</p>"},{"location":"dev/docs/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install -e .[docs]\n</code></pre>"},{"location":"dev/docs/#build-the-documentation","title":"Build the Documentation","text":"<p>One time build: <pre><code>mkdocs build\n</code></pre></p>"},{"location":"dev/docs/#local-deployment-and-test","title":"Local Deployment and Test","text":"<p>This runs continually and re-generates the documentation upon changes in the <code>./docs/</code> sub-director and deploys the site locally (127.0.0.1:8000, by default): <pre><code>mkdocs serve\n</code></pre> Note: The <code>gen-files</code> plugin currently breaks the <code>serve</code> command by continually re-generating the documentation. Disable this config in mkdocs.yml to avoid this behaviour.</p>"},{"location":"dev/docs/#test-remote-deployment","title":"Test Remote Deployment","text":"<p>This can be used to generate and deploy a local version of the documentation remotely on Github pages in order to share a preview with other developers. Note, as the documentation is generated locally, even changes that have not been pushed will be deployed: <pre><code>mkdocs gh-deploy\n</code></pre> It will be deployed to the Github pages of the repo's username (branch is ignored), e.g., https://danceratopz.github.io/execution-spec-tests.</p>"},{"location":"dev/docs/#production-deployment","title":"Production Deployment","text":"<p>Ensure that <code>docs/rtdio_requirements.txt</code> is up-to-date as following:</p> <pre><code>rm -rf venv-docs\npython -m venv ./venv-docs\nsource ./venv-docs/bin/activate.sh\npip install -e .[docs]\nmkdocs serve\n# -&gt; check console output / build\npip freeze &gt; ./docs/rtdio_requirements.txt\n</code></pre> <p>Read the docs should pick up a push to the <code>main</code> branch and deploy an up-to-date version of the documentation. Active maintainers who wish to manage the documentation on readthedocs.org require a readthedocs account and be given permission (please ask one of the active maintainers).</p>"},{"location":"dev/docs/#implementation","title":"Implementation","text":""},{"location":"dev/docs/#plugins","title":"Plugins","text":"<p>The documentation flow uses <code>mkdocs</code> and the following additional plugins:</p> <ul> <li>mkdocs: The main doc generation tool.</li> <li>mkdocs-material: Provides many additional features and styling for mkdocs.</li> <li>mkdocstrings and mkdocstrings-python: To generate documentation from Python docstrings.</li> <li>mkdocs-gen-files: To generate markdown files automatically for each test filler Python module. See this page for example usage. This plugin is used to programmatically generate the nav section for the generated filler documentation. </li> <li>mkdocs-literate-nav: Is used to define the navigation layout for non-generated content and was created to work well with <code>mkdocs-gen-files</code> to add nav content for generated content.</li> <li>mkdocs-git-authors-plugin: To display doc contributors in the page footer.</li> <li>mkdocs-glightbox - for improved image and inline content display.</li> </ul>"},{"location":"dev/docs/#the-test-case-reference-section","title":"The \"Test Case Reference\" Section","text":"<p>This section is auto-generated via a combination of:</p> <ol> <li>mkdocstrings and mkdocstrings-python,</li> <li>mkdocs-gen-files,</li> <li>mkdocs-literate-nav.</li> </ol> <p>It auto-generates a sequence of nested pages (with nav entries) of all python modules detected under <code>./fillers</code>. Each page contains a stub to the doc generated by mkdocstrings from the module's docstrings and source code. The mkdocs-gen-files and mkdocs-literate-nav plugins were created exactly for this purpose.</p> <p>No action is necessary if a new test directory or module is added to <code>./fillers</code>, it will be picked up automatically.</p> <p>Working with generated content</p> <p>The files in the <code>./fillers</code> directory are watched by <code>mkdocs serve</code>. Run <code>mkdocs serve</code> and edit the source docstrings: The browser will reload with the new content automatically.</p>"},{"location":"dev/docs/#navigation","title":"Navigation","text":"<p>All pages that are to be included in the documentation and the navigation bar must be included in <code>navigation.md</code>, except fillers/\"Test Case Reference\" entries. This is enabled by mkdocs-literate-nav. The nav entries for the automatically generated \"Test Case Reference\" section are generated in mkdocs-gen-files and appended to <code>navigation.md</code>.</p> <p>Current nav ordering limitations</p> <p>The \"Test Case Reference\" section must currently be the last section in the nav. This is because our mkdocs flow:</p> <ol> <li>Reads <code>navigation.md</code></li> <li>Generates the filler documentation and appends the Test Case Reference entries to <code>navigation.md</code></li> <li>Generates the nav.</li> </ol> <p>If necessary, we could probably split <code>navigation.md</code> into two files</p> <ul> <li><code>navigation-pre-test-case-reference.md</code>,</li> <li><code>navigation-post-test-case-reference.md</code>,</li> </ul> <p>and create an arbitrary ordering in the filler doc gen script. But this is untested.</p>"},{"location":"fillers/","title":"Test Case Reference","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers\n</code></pre> <p>Each Python module contained within <code>fillers</code> defines test cases targeting a specific area of EVM functionality.</p>"},{"location":"fillers/EIPs/","title":"EIPs","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips\n</code></pre> <p>Cross-client Ethereum Improvement Proposal Tests</p>"},{"location":"fillers/EIPs/eip3651/","title":"EIP-3651","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip3651.py\n</code></pre> <p>Test EIP-3651: Warm COINBASE EIP: https://eips.ethereum.org/EIPS/eip-3651 Source tests: https://github.com/ethereum/tests/pull/1082</p>"},{"location":"fillers/EIPs/eip3651/#fillers.eips.eip3651.test_warm_coinbase_call_out_of_gas","title":"<code>test_warm_coinbase_call_out_of_gas(state_test, fork, opcode, contract_under_test_code, call_gas_exact, use_sufficient_gas)</code>","text":"<p>Test warm coinbase.</p> Source code in <code>fillers/eips/eip3651.py</code> <pre><code>@pytest.mark.parametrize(\n    \"use_sufficient_gas\",\n    [True, False],\n    ids=[\"sufficient_gas\", \"insufficient_gas\"],\n)\n@pytest.mark.parametrize(\n    \"opcode,contract_under_test_code,call_gas_exact\",\n    [\n        (\n            \"call\",\n            Op.POP(Op.CALL(0, Op.COINBASE, 0, 0, 0, 0, 0)),\n            # Extra gas: COINBASE + 4*PUSH1 + 2*DUP1 + POP\n            GAS_REQUIRED_CALL_WARM_ACCOUNT + 22,\n        ),\n        (\n            \"callcode\",\n            Op.POP(Op.CALLCODE(0, Op.COINBASE, 0, 0, 0, 0, 0)),\n            # Extra gas: COINBASE + 4*PUSH1 + 2*DUP1 + POP\n            GAS_REQUIRED_CALL_WARM_ACCOUNT + 22,\n        ),\n        (\n            \"delegatecall\",\n            Op.POP(Op.DELEGATECALL(0, Op.COINBASE, 0, 0, 0, 0)),\n            # Extra: COINBASE + 3*PUSH1 + 2*DUP1 + POP\n            GAS_REQUIRED_CALL_WARM_ACCOUNT + 19,\n        ),\n        (\n            \"staticcall\",\n            Op.POP(Op.STATICCALL(0, Op.COINBASE, 0, 0, 0, 0)),\n            # Extra: COINBASE + 3*PUSH1 + 2*DUP1 + POP\n            GAS_REQUIRED_CALL_WARM_ACCOUNT + 19,\n        ),\n    ],\n    ids=[\"CALL\", \"CALLCODE\", \"DELEGATECALL\", \"STATICCALL\"],\n)\ndef test_warm_coinbase_call_out_of_gas(\n    state_test,\n    fork,\n    opcode,\n    contract_under_test_code,\n    call_gas_exact,\n    use_sufficient_gas,\n):\n\"\"\"\n    Test warm coinbase.\n    \"\"\"\n    env = Environment(\n        coinbase=\"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\",\n        difficulty=0x20000,\n        gas_limit=10000000000,\n        number=1,\n        timestamp=1000,\n    )\n    caller_address = \"0xcccccccccccccccccccccccccccccccccccccccc\"\n    contract_under_test_address = 0x100\n\n    if not use_sufficient_gas:\n        call_gas_exact -= 1\n\n    caller_code = Op.SSTORE(\n        0,\n        Op.CALL(call_gas_exact, contract_under_test_address, 0, 0, 0, 0, 0),\n    )\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000),\n        caller_address: Account(code=caller_code),\n        to_address(contract_under_test_address): Account(\n            code=contract_under_test_code\n        ),\n    }\n\n    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=caller_address,\n        gas_limit=100000000,\n        gas_price=10,\n        protected=False,\n    )\n\n    post = {}\n\n    if use_sufficient_gas and is_fork(fork=fork, which=Shanghai):\n        post[caller_address] = Account(\n            storage={\n                # On shanghai and beyond, calls with only 100 gas to\n                # coinbase will succeed.\n                0: 1,\n            }\n        )\n    else:\n        post[caller_address] = Account(\n            storage={\n                # Before shanghai, calls with only 100 gas to\n                # coinbase will fail.\n                0: 0,\n            }\n        )\n\n    state_test(\n        env=env,\n        pre=pre,\n        post=post,\n        txs=[tx],\n        tag=\"opcode_\" + opcode,\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3651/#fillers.eips.eip3651.test_warm_coinbase_gas_usage","title":"<code>test_warm_coinbase_gas_usage(state_test, fork, opcode, code_gas_measure)</code>","text":"<p>Test gas usage of different opcodes assuming warm coinbase.</p> Source code in <code>fillers/eips/eip3651.py</code> <pre><code>@pytest.mark.parametrize(\n    \"opcode,code_gas_measure\",\n    gas_measured_opcodes,\n    ids=[i[0] for i in gas_measured_opcodes],\n)\ndef test_warm_coinbase_gas_usage(state_test, fork, opcode, code_gas_measure):\n\"\"\"\n    Test gas usage of different opcodes assuming warm coinbase.\n    \"\"\"\n    env = Environment(\n        coinbase=\"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\",\n        difficulty=0x20000,\n        gas_limit=10000000000,\n        number=1,\n        timestamp=1000,\n    )\n\n    measure_address = to_address(0x100)\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000),\n        measure_address: Account(\n            code=code_gas_measure,\n        ),\n    }\n\n    if is_fork(fork, Shanghai):\n        expected_gas = 100  # Warm account access cost after EIP-3651\n    else:\n        expected_gas = 2600  # Cold account access cost before EIP-3651\n\n    post = {\n        measure_address: Account(\n            storage={\n                0x00: expected_gas,\n            }\n        )\n    }\n    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=measure_address,\n        gas_limit=100000000,\n        gas_price=10,\n        protected=False,\n    )\n\n    state_test(\n        env=env,\n        pre=pre,\n        post=post,\n        txs=[tx],\n        tag=\"opcode_\" + opcode.lower(),\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3855/","title":"EIP-3855","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip3855.py\n</code></pre> <p>Test EIP-3855: PUSH0 Instruction EIP: https://eips.ethereum.org/EIPS/eip-3855 Source tests: https://github.com/ethereum/tests/pull/1033</p>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_key_sstore","title":"<code>test_push0_key_sstore(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Use PUSH0 to set a key for SSTORE.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_key_sstore(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Use PUSH0 to set a key for SSTORE.\n    \"\"\"\n    code = Op.SSTORE(Op.PUSH0, 1)\n\n    pre[addr_1] = Account(code=code)\n    post[addr_1] = Account(storage={0x00: 0x01})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"key_sstore\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_fill_stack","title":"<code>test_push0_fill_stack(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Fill stack with PUSH0, then OR all values and save using SSTORE.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_fill_stack(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Fill stack with PUSH0, then OR all values and save using SSTORE.\n    \"\"\"\n    code = Op.PUSH0 * 1024\n    code += Op.OR * 1023\n    code += Op.SSTORE(Op.SWAP1, 1)\n\n    pre[addr_1] = Account(code=code)\n    post[addr_1] = Account(storage={0x00: 0x01})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"fill_stack\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_stack_overflow","title":"<code>test_push0_stack_overflow(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Stack overflow by using PUSH0 1025 times.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_stack_overflow(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Stack overflow by using PUSH0 1025 times.\n    \"\"\"\n    code = Op.SSTORE(Op.PUSH0, 1)\n    code += Op.PUSH0 * 1025\n\n    pre[addr_1] = Account(code=code)\n    post[addr_1] = Account(storage={0x00: 0x00})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"stack_overflow\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_storage_overwrite","title":"<code>test_push0_storage_overwrite(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Update an already existing storage value.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_storage_overwrite(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Update an already existing storage value.\n    \"\"\"\n    code = Op.SSTORE(Op.PUSH0, 2) + Op.SSTORE(1, Op.PUSH0)\n\n    pre[addr_1] = Account(code=code, storage={0x00: 0x0A, 0x01: 0x0A})\n    post[addr_1] = Account(storage={0x00: 0x02, 0x01: 0x00})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"storage_overwrite\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_during_staticcall","title":"<code>test_push0_during_staticcall(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Test PUSH0 during staticcall.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_during_staticcall(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Test PUSH0 during staticcall.\n    \"\"\"\n    addr_2 = to_address(0x200)\n\n    code_1 = Yul(\n\"\"\"\n        {\n            sstore(0, staticcall(100000, 0x200, 0, 0, 0, 0))\n            sstore(0, 1)\n            returndatacopy(0x1f, 0, 1)\n            sstore(1, mload(0))\n        }\n        \"\"\"\n    )\n    code_2 = Op.MSTORE8(Op.PUSH0, 0xFF) + Op.RETURN(Op.PUSH0, 1)\n\n    pre[addr_1] = Account(code=code_1)\n    pre[addr_2] = Account(code=code_2)\n    post[addr_1] = Account(storage={0x00: 0x01, 0x01: 0xFF})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"during_staticcall\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_before_jumpdest","title":"<code>test_push0_before_jumpdest(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Jump to a JUMPDEST next to a PUSH0, must succeed.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_before_jumpdest(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Jump to a JUMPDEST next to a PUSH0, must succeed.\n    \"\"\"\n    code = (\n        Op.PUSH1(4)\n        + Op.JUMP\n        + Op.PUSH0\n        + Op.JUMPDEST\n        + Op.SSTORE(Op.PUSH0, 1)\n        + Op.STOP\n    )\n\n    pre[addr_1] = Account(code=code)\n    post[addr_1] = Account(storage={0x00: 0x01})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"before_jumpdest\")\n</code></pre>"},{"location":"fillers/EIPs/eip3855/#fillers.eips.eip3855.test_push0_gas_cost","title":"<code>test_push0_gas_cost(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Test PUSH0 gas cost.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_gas_cost(\n    state_test: StateTestFiller,\n    fork: Fork,\n    env: Environment,\n    pre: dict,\n    post: dict,\n    tx: Transaction,\n    addr_1: str,\n):\n\"\"\"\n    Test PUSH0 gas cost.\n    \"\"\"\n    code = CodeGasMeasure(\n        code=Op.PUSH0,\n        extra_stack_items=1,\n    )\n\n    pre[addr_1] = Account(code=code)\n    post[addr_1] = Account(storage={0x00: 0x02})\n\n    state_test(env=env, pre=pre, post=post, txs=[tx], tag=\"gas_cost\")\n</code></pre>"},{"location":"fillers/EIPs/eip3860/","title":"EIP-3860","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip3860.py\n</code></pre> <p>Test EIP-3860: Limit and meter initcode EIP: https://eips.ethereum.org/EIPS/eip-3860</p> https://github.com/ethereum/tests/pull/990 <p>https://github.com/ethereum/tests/pull/1012</p>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.calculate_initcode_word_cost","title":"<code>calculate_initcode_word_cost(length)</code>","text":"<p>Calculates the added word cost on contract creation added by the length of the initcode based on the formula: INITCODE_WORD_COST * ceil(len(initcode) / 32)</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_initcode_word_cost(length: int) -&gt; int:\n\"\"\"\n    Calculates the added word cost on contract creation added by the\n    length of the initcode based on the formula:\n    INITCODE_WORD_COST * ceil(len(initcode) / 32)\n    \"\"\"\n    return INITCODE_WORD_COST * ceiling_division(length, 32)\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.calculate_create2_word_cost","title":"<code>calculate_create2_word_cost(length)</code>","text":"<p>Calculates the added word cost on contract creation added by the hashing of the initcode during create2 contract creation.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create2_word_cost(length: int) -&gt; int:\n\"\"\"\n    Calculates the added word cost on contract creation added by the\n    hashing of the initcode during create2 contract creation.\n    \"\"\"\n    return KECCAK_WORD_COST * ceiling_division(length, 32)\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.calculate_create_tx_intrinsic_cost","title":"<code>calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)</code>","text":"<p>Calculates the intrinsic gas cost of a transaction that contains initcode and creates a contract</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create_tx_intrinsic_cost(\n    initcode: Initcode, eip_3860_active: bool\n) -&gt; int:\n\"\"\"\n    Calculates the intrinsic gas cost of a transaction that contains initcode\n    and creates a contract\n    \"\"\"\n    cost = (\n        BASE_TRANSACTION_GAS  # G_transaction\n        + CREATE_CONTRACT_BASE_GAS  # G_transaction_create\n        + eip_2028_transaction_data_cost(\n            initcode.assemble()\n        )  # Transaction calldata cost\n    )\n    if eip_3860_active:\n        cost += calculate_initcode_word_cost(len(initcode.assemble()))\n    return cost\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.calculate_create_tx_execution_cost","title":"<code>calculate_create_tx_execution_cost(initcode, eip_3860_active)</code>","text":"<p>Calculates the total execution gas cost of a transaction that contains initcode and creates a contract</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create_tx_execution_cost(\n    initcode: Initcode,\n    eip_3860_active: bool,\n) -&gt; int:\n\"\"\"\n    Calculates the total execution gas cost of a transaction that\n    contains initcode and creates a contract\n    \"\"\"\n    cost = calculate_create_tx_intrinsic_cost(\n        initcode=initcode, eip_3860_active=eip_3860_active\n    )\n    cost += initcode.deployment_gas\n    cost += initcode.execution_gas\n    return cost\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.get_initcode_name","title":"<code>get_initcode_name(val)</code>","text":"<p>Helper function that returns an Initcode object's name to generate test ids.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def get_initcode_name(val):\n\"\"\"\n    Helper function that returns an Initcode object's name to generate test\n    ids.\n    \"\"\"\n    return val.name\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.test_contract_creating_tx","title":"<code>test_contract_creating_tx(blockchain_test, fork, initcode)</code>","text":"<p>Test cases using a contract creating transaction</p> <p>Test creating a contract using a transaction using an initcode that is on/over the max allowed limit.</p> <p>Generates a BlockchainTest based on the provided <code>initcode</code> and its length.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n    \"initcode\",\n    [\n        INITCODE_ZEROS_MAX_LIMIT,\n        INITCODE_ONES_MAX_LIMIT,\n        INITCODE_ZEROS_OVER_LIMIT,\n        INITCODE_ONES_OVER_LIMIT,\n    ],\n    ids=get_initcode_name,\n)\ndef test_contract_creating_tx(\n    blockchain_test: BlockchainTestFiller, fork: Fork, initcode: Initcode\n):\n\"\"\"\n    Test cases using a contract creating transaction\n\n    Test creating a contract using a transaction using an initcode that is\n    on/over the max allowed limit.\n\n    Generates a BlockchainTest based on the provided `initcode` and its\n    length.\n    \"\"\"\n    eip_3860_active = True\n    env = Environment()\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000),\n    }\n\n    post: Dict[Any, Any] = {}\n\n    created_contract_address = compute_create_address(\n        address=TestAddress,\n        nonce=0,\n    )\n\n    tx = Transaction(\n        nonce=0,\n        to=None,\n        data=initcode,\n        gas_limit=10000000,\n        gas_price=10,\n    )\n\n    block = Block(txs=[tx])\n\n    if len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n        # Initcode is above the max size, tx inclusion in the block makes\n        # it invalid.\n        post[created_contract_address] = Account.NONEXISTENT\n        tx.error = \"max initcode size exceeded\"\n        block.exception = \"max initcode size exceeded\"\n    else:\n        # Initcode is at or below the max size, tx inclusion in the block\n        # is ok and the contract is successfully created.\n        post[created_contract_address] = Account(code=Op.STOP)\n\n    blockchain_test(\n        pre=pre,\n        post=post,\n        blocks=[block],\n        genesis_environment=env,\n        tag=f\"{initcode.name}\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage","title":"<code>TestContractCreationGasUsage</code>","text":"<p>Test EIP-3860 Limit Initcode Gas Usage for a contract creating transaction, using different initcode lengths.</p> <p>Generates 4 test cases that verify the gas cost behavior of a</p> contract creating transaction <p>1) Test with exact intrinsic gas minus one, contract create fails    and tx is invalid. 2) Test with exact intrinsic gas, contract create fails,    but tx is valid. 3) Test with exact execution gas minus one, contract create fails,    but tx is valid. 4) Test with exact execution gas, contract create succeeds.</p> <p>Initcode must be within valid EIP-3860 length.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n    \"initcode\",\n    [\n        INITCODE_ZEROS_MAX_LIMIT,\n        INITCODE_ONES_MAX_LIMIT,\n        EMPTY_INITCODE,\n        SINGLE_BYTE_INITCODE,\n        INITCODE_ZEROS_32_BYTES,\n        INITCODE_ZEROS_33_BYTES,\n        INITCODE_ZEROS_49120_BYTES,\n        INITCODE_ZEROS_49121_BYTES,\n    ],\n    ids=get_initcode_name,\n)\n@pytest.mark.parametrize(\n    \"gas_test_case\",\n    [\n        \"too_little_intrinsic_gas\",\n        \"exact_intrinsic_gas\",\n        \"too_little_execution_gas\",\n        \"exact_execution_gas\",\n    ],\n    ids=lambda x: x,\n)\nclass TestContractCreationGasUsage:\n\"\"\"\n    Test EIP-3860 Limit Initcode Gas Usage for a contract\n    creating transaction, using different initcode lengths.\n\n    Generates 4 test cases that verify the gas cost behavior of a\n    contract creating transaction:\n        1) Test with exact intrinsic gas minus one, contract create fails\n           and tx is invalid.\n        2) Test with exact intrinsic gas, contract create fails,\n           but tx is valid.\n        3) Test with exact execution gas minus one, contract create fails,\n           but tx is valid.\n        4) Test with exact execution gas, contract create succeeds.\n\n    Initcode must be within valid EIP-3860 length.\n    \"\"\"\n\n    @pytest.fixture\n    def eip_3860_active(self):  # noqa: D102\n        return True\n\n    @pytest.fixture\n    def exact_intrinsic_gas(self, initcode, eip_3860_active):\n\"\"\"\n        Calculates the intrinsic tx gas cost.\n        \"\"\"\n        return calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)\n\n    @pytest.fixture\n    def exact_execution_gas(self, initcode, eip_3860_active):\n\"\"\"\n        Calculates the total execution gas cost.\n        \"\"\"\n        return calculate_create_tx_execution_cost(\n            initcode,\n            eip_3860_active,\n        )\n\n    @pytest.fixture\n    def created_contract_address(self):\n\"\"\"\n        Calculates the address of the contract deployed via CREATE.\n        \"\"\"\n        return compute_create_address(\n            address=TestAddress,\n            nonce=0,\n        )\n\n    @pytest.fixture\n    def env(self) -&gt; Environment:  # noqa: D102\n        return Environment()\n\n    @pytest.fixture\n    def pre(self) -&gt; Dict[Any, Any]:  # noqa: D102\n        return {\n            TestAddress: Account(balance=1000000000000000000000),\n        }\n\n    @pytest.fixture\n    def tx_error(self, gas_test_case) -&gt; str | None:\n\"\"\"\n        Test that the transaction is invalid if too little intrinsic gas is\n        specified, otherwise the tx succeeds.\n        \"\"\"\n        if gas_test_case == \"too_little_intrinsic_gas\":\n            return \"intrinsic gas too low\"\n        return None\n\n    @pytest.fixture\n    def tx(\n        self,\n        gas_test_case,\n        initcode,\n        tx_error,\n        exact_intrinsic_gas,\n        exact_execution_gas,\n    ) -&gt; Transaction:\n\"\"\"\n        Implement the gas_test_case by setting the gas_limit of the tx\n        appropriately and test whether the tx succeeds or fails with\n        appropriate error.\n        \"\"\"\n        if gas_test_case == \"too_little_intrinsic_gas\":\n            gas_limit = exact_intrinsic_gas - 1\n        elif gas_test_case == \"exact_intrinsic_gas\":\n            gas_limit = exact_intrinsic_gas\n        elif gas_test_case == \"too_little_execution_gas\":\n            gas_limit = exact_execution_gas - 1\n        elif gas_test_case == \"exact_execution_gas\":\n            gas_limit = exact_execution_gas\n        else:\n            pytest.fail(\"Invalid gas test case provided.\")\n\n        return Transaction(\n            nonce=0,\n            to=None,\n            data=initcode,\n            gas_limit=gas_limit,\n            gas_price=10,\n            error=tx_error,\n        )\n\n    @pytest.fixture\n    def block(self, tx, tx_error) -&gt; Block:\n\"\"\"\n        Test that the tx_error is also propagated on the Block for the case of\n        too little intrinsic gas.\n        \"\"\"\n        return Block(txs=[tx], exception=tx_error)\n\n    @pytest.fixture\n    def post(\n        self,\n        gas_test_case,\n        initcode,\n        created_contract_address,\n        exact_intrinsic_gas,\n        exact_execution_gas,\n    ) -&gt; Dict[Any, Any]:\n\"\"\"\n        Test that contract creation fails unless enough execution gas is\n        provided.\n        \"\"\"\n        if (\n            gas_test_case == \"exact_intrinsic_gas\"\n            and exact_intrinsic_gas == exact_execution_gas\n        ):\n            # Special scenario where the execution of the initcode and\n            # gas cost to deploy are zero\n            return {\n                created_contract_address: Account(code=initcode.deploy_code)\n            }\n        elif gas_test_case == \"exact_execution_gas\":\n            return {\n                created_contract_address: Account(code=initcode.deploy_code)\n            }\n        return {created_contract_address: Account.NONEXISTENT}\n\n    def test_gas_usage(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        fork: Fork,\n        gas_test_case: str,\n        initcode: Initcode,\n        exact_intrinsic_gas,\n        exact_execution_gas,\n        env,\n        pre,\n        block,\n        post,\n    ):\n\"\"\"\n        Test transaction and contract creation behavior for different gas\n        limits.\n        \"\"\"\n        if (gas_test_case == \"too_little_execution_gas\") and (\n            exact_execution_gas == exact_intrinsic_gas\n        ):\n            pytest.skip(\n                \"Special case, the execution of the initcode and gas \"\n                \"cost to deploy are zero: Then this test case is \"\n                \"equivalent to that of 'test_exact_intrinsic_gas'.\"\n            )\n\n        blockchain_test(\n            pre=pre,\n            post=post,\n            blocks=[block],\n            genesis_environment=env,\n            tag=f\"{initcode.name}_{gas_test_case}\",\n        )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.exact_intrinsic_gas","title":"<code>exact_intrinsic_gas(initcode, eip_3860_active)</code>","text":"<p>Calculates the intrinsic tx gas cost.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef exact_intrinsic_gas(self, initcode, eip_3860_active):\n\"\"\"\n    Calculates the intrinsic tx gas cost.\n    \"\"\"\n    return calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.exact_execution_gas","title":"<code>exact_execution_gas(initcode, eip_3860_active)</code>","text":"<p>Calculates the total execution gas cost.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef exact_execution_gas(self, initcode, eip_3860_active):\n\"\"\"\n    Calculates the total execution gas cost.\n    \"\"\"\n    return calculate_create_tx_execution_cost(\n        initcode,\n        eip_3860_active,\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.created_contract_address","title":"<code>created_contract_address()</code>","text":"<p>Calculates the address of the contract deployed via CREATE.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef created_contract_address(self):\n\"\"\"\n    Calculates the address of the contract deployed via CREATE.\n    \"\"\"\n    return compute_create_address(\n        address=TestAddress,\n        nonce=0,\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.tx_error","title":"<code>tx_error(gas_test_case)</code>","text":"<p>Test that the transaction is invalid if too little intrinsic gas is specified, otherwise the tx succeeds.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef tx_error(self, gas_test_case) -&gt; str | None:\n\"\"\"\n    Test that the transaction is invalid if too little intrinsic gas is\n    specified, otherwise the tx succeeds.\n    \"\"\"\n    if gas_test_case == \"too_little_intrinsic_gas\":\n        return \"intrinsic gas too low\"\n    return None\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.tx","title":"<code>tx(gas_test_case, initcode, tx_error, exact_intrinsic_gas, exact_execution_gas)</code>","text":"<p>Implement the gas_test_case by setting the gas_limit of the tx appropriately and test whether the tx succeeds or fails with appropriate error.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef tx(\n    self,\n    gas_test_case,\n    initcode,\n    tx_error,\n    exact_intrinsic_gas,\n    exact_execution_gas,\n) -&gt; Transaction:\n\"\"\"\n    Implement the gas_test_case by setting the gas_limit of the tx\n    appropriately and test whether the tx succeeds or fails with\n    appropriate error.\n    \"\"\"\n    if gas_test_case == \"too_little_intrinsic_gas\":\n        gas_limit = exact_intrinsic_gas - 1\n    elif gas_test_case == \"exact_intrinsic_gas\":\n        gas_limit = exact_intrinsic_gas\n    elif gas_test_case == \"too_little_execution_gas\":\n        gas_limit = exact_execution_gas - 1\n    elif gas_test_case == \"exact_execution_gas\":\n        gas_limit = exact_execution_gas\n    else:\n        pytest.fail(\"Invalid gas test case provided.\")\n\n    return Transaction(\n        nonce=0,\n        to=None,\n        data=initcode,\n        gas_limit=gas_limit,\n        gas_price=10,\n        error=tx_error,\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.block","title":"<code>block(tx, tx_error)</code>","text":"<p>Test that the tx_error is also propagated on the Block for the case of too little intrinsic gas.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef block(self, tx, tx_error) -&gt; Block:\n\"\"\"\n    Test that the tx_error is also propagated on the Block for the case of\n    too little intrinsic gas.\n    \"\"\"\n    return Block(txs=[tx], exception=tx_error)\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.post","title":"<code>post(gas_test_case, initcode, created_contract_address, exact_intrinsic_gas, exact_execution_gas)</code>","text":"<p>Test that contract creation fails unless enough execution gas is provided.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef post(\n    self,\n    gas_test_case,\n    initcode,\n    created_contract_address,\n    exact_intrinsic_gas,\n    exact_execution_gas,\n) -&gt; Dict[Any, Any]:\n\"\"\"\n    Test that contract creation fails unless enough execution gas is\n    provided.\n    \"\"\"\n    if (\n        gas_test_case == \"exact_intrinsic_gas\"\n        and exact_intrinsic_gas == exact_execution_gas\n    ):\n        # Special scenario where the execution of the initcode and\n        # gas cost to deploy are zero\n        return {\n            created_contract_address: Account(code=initcode.deploy_code)\n        }\n    elif gas_test_case == \"exact_execution_gas\":\n        return {\n            created_contract_address: Account(code=initcode.deploy_code)\n        }\n    return {created_contract_address: Account.NONEXISTENT}\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.test_gas_usage","title":"<code>test_gas_usage(blockchain_test, fork, gas_test_case, initcode, exact_intrinsic_gas, exact_execution_gas, env, pre, block, post)</code>","text":"<p>Test transaction and contract creation behavior for different gas limits.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def test_gas_usage(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    gas_test_case: str,\n    initcode: Initcode,\n    exact_intrinsic_gas,\n    exact_execution_gas,\n    env,\n    pre,\n    block,\n    post,\n):\n\"\"\"\n    Test transaction and contract creation behavior for different gas\n    limits.\n    \"\"\"\n    if (gas_test_case == \"too_little_execution_gas\") and (\n        exact_execution_gas == exact_intrinsic_gas\n    ):\n        pytest.skip(\n            \"Special case, the execution of the initcode and gas \"\n            \"cost to deploy are zero: Then this test case is \"\n            \"equivalent to that of 'test_exact_intrinsic_gas'.\"\n        )\n\n    blockchain_test(\n        pre=pre,\n        post=post,\n        blocks=[block],\n        genesis_environment=env,\n        tag=f\"{initcode.name}_{gas_test_case}\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestCreateInitcode","title":"<code>TestCreateInitcode</code>","text":"<p>Test contract creation via the CREATE/CREATE2 opcodes that have an initcode that is on/over the max allowed limit.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n    \"initcode\",\n    [\n        INITCODE_ZEROS_MAX_LIMIT,\n        INITCODE_ONES_MAX_LIMIT,\n        INITCODE_ZEROS_OVER_LIMIT,\n        INITCODE_ONES_OVER_LIMIT,\n        EMPTY_INITCODE,\n        SINGLE_BYTE_INITCODE,\n        INITCODE_ZEROS_32_BYTES,\n        INITCODE_ZEROS_33_BYTES,\n        INITCODE_ZEROS_49120_BYTES,\n        INITCODE_ZEROS_49121_BYTES,\n    ],\n    ids=get_initcode_name,\n)\n@pytest.mark.parametrize(\"opcode\", [Op.CREATE, Op.CREATE2], ids=get_create_id)\nclass TestCreateInitcode:\n\"\"\"\n    Test contract creation via the CREATE/CREATE2 opcodes that have an initcode\n    that is on/over the max allowed limit.\n    \"\"\"\n\n    @pytest.fixture\n    def create_code(self, opcode: Op, initcode: Initcode):  # noqa: D102\n        if opcode == Op.CREATE:\n            create_call = Op.CREATE(0, 0, Op.CALLDATASIZE)\n        elif opcode == Op.CREATE2:\n            create_call = Op.CREATE2(0, 0, Op.CALLDATASIZE, 0xDEADBEEF)\n        else:\n            raise Exception(\"Invalid opcode specified for test.\")\n        return (\n            Op.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\n            + Op.GAS\n            + create_call\n            + Op.GAS\n            # stack: [Gas 2, Call Result, Gas 1]\n            + Op.SWAP1\n            # stack: [Call Result, Gas 2, Gas 1]\n            + Op.SSTORE(0)\n            # stack: [Gas 2, Gas 1]\n            + Op.SWAP1\n            # stack: [Gas 1, Gas 2]\n            + Op.SUB\n            # stack: [Gas 1 - Gas 2]\n            + Op.SSTORE(1)\n        )\n\n    @pytest.fixture\n    def created_contract_address(  # noqa: D102\n        self, initcode: Initcode, opcode: Op\n    ):\n        if opcode == Op.CREATE:\n            return compute_create_address(\n                address=0x100,\n                nonce=1,\n            )\n        if opcode == Op.CREATE2:\n            return compute_create2_address(\n                address=0x100,\n                salt=0xDEADBEEF,\n                initcode=initcode.assemble(),\n            )\n        raise Exception(\"invalid opcode for generator\")\n\n    def test_create_opcode_initcode(\n        self,\n        state_test: StateTestFiller,\n        opcode: Op,\n        initcode: Initcode,\n        create_code: Yul,\n        created_contract_address: str,\n    ):\n\"\"\"\n        Test contract creation via the CREATE/CREATE2 opcodes that have an\n        initcode that is on/over the max allowed limit.\n        \"\"\"\n        eip_3860_active = True\n        env = Environment()\n\n        call_code = Op.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\n        call_code += Op.SSTORE(\n            Op.CALL(5000000, 0x100, 0, 0, Op.CALLDATASIZE, 0, 0),\n            1,\n        )\n\n        pre = {\n            TestAddress: Account(balance=1000000000000000000000),\n            to_address(0x100): Account(\n                code=create_code,\n                nonce=1,\n            ),\n            to_address(0x200): Account(\n                code=call_code,\n                nonce=1,\n            ),\n        }\n\n        post: Dict[Any, Any] = {}\n\n        tx = Transaction(\n            nonce=0,\n            to=to_address(0x200),\n            data=initcode,\n            gas_limit=10000000,\n            gas_price=10,\n        )\n\n        # Calculate the expected gas of the contract creation operation\n        expected_gas_usage = (\n            CREATE_CONTRACT_BASE_GAS\n            + GAS_OPCODE_GAS\n            + (2 * PUSH_DUP_OPCODE_GAS)\n            + CALLDATASIZE_OPCODE_GAS\n        )\n        if opcode == Op.CREATE2:\n            # Extra PUSH operation\n            expected_gas_usage += PUSH_DUP_OPCODE_GAS\n\n        if len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n            # Call returns 0 as out of gas s[0]==1\n            post[to_address(0x200)] = Account(\n                nonce=1,\n                storage={\n                    0: 1,\n                    1: 0,\n                },\n            )\n\n            post[created_contract_address] = Account.NONEXISTENT\n            post[to_address(0x100)] = Account(\n                nonce=1,\n                storage={\n                    0: 0,\n                    1: 0,\n                },\n            )\n\n        else:\n            # The initcode is only executed if the length check succeeds\n            expected_gas_usage += initcode.execution_gas\n            # The code is only deployed if the length check succeeds\n            expected_gas_usage += initcode.deployment_gas\n\n            if opcode == Op.CREATE2:\n                # CREATE2 hashing cost should only be deducted if the initcode\n                # does not exceed the max length\n                expected_gas_usage += calculate_create2_word_cost(\n                    len(initcode.assemble())\n                )\n\n            if eip_3860_active:\n                # Initcode word cost is only deducted if the length check\n                # succeeds\n                expected_gas_usage += calculate_initcode_word_cost(\n                    len(initcode.assemble())\n                )\n\n            # Call returns 1 as valid initcode length s[0]==1 &amp;&amp; s[1]==1\n            post[to_address(0x200)] = Account(\n                nonce=1,\n                storage={\n                    0: 0,\n                    1: 1,\n                },\n            )\n\n            post[created_contract_address] = Account(code=initcode.deploy_code)\n            post[to_address(0x100)] = Account(\n                nonce=2,\n                storage={\n                    0: created_contract_address,\n                    1: expected_gas_usage,\n                },\n            )\n\n        state_test(\n            env=env,\n            pre=pre,\n            post=post,\n            txs=[tx],\n            tag=f\"{initcode.name}_{opcode}\",\n        )\n</code></pre>"},{"location":"fillers/EIPs/eip3860/#fillers.eips.eip3860.TestCreateInitcode.test_create_opcode_initcode","title":"<code>test_create_opcode_initcode(state_test, opcode, initcode, create_code, created_contract_address)</code>","text":"<p>Test contract creation via the CREATE/CREATE2 opcodes that have an initcode that is on/over the max allowed limit.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def test_create_opcode_initcode(\n    self,\n    state_test: StateTestFiller,\n    opcode: Op,\n    initcode: Initcode,\n    create_code: Yul,\n    created_contract_address: str,\n):\n\"\"\"\n    Test contract creation via the CREATE/CREATE2 opcodes that have an\n    initcode that is on/over the max allowed limit.\n    \"\"\"\n    eip_3860_active = True\n    env = Environment()\n\n    call_code = Op.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\n    call_code += Op.SSTORE(\n        Op.CALL(5000000, 0x100, 0, 0, Op.CALLDATASIZE, 0, 0),\n        1,\n    )\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000),\n        to_address(0x100): Account(\n            code=create_code,\n            nonce=1,\n        ),\n        to_address(0x200): Account(\n            code=call_code,\n            nonce=1,\n        ),\n    }\n\n    post: Dict[Any, Any] = {}\n\n    tx = Transaction(\n        nonce=0,\n        to=to_address(0x200),\n        data=initcode,\n        gas_limit=10000000,\n        gas_price=10,\n    )\n\n    # Calculate the expected gas of the contract creation operation\n    expected_gas_usage = (\n        CREATE_CONTRACT_BASE_GAS\n        + GAS_OPCODE_GAS\n        + (2 * PUSH_DUP_OPCODE_GAS)\n        + CALLDATASIZE_OPCODE_GAS\n    )\n    if opcode == Op.CREATE2:\n        # Extra PUSH operation\n        expected_gas_usage += PUSH_DUP_OPCODE_GAS\n\n    if len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n        # Call returns 0 as out of gas s[0]==1\n        post[to_address(0x200)] = Account(\n            nonce=1,\n            storage={\n                0: 1,\n                1: 0,\n            },\n        )\n\n        post[created_contract_address] = Account.NONEXISTENT\n        post[to_address(0x100)] = Account(\n            nonce=1,\n            storage={\n                0: 0,\n                1: 0,\n            },\n        )\n\n    else:\n        # The initcode is only executed if the length check succeeds\n        expected_gas_usage += initcode.execution_gas\n        # The code is only deployed if the length check succeeds\n        expected_gas_usage += initcode.deployment_gas\n\n        if opcode == Op.CREATE2:\n            # CREATE2 hashing cost should only be deducted if the initcode\n            # does not exceed the max length\n            expected_gas_usage += calculate_create2_word_cost(\n                len(initcode.assemble())\n            )\n\n        if eip_3860_active:\n            # Initcode word cost is only deducted if the length check\n            # succeeds\n            expected_gas_usage += calculate_initcode_word_cost(\n                len(initcode.assemble())\n            )\n\n        # Call returns 1 as valid initcode length s[0]==1 &amp;&amp; s[1]==1\n        post[to_address(0x200)] = Account(\n            nonce=1,\n            storage={\n                0: 0,\n                1: 1,\n            },\n        )\n\n        post[created_contract_address] = Account(code=initcode.deploy_code)\n        post[to_address(0x100)] = Account(\n            nonce=2,\n            storage={\n                0: created_contract_address,\n                1: expected_gas_usage,\n            },\n        )\n\n    state_test(\n        env=env,\n        pre=pre,\n        post=post,\n        txs=[tx],\n        tag=f\"{initcode.name}_{opcode}\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/","title":"EIP-4844","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip4844\n</code></pre> <p>Cross-client Ethereum EIP-4844 Tests</p>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/","title":"datahash_opcode","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip4844/datahash_opcode.py\n</code></pre> <p>Test EIP-4844: Shard Blob Transactions (DATAHASH Opcode) EIP: https://eips.ethereum.org/EIPS/eip-4844</p>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/#fillers.eips.eip4844.datahash_opcode.test_datahash_opcode_contexts","title":"<code>test_datahash_opcode_contexts(_)</code>","text":"<p>Test DATAHASH opcode called on different contexts.</p> Source code in <code>fillers/eips/eip4844/datahash_opcode.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_datahash_opcode_contexts(_: Fork):\n\"\"\"\n    Test DATAHASH opcode called on different contexts.\n    \"\"\"\n    datahash_verbatim = \"verbatim_{}i_{}o\".format(\n        Op.DATAHASH.popped_stack_items, Op.DATAHASH.pushed_stack_items\n    )\n\n    datahash_sstore_bytecode = Yul(\n        f\"\"\"\n{{\n           let pos := calldataload(0)\n           let end := calldataload(32)\n           for {{}} lt(pos, end) {{ pos := add(pos, 1) }}\n{{\n            let datahash := {datahash_verbatim}(hex\"{Op.DATAHASH.hex()}\", pos)\n            sstore(pos, datahash)\n}}\n           let datahash := {datahash_verbatim}(hex\"{Op.DATAHASH.hex()}\", end)\n           sstore(end, datahash)\n           return(0, 0)\n}}\n        \"\"\"\n    )\n    datahash_sstore_bytecode_address = to_address(0x100)\n\n    datahash_return_bytecode = Yul(\n        f\"\"\"\n{{\n           let pos := calldataload(0)\n           let datahash := {datahash_verbatim}(hex\"{Op.DATAHASH.hex()}\", pos)\n           mstore(0, datahash)\n           return(0, 32)\n}}\n        \"\"\"\n    )\n    datahash_return_bytecode_address = to_address(0x600)\n\n    initcode_datahash_sstore_bytecode = Yul(\n        f\"\"\"\n{{\n           for {{ let pos := 0 }} lt(pos, 10) {{ pos := add(pos, 1) }}\n{{\n            let datahash := {datahash_verbatim}(hex\"{Op.DATAHASH.hex()}\", pos)\n            sstore(pos, datahash)\n}}\n           return(0, 0)\n}}\n        \"\"\"\n    )\n    tx_created_contract_address = compute_create_address(TestAddress, 0)\n\n    call_bytecode = Yul(\n\"\"\"\n        {\n            calldatacopy(0, 0, calldatasize())\n            pop(call(gas(), 0x100, 0, 0, calldatasize(), 0, 0))\n        }\n        \"\"\"\n    )\n    call_bytecode_address = to_address(0x200)\n\n    delegatecall_bytecode = Yul(\n\"\"\"\n        {\n            calldatacopy(0, 0, calldatasize())\n            pop(delegatecall(gas(), 0x100, 0, calldatasize(), 0, 0))\n        }\n        \"\"\"\n    )\n    delegatecall_bytecode_address = to_address(0x300)\n\n    callcode_bytecode = Yul(\n        f\"\"\"\n{{\n    let pos := calldataload(0)\n    let end := calldataload(32)\n    for {{ }} lt(pos, end) {{ pos := add(pos, 1) }}\n{{\n    mstore(0, pos)\n    pop(callcode(gas(), {datahash_return_bytecode_address}, 0, 0, 32, 0, 32))\n    let datahash := mload(0)\n    sstore(pos, datahash)\n}}\n\n    mstore(0, end)\n    pop(callcode(gas(), {datahash_return_bytecode_address}, 0, 0, 32, 0, 32))\n    let datahash := mload(0)\n    sstore(end, datahash)\n    return(0, 0)\n}}\n        \"\"\"\n    )\n    callcode_bytecode_address = to_address(0x800)\n\n    staticcall_bytecode = Yul(\n        f\"\"\"\n{{\n    let pos := calldataload(0)\n    let end := calldataload(32)\n    for {{ }} lt(pos, end) {{ pos := add(pos, 1) }}\n{{\n    mstore(0, pos)\n    pop(staticcall(gas(), {datahash_return_bytecode_address}, 0, 32, 0, 32))\n    let datahash := mload(0)\n    sstore(pos, datahash)\n}}\n\n    mstore(0, end)\n    pop(staticcall(gas(), {datahash_return_bytecode_address}, 0, 32, 0, 32))\n    let datahash := mload(0)\n    sstore(end, datahash)\n    return(0, 0)\n}}\n        \"\"\"\n    )\n    staticcall_bytecode_address = to_address(0x700)\n\n    create_bytecode = Yul(\n\"\"\"\n        {\n            calldatacopy(0, 0, calldatasize())\n            pop(create(0, 0, calldatasize()))\n        }\n        \"\"\"\n    )\n    create_bytecode_address = to_address(0x400)\n    create_opcode_created_contract = compute_create_address(\n        create_bytecode_address, 0\n    )\n\n    create2_bytecode = Yul(\n\"\"\"\n        {\n            calldatacopy(0, 0, calldatasize())\n            pop(create2(0, 0, calldatasize(), 0))\n        }\n        \"\"\"\n    )\n    create2_bytecode_address = to_address(0x500)\n    create2_opcode_created_contract = compute_create2_address(\n        create2_bytecode_address,\n        0,\n        initcode_datahash_sstore_bytecode.assemble(),\n    )\n\n    b_hashes: Sequence[bytes] = [\n        to_hash_bytes(1 &lt;&lt; x) for x in range(MAX_BLOB_PER_BLOCK)\n    ]\n\n    tags = [\n        \"at_top_level_call_stack\",\n        \"max_value\",\n        \"on_call\",\n        \"on_delegatecall\",\n        \"on_staticcall\",\n        \"on_callcode\",\n        \"on_initcode\",\n        \"on_create\",\n        \"on_create2\",\n        \"tx_type_2\",\n        \"tx_type_1\",\n        \"tx_type_0\",\n    ]\n\n    pre_states: List[Dict] = [\n        {  # DATAHASH on top level of the call stack\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH max value\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH on CALL\n            call_bytecode_address: Account(code=call_bytecode),\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH on DELEGATECALL\n            delegatecall_bytecode_address: Account(code=delegatecall_bytecode),\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH on STATICCALL\n            staticcall_bytecode_address: Account(code=staticcall_bytecode),\n            datahash_return_bytecode_address: Account(\n                code=datahash_return_bytecode\n            ),\n        },\n        {  # DATAHASH on CALLCODE\n            callcode_bytecode_address: Account(code=callcode_bytecode),\n            datahash_return_bytecode_address: Account(\n                code=datahash_return_bytecode\n            ),\n        },\n        {},  # DATAHASH on INITCODE\n        {  # DATAHASH on CREATE\n            create_bytecode_address: Account(code=create_bytecode),\n        },\n        {  # DATAHASH on CREATE2\n            create2_bytecode_address: Account(code=create2_bytecode),\n        },\n        {  # DATAHASH on type 2 tx\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH on type 1 tx\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n        {  # DATAHASH on type 0 tx\n            datahash_sstore_bytecode_address: Account(\n                code=datahash_sstore_bytecode\n            ),\n        },\n    ]\n\n    # Type 3 tx template\n    tx_type_3 = Transaction(\n        ty=3,\n        data=to_hash_bytes(0),\n        gas_limit=3000000,\n        max_fee_per_gas=10,\n        max_priority_fee_per_gas=10,\n        max_fee_per_data_gas=10,\n        access_list=[],\n        blob_versioned_hashes=b_hashes,\n    )\n\n    txs = [\n        tx_type_3.with_fields(  # DATAHASH on top level of the call stack\n            to=datahash_sstore_bytecode_address,\n            blob_versioned_hashes=b_hashes[:1],\n        ),\n        tx_type_3.with_fields(  # DATAHASH on max value\n            data=to_hash_bytes(2**256 - 1) + to_hash_bytes(2**256 - 1),\n            to=datahash_sstore_bytecode_address,\n        ),\n        tx_type_3.with_fields(  # DATAHASH on CALL\n            data=to_hash_bytes(1) + to_hash_bytes(1),\n            to=call_bytecode_address,\n            blob_versioned_hashes=b_hashes[:2],\n        ),\n        tx_type_3.with_fields(  # DATAHASH on DELEGATECALL\n            data=to_hash_bytes(0) + to_hash_bytes(3),\n            to=delegatecall_bytecode_address,\n        ),\n        tx_type_3.with_fields(  # DATAHASH on STATICCALL\n            data=to_hash_bytes(0) + to_hash_bytes(3),\n            to=staticcall_bytecode_address,\n        ),\n        tx_type_3.with_fields(  # DATAHASH on CALLCODE\n            data=to_hash_bytes(0) + to_hash_bytes(3),\n            to=callcode_bytecode_address,\n        ),\n        tx_type_3.with_fields(  # DATAHASH on INITCODE\n            data=initcode_datahash_sstore_bytecode, to=None\n        ),\n        tx_type_3.with_fields(  # DATAHASH on CREATE\n            data=initcode_datahash_sstore_bytecode,\n            to=create_bytecode_address,\n        ),\n        tx_type_3.with_fields(  # DATAHASH on CREATE2\n            data=initcode_datahash_sstore_bytecode,\n            to=create2_bytecode_address,\n        ),\n        Transaction(  # DATAHASH on type 2 tx\n            ty=2,\n            data=to_hash_bytes(0),\n            to=datahash_sstore_bytecode_address,\n            gas_limit=3000000,\n            max_fee_per_gas=10,\n            max_priority_fee_per_gas=10,\n            access_list=[],\n        ),\n        Transaction(  # DATAHASH on type 1 tx\n            ty=1,\n            data=to_hash_bytes(0),\n            to=datahash_sstore_bytecode_address,\n            gas_limit=3000000,\n            gas_price=10,\n            access_list=[],\n        ),\n        Transaction(  # DATAHASH on type 0 tx\n            ty=0,\n            data=to_hash_bytes(0),\n            to=datahash_sstore_bytecode_address,\n            gas_limit=3000000,\n            gas_price=10,\n        ),\n    ]\n\n    post_states: List[Dict] = [\n        {  # DATAHASH on top level of the call stack\n            datahash_sstore_bytecode_address: Account(\n                storage={0: b_hashes[0]}\n            ),\n        },\n        {  # DATAHASH on max value\n            datahash_sstore_bytecode_address: Account(storage={}),\n        },\n        {  # DATAHASH on CALL\n            datahash_sstore_bytecode_address: Account(\n                storage={1: b_hashes[1]}\n            ),\n        },\n        {  # DATAHASH on DELEGATECALL\n            delegatecall_bytecode_address: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on STATICCALL\n            staticcall_bytecode_address: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on CALLCODE\n            callcode_bytecode_address: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on INITCODE\n            tx_created_contract_address: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on CREATE\n            create_opcode_created_contract: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on CREATE2\n            create2_opcode_created_contract: Account(\n                storage={\n                    k: v for (k, v) in zip(range(len(b_hashes)), b_hashes)\n                }\n            ),\n        },\n        {  # DATAHASH on type 2 tx\n            datahash_sstore_bytecode_address: Account(storage={0: 0}),\n        },\n        {  # DATAHASH on type 1 tx\n            datahash_sstore_bytecode_address: Account(storage={0: 0}),\n        },\n        {  # DATAHASH on type 0 tx\n            datahash_sstore_bytecode_address: Account(storage={0: 0}),\n        },\n    ]\n\n    for pre, post, tag, tx in zip(pre_states, post_states, tags, txs):\n        pre[TestAddress] = Account(balance=1000000000000000000000)\n        yield StateTest(\n            env=env,\n            pre=pre,\n            post=post,\n            txs=[tx],\n            tag=tag,\n        )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/#fillers.eips.eip4844.datahash_opcode.test_datahash_gas_cost","title":"<code>test_datahash_gas_cost(_)</code>","text":"<p>Test DATAHASH opcode gas cost using a variety of indexes.</p> Source code in <code>fillers/eips/eip4844/datahash_opcode.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_datahash_gas_cost(_: Fork):\n\"\"\"\n    Test DATAHASH opcode gas cost using a variety of indexes.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000),\n    }\n    tx = Transaction(  # Transaction template\n        data=to_hash_bytes(0),\n        gas_limit=3000000,\n        max_fee_per_gas=10,\n        max_fee_per_data_gas=10,\n    )\n    post = {}\n\n    # Declare datahash indexes: zero, max &amp; random values\n    datahash_index_measures: List[int] = [\n        0x00,\n        0x01,\n        0x02,\n        0x03,\n        0x04,\n        2**256 - 1,\n        0x30A9B2A6C3F3F0675B768D49B5F5DC5B5D988F88D55766247BA9E40B125F16BB,\n        0x4FA4D4CDE4AA01E57FB2C880D1D9C778C33BDF85E48EF4C4D4B4DE51ABCCF4ED,\n        0x7871C9B8A0C72D38F5E5B5D08E5CB5CE5E23FB1BC5D75F9C29F7B94DF0BCEEB7,\n        0xA12C8B6A8B11410C7D98D790E1098F1ED6D93CB7A64711481AAAB1848E13212F,\n    ]\n\n    gas_measures_code = [\n        CodeGasMeasure(\n            code=Op.DATAHASH(index),\n            overhead_cost=3,\n            extra_stack_items=1,\n        )\n        for index in datahash_index_measures\n    ]\n\n    txs_type_0, txs_type_1, txs_type_2, txs_type_3 = ([] for _ in range(4))\n    for i, code in enumerate(gas_measures_code):\n        address = to_address(0x100 + i * 0x100)\n        pre[address] = Account(code=code)\n        txs_type_0.append(\n            tx.with_fields(ty=0, to=address, nonce=i, gas_price=10)\n        )\n        txs_type_1.append(\n            tx.with_fields(ty=1, to=address, nonce=i, gas_price=10)\n        )\n        txs_type_2.append(\n            tx.with_fields(\n                ty=2,\n                to=address,\n                nonce=i,\n                max_priority_fee_per_gas=10,\n                blob_versioned_hashes=[BLOB_HASHES[i % MAX_BLOB_PER_BLOCK]],\n            )\n        )\n        txs_type_3.append(\n            tx.with_fields(\n                ty=3,\n                to=address,\n                nonce=i,\n                max_priority_fee_per_gas=10,\n                blob_versioned_hashes=[BLOB_HASHES[i % MAX_BLOB_PER_BLOCK]],\n            )\n        )\n        post[address] = Account(storage={0: DATAHASH_GAS_COST})\n\n    # DATAHASH gas cost on tx type 0, 1 &amp; 2\n    for i, txs in enumerate([txs_type_0, txs_type_1, txs_type_2]):\n        yield StateTest(\n            env=env, pre=pre, post=post, txs=txs, tag=f\"tx_type_{i}\"\n        )\n\n    # DATAHASH gas cost on tx type 3\n    total_blocks = (\n        len(txs_type_3) + MAX_BLOB_PER_BLOCK - 1\n    ) // MAX_BLOB_PER_BLOCK\n    blocks = [\n        Block(\n            txs=txs_type_3[\n                i * MAX_BLOB_PER_BLOCK : (i + 1) * MAX_BLOB_PER_BLOCK\n            ]\n        )\n        for i in range(total_blocks)\n    ]\n\n    yield BlockchainTest(pre=pre, post=post, blocks=blocks, tag=\"tx_type_3\")\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/#fillers.eips.eip4844.datahash_opcode.test_datahash_blob_versioned_hash","title":"<code>test_datahash_blob_versioned_hash(_)</code>","text":"<p>Tests that the <code>DATAHASH</code> opcode returns the correct versioned hash for various valid index scenarios.</p> Source code in <code>fillers/eips/eip4844/datahash_opcode.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_datahash_blob_versioned_hash(_: Fork):\n\"\"\"\n    Tests that the `DATAHASH` opcode returns the correct versioned hash for\n    various valid index scenarios.\n    \"\"\"\n    TOTAL_BLOCKS = 10\n\n    pre = {\n        TestAddress: Account(balance=10000000000000000000000),\n    }\n    post = {}\n    blocks = []\n\n    # Create an arbitrary repeated list of blob hashes\n    # with length MAX_BLOB_PER_BLOCK * TOTAL_BLOCKS\n    b_hashes = list(\n        itertools.islice(\n            itertools.cycle(BLOB_HASHES),\n            MAX_BLOB_PER_BLOCK * TOTAL_BLOCKS,\n        )\n    )\n\n    # `DATAHASH` sstore template helper\n    def datahash_sstore(index: int):\n        return Op.SSTORE(index, Op.DATAHASH(index))\n\n    # `DATAHASH` on valid indexes\n    datahash_single_valid_calls = b\"\".join(\n        datahash_sstore(i) for i in range(MAX_BLOB_PER_BLOCK)\n    )\n    pre_single_valid_calls = copy(pre)\n\n    # `DATAHASH` on valid index repeated:\n    # DATAHASH(i), DATAHASH(i), ...\n    datahash_repeated_valid_calls = b\"\".join(\n        b\"\".join([datahash_sstore(i) for _ in range(10)])\n        for i in range(MAX_BLOB_PER_BLOCK)\n    )\n    pre_datahash_repeated_valid_calls = copy(pre)\n\n    # `DATAHASH` on valid/invalid/valid:\n    # DATAHASH(i), DATAHASH(MAX_BLOB_PER_BLOCK), DATAHASH(i)\n    datahash_valid_invalid_calls = b\"\".join(\n        datahash_sstore(i)\n        + datahash_sstore(MAX_BLOB_PER_BLOCK)\n        + datahash_sstore(i)\n        for i in range(MAX_BLOB_PER_BLOCK)\n    )\n    pre_datahash_valid_invalid_calls = copy(pre)\n\n    # `DATAHASH` on different valid indexes repeated:\n    # DATAHASH(i), DATAHASH(i+1), DATAHASH(i)\n    datahash_varied_valid_calls = b\"\".join(\n        datahash_sstore(i) + datahash_sstore(i + 1) + datahash_sstore(i)\n        for i in range(MAX_BLOB_PER_BLOCK - 1)\n    )\n    pre_datahash_varied_valid_calls = copy(pre)\n\n    for i in range(TOTAL_BLOCKS):\n        address = to_address(0x100 + i * 0x100)\n        pre_single_valid_calls[address] = Account(\n            code=datahash_single_valid_calls\n        )\n        pre_datahash_repeated_valid_calls[address] = Account(\n            code=datahash_repeated_valid_calls\n        )\n        pre_datahash_valid_invalid_calls[address] = Account(\n            code=datahash_valid_invalid_calls\n        )\n        pre_datahash_varied_valid_calls[address] = Account(\n            code=datahash_varied_valid_calls\n        )\n        blocks.append(\n            Block(\n                txs=[  # Create tx with max blobs per block\n                    Transaction(\n                        ty=3,\n                        nonce=i,\n                        data=to_hash_bytes(0),\n                        to=address,\n                        gas_limit=3000000,\n                        max_fee_per_gas=10,\n                        max_priority_fee_per_gas=10,\n                        max_fee_per_data_gas=10,\n                        access_list=[],\n                        blob_versioned_hashes=b_hashes[\n                            (i * MAX_BLOB_PER_BLOCK) : (i + 1)\n                            * MAX_BLOB_PER_BLOCK\n                        ],\n                    )\n                ]\n            )\n        )\n        post[address] = Account(\n            storage={\n                index: b_hashes[i * MAX_BLOB_PER_BLOCK + index]\n                for index in range(MAX_BLOB_PER_BLOCK)\n            }\n        )\n\n    yield BlockchainTest(\n        pre=pre_single_valid_calls,\n        post=post,\n        blocks=blocks,\n        tag=\"valid_calls\",\n    )\n\n    yield BlockchainTest(\n        pre=pre_datahash_repeated_valid_calls,\n        post=post,\n        blocks=blocks,\n        tag=\"repeated_calls\",\n    )\n\n    yield BlockchainTest(\n        pre=pre_datahash_valid_invalid_calls,\n        post=post,\n        blocks=blocks,\n        tag=\"valid_invalid_calls\",\n    )\n\n    yield BlockchainTest(\n        pre=pre_datahash_varied_valid_calls,\n        post=post,\n        blocks=blocks,\n        tag=\"varied_valid_calls\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/#fillers.eips.eip4844.datahash_opcode.test_datahash_invalid_blob_index","title":"<code>test_datahash_invalid_blob_index(_)</code>","text":"<p>Tests that the <code>DATAHASH</code> opcode returns a zeroed bytes32 value for invalid indexes.</p> Source code in <code>fillers/eips/eip4844/datahash_opcode.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_datahash_invalid_blob_index(_: Fork):\n\"\"\"\n    Tests that the `DATAHASH` opcode returns a zeroed bytes32 value\n    for invalid indexes.\n    \"\"\"\n    INVALID_DEPTH_FACTOR = 5\n    TOTAL_BLOCKS = 5\n\n    pre = {\n        TestAddress: Account(balance=10000000000000000000000),\n    }\n    blocks = []\n    post = {}\n\n    # `DATAHASH` on invalid indexes: -ve invalid -&gt; valid -&gt; +ve invalid:\n    datahash_invalid_calls = b\"\".join(\n        Op.SSTORE(i, Op.DATAHASH(i))\n        for i in range(\n            -INVALID_DEPTH_FACTOR, MAX_BLOB_PER_BLOCK + INVALID_DEPTH_FACTOR\n        )\n    )\n\n    for i in range(TOTAL_BLOCKS):\n        address = to_address(0x100 + i * 0x100)\n        pre[address] = Account(code=datahash_invalid_calls)\n        blob_per_block = (i % MAX_BLOB_PER_BLOCK) + 1\n        blob_hashes = [BLOB_HASHES[blob] for blob in range(blob_per_block)]\n        blocks.append(\n            Block(\n                txs=[\n                    Transaction(\n                        ty=3,\n                        nonce=i,\n                        data=to_hash_bytes(0),\n                        to=address,\n                        gas_limit=3000000,\n                        max_fee_per_gas=10,\n                        max_priority_fee_per_gas=10,\n                        max_fee_per_data_gas=10,\n                        access_list=[],\n                        blob_versioned_hashes=blob_hashes,\n                    )\n                ]\n            )\n        )\n        post[address] = Account(\n            storage={\n                index: (\n                    0\n                    if index &lt; 0 or index &gt;= blob_per_block\n                    else blob_hashes[index]\n                )\n                for index in range(\n                    -INVALID_DEPTH_FACTOR,\n                    blob_per_block\n                    + (INVALID_DEPTH_FACTOR - (i % MAX_BLOB_PER_BLOCK)),\n                )\n            }\n        )\n\n    yield BlockchainTest(\n        pre=pre,\n        post=post,\n        blocks=blocks,\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/datahash_opcode/#fillers.eips.eip4844.datahash_opcode.test_datahash_multiple_txs_in_block","title":"<code>test_datahash_multiple_txs_in_block(_)</code>","text":"<p>Tests that the <code>DATAHASH</code> opcode returns the appropriate values when there is more than one blob tx type within a block.</p> Source code in <code>fillers/eips/eip4844/datahash_opcode.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_datahash_multiple_txs_in_block(_: Fork):\n\"\"\"\n    Tests that the `DATAHASH` opcode returns the appropriate values\n    when there is more than one blob tx type within a block.\n    \"\"\"\n    datahash_valid_call = b\"\".join(\n        [Op.SSTORE(i, Op.DATAHASH(i)) for i in range(MAX_BLOB_PER_BLOCK)]\n    )\n\n    pre = {\n        to_address(address): Account(code=datahash_valid_call)\n        for address in range(0x100, 0x500, 0x100)\n    }\n    pre[TestAddress] = Account(balance=10000000000000000000000)\n\n    tx = Transaction(\n        data=to_hash_bytes(0),\n        gas_limit=3000000,\n        max_fee_per_gas=10,\n        max_priority_fee_per_gas=10,\n        max_fee_per_data_gas=10,\n        access_list=[],\n        blob_versioned_hashes=BLOB_HASHES[0:MAX_BLOB_PER_BLOCK],\n    )\n\n    blocks = [\n        Block(\n            txs=[\n                tx.with_fields(ty=3, nonce=0, to=to_address(0x100)),\n                tx.with_fields(ty=2, nonce=1, to=to_address(0x100)),\n            ]\n        ),\n        Block(\n            txs=[\n                tx.with_fields(ty=2, nonce=2, to=to_address(0x200)),\n                tx.with_fields(ty=3, nonce=3, to=to_address(0x200)),\n            ]\n        ),\n        Block(\n            txs=[\n                tx.with_fields(ty=2, nonce=4, to=to_address(0x300)),\n                tx.with_fields(ty=3, nonce=5, to=to_address(0x400)),\n            ]\n        ),\n    ]\n\n    post = {\n        to_address(address): Account(\n            storage={i: BLOB_HASHES[i] for i in range(MAX_BLOB_PER_BLOCK)}\n        )\n        if address in (0x200, 0x400)\n        else Account(storage={i: 0 for i in range(MAX_BLOB_PER_BLOCK)})\n        for address in range(0x100, 0x500, 0x100)\n    }\n\n    yield BlockchainTest(\n        pre=pre,\n        post=post,\n        blocks=blocks,\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/","title":"excess_data_gas","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/eips/eip4844/excess_data_gas.py\n</code></pre> <p>Test EIP-4844: Shard Blob Transactions (Excess Data Tests) EIP: https://eips.ethereum.org/EIPS/eip-4844</p>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.fake_exponential","title":"<code>fake_exponential(factor, numerator, denominator)</code>","text":"<p>Used to calculate the data gas cost.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def fake_exponential(factor: int, numerator: int, denominator: int) -&gt; int:\n\"\"\"\n    Used to calculate the data gas cost.\n    \"\"\"\n    i = 1\n    output = 0\n    numerator_accumulator = factor * denominator\n    while numerator_accumulator &gt; 0:\n        output += numerator_accumulator\n        numerator_accumulator = (numerator_accumulator * numerator) // (\n            denominator * i\n        )\n        i += 1\n    return output // denominator\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.calc_data_fee","title":"<code>calc_data_fee(tx, excess_data_gas)</code>","text":"<p>Calculate the data fee for a transaction.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def calc_data_fee(tx: Transaction, excess_data_gas: int) -&gt; int:\n\"\"\"\n    Calculate the data fee for a transaction.\n    \"\"\"\n    return get_total_data_gas(tx) * get_data_gasprice(excess_data_gas)\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.get_total_data_gas","title":"<code>get_total_data_gas(tx)</code>","text":"<p>Calculate the total data gas for a transaction.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def get_total_data_gas(tx: Transaction) -&gt; int:\n\"\"\"\n    Calculate the total data gas for a transaction.\n    \"\"\"\n    if tx.blob_versioned_hashes is None:\n        return 0\n    return DATA_GAS_PER_BLOB * len(tx.blob_versioned_hashes)\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.get_data_gasprice_from_blobs","title":"<code>get_data_gasprice_from_blobs(excess_blobs)</code>","text":"<p>Calculate the data gas price from the excess blob count.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def get_data_gasprice_from_blobs(excess_blobs: int) -&gt; int:\n\"\"\"\n    Calculate the data gas price from the excess blob count.\n    \"\"\"\n    return fake_exponential(\n        MIN_DATA_GASPRICE,\n        excess_blobs * DATA_GAS_PER_BLOB,\n        DATA_GASPRICE_UPDATE_FRACTION,\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.get_data_gasprice","title":"<code>get_data_gasprice(excess_data_gas)</code>","text":"<p>Calculate the data gas price from the excess.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def get_data_gasprice(excess_data_gas: int) -&gt; int:\n\"\"\"\n    Calculate the data gas price from the excess.\n    \"\"\"\n    return fake_exponential(\n        MIN_DATA_GASPRICE,\n        excess_data_gas,\n        DATA_GASPRICE_UPDATE_FRACTION,\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.calc_excess_data_gas","title":"<code>calc_excess_data_gas(parent_excess_data_gas, new_blobs)</code>","text":"<p>Calculate the excess data gas for a block given the parent excess data gas and the number of blobs in the block.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def calc_excess_data_gas(parent_excess_data_gas: int, new_blobs: int) -&gt; int:\n\"\"\"\n    Calculate the excess data gas for a block given the parent excess data gas\n    and the number of blobs in the block.\n    \"\"\"\n    consumed_data_gas = new_blobs * DATA_GAS_PER_BLOB\n    if parent_excess_data_gas + consumed_data_gas &lt; TARGET_DATA_GAS_PER_BLOCK:\n        return 0\n    else:\n        return (\n            parent_excess_data_gas\n            + consumed_data_gas\n            - TARGET_DATA_GAS_PER_BLOCK\n        )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.ExcessDataGasCalcTestCase","title":"<code>ExcessDataGasCalcTestCase</code>  <code>dataclass</code>","text":"<p>Test case generator class for the correct excess data gas calculation.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@dataclass(kw_only=True)\nclass ExcessDataGasCalcTestCase:\n\"\"\"\n    Test case generator class for the correct excess data gas calculation.\n    \"\"\"\n\n    parent_excess_blobs: int\n    blobs: int\n    block_base_fee: int = 7\n\n    def generate(self) -&gt; BlockchainTest:\n\"\"\"\n        Generate the test case.\n        \"\"\"\n        parent_excess_data_gas = self.parent_excess_blobs * DATA_GAS_PER_BLOB\n        env = Environment(excess_data_gas=parent_excess_data_gas)\n\n        destination_account = to_address(0x100)\n\n        excess_data_gas = calc_excess_data_gas(\n            parent_excess_data_gas=parent_excess_data_gas,\n            new_blobs=self.blobs,\n        )\n        data_gasprice = get_data_gasprice(\n            excess_data_gas=parent_excess_data_gas\n        )\n        tx_value = 1\n        tx_gas = 21000\n        fee_per_gas = self.block_base_fee\n        data_cost = data_gasprice * DATA_GAS_PER_BLOB * self.blobs\n        tx_exact_cost = (tx_gas * fee_per_gas) + tx_value + data_cost\n        pre = {\n            TestAddress: Account(balance=tx_exact_cost),\n        }\n\n        if self.blobs &gt; 0:\n            tx = Transaction(\n                ty=3,\n                nonce=0,\n                to=destination_account,\n                value=tx_value,\n                gas_limit=tx_gas,\n                max_fee_per_gas=fee_per_gas,\n                max_priority_fee_per_gas=0,\n                max_fee_per_data_gas=data_gasprice,\n                access_list=[],\n                blob_versioned_hashes=[\n                    to_hash_bytes(x) for x in range(self.blobs)\n                ],\n            )\n        else:\n            tx = Transaction(\n                ty=2,\n                nonce=0,\n                to=destination_account,\n                value=tx_value,\n                gas_limit=tx_gas,\n                max_fee_per_gas=fee_per_gas,\n                max_priority_fee_per_gas=0,\n                access_list=[],\n            )\n\n        return BlockchainTest(\n            pre=pre,\n            post={destination_account: Account(balance=1)},\n            blocks=[Block(txs=[tx])],\n            genesis_environment=env,\n            tag=f\"start_excess_data_gas_{hex(parent_excess_data_gas)}\"\n            + f\"_blobs_{self.blobs}_\"\n            + f\"expected_excess_data_gas_{hex(excess_data_gas)}\",\n        )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.ExcessDataGasCalcTestCase.generate","title":"<code>generate()</code>","text":"<p>Generate the test case.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def generate(self) -&gt; BlockchainTest:\n\"\"\"\n    Generate the test case.\n    \"\"\"\n    parent_excess_data_gas = self.parent_excess_blobs * DATA_GAS_PER_BLOB\n    env = Environment(excess_data_gas=parent_excess_data_gas)\n\n    destination_account = to_address(0x100)\n\n    excess_data_gas = calc_excess_data_gas(\n        parent_excess_data_gas=parent_excess_data_gas,\n        new_blobs=self.blobs,\n    )\n    data_gasprice = get_data_gasprice(\n        excess_data_gas=parent_excess_data_gas\n    )\n    tx_value = 1\n    tx_gas = 21000\n    fee_per_gas = self.block_base_fee\n    data_cost = data_gasprice * DATA_GAS_PER_BLOB * self.blobs\n    tx_exact_cost = (tx_gas * fee_per_gas) + tx_value + data_cost\n    pre = {\n        TestAddress: Account(balance=tx_exact_cost),\n    }\n\n    if self.blobs &gt; 0:\n        tx = Transaction(\n            ty=3,\n            nonce=0,\n            to=destination_account,\n            value=tx_value,\n            gas_limit=tx_gas,\n            max_fee_per_gas=fee_per_gas,\n            max_priority_fee_per_gas=0,\n            max_fee_per_data_gas=data_gasprice,\n            access_list=[],\n            blob_versioned_hashes=[\n                to_hash_bytes(x) for x in range(self.blobs)\n            ],\n        )\n    else:\n        tx = Transaction(\n            ty=2,\n            nonce=0,\n            to=destination_account,\n            value=tx_value,\n            gas_limit=tx_gas,\n            max_fee_per_gas=fee_per_gas,\n            max_priority_fee_per_gas=0,\n            access_list=[],\n        )\n\n    return BlockchainTest(\n        pre=pre,\n        post={destination_account: Account(balance=1)},\n        blocks=[Block(txs=[tx])],\n        genesis_environment=env,\n        tag=f\"start_excess_data_gas_{hex(parent_excess_data_gas)}\"\n        + f\"_blobs_{self.blobs}_\"\n        + f\"expected_excess_data_gas_{hex(excess_data_gas)}\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.test_excess_data_gas_calc","title":"<code>test_excess_data_gas_calc(_)</code>","text":"<p>Test calculation of the excess_data_gas increase/decrease across multiple blocks with and without blobs.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_excess_data_gas_calc(_: Fork):\n\"\"\"\n    Test calculation of the excess_data_gas increase/decrease across multiple\n    blocks with and without blobs.\n    \"\"\"\n    test_cases: List[ExcessDataGasCalcTestCase] = [\n        # Result excess data gas zero, included data blob txs cost &gt; 0\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK - 1,\n            blobs=0,\n        ),\n        # Result excess data gas zero, included data blob txs cost 0\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=0,\n            blobs=TARGET_BLOBS_PER_BLOCK - 1,\n        ),\n        # Result excess data gas target, included data blob txs cost 0\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=0,\n            blobs=TARGET_BLOBS_PER_BLOCK,\n        ),\n        # Excess data gas result is max - target, included data blob txs cost 0\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=0,\n            blobs=MAX_BLOBS_PER_BLOCK,\n        ),\n        # Data gas cost = 2\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=12,\n            blobs=1,\n        ),\n        # Data gas cost = 1\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=11,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data tx wei cost &lt; 2^32\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=176,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data tx wei cost &gt; 2^32\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=177,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data gas cost &lt; 2^32\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=376,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data gas cost &gt; 2^32\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=377,\n            blobs=1,\n        ),\n        # Data tx wei cost &lt; 2^64\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=553,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data tx wei cost &gt; 2^64\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=554,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data gas cost &lt; 2^64\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=753,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n        # Data gas cost &gt; 2^64\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=754,\n            blobs=1,\n        ),\n        # Data tx wei cost &gt; Main-net current total Ether supply\n        ExcessDataGasCalcTestCase(\n            parent_excess_blobs=820,\n            blobs=TARGET_BLOBS_PER_BLOCK + 1,\n        ),\n    ]\n\n    # Test for calculation of a resulting excess data gas value that is\n    # lower than the target, but not zero.\n    for result_excess_blob_count in range(1, TARGET_BLOBS_PER_BLOCK):\n        # Excess data gas result is 1 data gas per blob\n        test_cases.append(\n            ExcessDataGasCalcTestCase(\n                parent_excess_blobs=TARGET_BLOBS_PER_BLOCK\n                + result_excess_blob_count,\n                blobs=0,\n            )\n        )\n        # Excess data gas result is 1 data gas per blob\n        test_cases.append(\n            ExcessDataGasCalcTestCase(\n                parent_excess_blobs=TARGET_BLOBS_PER_BLOCK,\n                blobs=TARGET_BLOBS_PER_BLOCK - result_excess_blob_count,\n            )\n        )\n        # Excess data gas result is 1 data gas per blob\n        test_cases.append(\n            ExcessDataGasCalcTestCase(\n                parent_excess_blobs=TARGET_BLOBS_PER_BLOCK\n                - result_excess_blob_count,\n                blobs=TARGET_BLOBS_PER_BLOCK,\n            )\n        )\n\n    for tc in test_cases:\n        yield tc.generate()\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.InvalidExcessDataGasInHeaderTestCase","title":"<code>InvalidExcessDataGasInHeaderTestCase</code>  <code>dataclass</code>","text":"<p>Test case generator for invalid excess_data_gas in header.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidExcessDataGasInHeaderTestCase:\n\"\"\"\n    Test case generator for invalid excess_data_gas in header.\n    \"\"\"\n\n    new_blobs: int\n    header_excess_data_gas: Optional[int] = None\n    header_excess_blobs_delta: Optional[int] = None\n    header_excess_data_gas_delta: Optional[int] = None\n    parent_excess_blobs: int = 10\n\n    def generate(self) -&gt; BlockchainTest:\n\"\"\"\n        Generate the test case.\n        \"\"\"\n        env = Environment(\n            excess_data_gas=self.parent_excess_blobs * DATA_GAS_PER_BLOB,\n        )\n\n        pre = {\n            TestAddress: Account(balance=10**40),\n        }\n\n        # All blocks are invalid in this type of test, no state modifications\n        post: Mapping[str, Account] = {}\n\n        parent_excess_data_gas = self.parent_excess_blobs * DATA_GAS_PER_BLOB\n\n        correct_excess_data_gas = calc_excess_data_gas(\n            parent_excess_data_gas=parent_excess_data_gas,\n            new_blobs=self.new_blobs,\n        )\n\n        if self.header_excess_blobs_delta is not None:\n            if self.header_excess_data_gas is not None:\n                raise Exception(\"test case is badly formatted\")\n            self.header_excess_data_gas = parent_excess_data_gas + (\n                self.header_excess_blobs_delta * DATA_GAS_PER_BLOB\n            )\n        elif self.header_excess_data_gas_delta is not None:\n            if self.header_excess_data_gas is not None:\n                raise Exception(\"test case is badly formatted\")\n            self.header_excess_data_gas = parent_excess_data_gas + (\n                self.header_excess_data_gas_delta\n            )\n        if self.header_excess_data_gas is None:\n            raise Exception(\"test case is badly formatted\")\n\n        if self.header_excess_data_gas == correct_excess_data_gas:\n            raise Exception(\"invalid test case\")\n\n        if self.new_blobs == 0:\n            # Send a normal type two tx instead\n            tx = Transaction(\n                ty=2,\n                nonce=0,\n                to=to_address(0x100),\n                value=1,\n                gas_limit=3000000,\n                max_fee_per_gas=1000000,\n                max_priority_fee_per_gas=10,\n                access_list=[],\n            )\n        else:\n            tx = Transaction(\n                ty=3,\n                nonce=0,\n                to=to_address(0x100),\n                value=1,\n                gas_limit=3000000,\n                max_fee_per_gas=1000000,\n                max_priority_fee_per_gas=10,\n                max_fee_per_data_gas=get_data_gasprice(\n                    excess_data_gas=parent_excess_data_gas\n                ),\n                access_list=[],\n                blob_versioned_hashes=[\n                    to_hash_bytes(x) for x in range(self.new_blobs)\n                ],\n            )\n\n        return BlockchainTest(\n            pre=pre,\n            post=post,\n            blocks=[\n                Block(\n                    txs=[tx],\n                    rlp_modifier=Header(\n                        excess_data_gas=self.header_excess_data_gas\n                    ),\n                    exception=\"invalid excess data gas\",\n                )\n            ],\n            genesis_environment=env,\n            tag=f\"correct_{hex(correct_excess_data_gas)}_\"\n            + f\"header_{hex(self.header_excess_data_gas)}\",\n        )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.InvalidExcessDataGasInHeaderTestCase.generate","title":"<code>generate()</code>","text":"<p>Generate the test case.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def generate(self) -&gt; BlockchainTest:\n\"\"\"\n    Generate the test case.\n    \"\"\"\n    env = Environment(\n        excess_data_gas=self.parent_excess_blobs * DATA_GAS_PER_BLOB,\n    )\n\n    pre = {\n        TestAddress: Account(balance=10**40),\n    }\n\n    # All blocks are invalid in this type of test, no state modifications\n    post: Mapping[str, Account] = {}\n\n    parent_excess_data_gas = self.parent_excess_blobs * DATA_GAS_PER_BLOB\n\n    correct_excess_data_gas = calc_excess_data_gas(\n        parent_excess_data_gas=parent_excess_data_gas,\n        new_blobs=self.new_blobs,\n    )\n\n    if self.header_excess_blobs_delta is not None:\n        if self.header_excess_data_gas is not None:\n            raise Exception(\"test case is badly formatted\")\n        self.header_excess_data_gas = parent_excess_data_gas + (\n            self.header_excess_blobs_delta * DATA_GAS_PER_BLOB\n        )\n    elif self.header_excess_data_gas_delta is not None:\n        if self.header_excess_data_gas is not None:\n            raise Exception(\"test case is badly formatted\")\n        self.header_excess_data_gas = parent_excess_data_gas + (\n            self.header_excess_data_gas_delta\n        )\n    if self.header_excess_data_gas is None:\n        raise Exception(\"test case is badly formatted\")\n\n    if self.header_excess_data_gas == correct_excess_data_gas:\n        raise Exception(\"invalid test case\")\n\n    if self.new_blobs == 0:\n        # Send a normal type two tx instead\n        tx = Transaction(\n            ty=2,\n            nonce=0,\n            to=to_address(0x100),\n            value=1,\n            gas_limit=3000000,\n            max_fee_per_gas=1000000,\n            max_priority_fee_per_gas=10,\n            access_list=[],\n        )\n    else:\n        tx = Transaction(\n            ty=3,\n            nonce=0,\n            to=to_address(0x100),\n            value=1,\n            gas_limit=3000000,\n            max_fee_per_gas=1000000,\n            max_priority_fee_per_gas=10,\n            max_fee_per_data_gas=get_data_gasprice(\n                excess_data_gas=parent_excess_data_gas\n            ),\n            access_list=[],\n            blob_versioned_hashes=[\n                to_hash_bytes(x) for x in range(self.new_blobs)\n            ],\n        )\n\n    return BlockchainTest(\n        pre=pre,\n        post=post,\n        blocks=[\n            Block(\n                txs=[tx],\n                rlp_modifier=Header(\n                    excess_data_gas=self.header_excess_data_gas\n                ),\n                exception=\"invalid excess data gas\",\n            )\n        ],\n        genesis_environment=env,\n        tag=f\"correct_{hex(correct_excess_data_gas)}_\"\n        + f\"header_{hex(self.header_excess_data_gas)}\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.test_invalid_excess_data_gas_in_header","title":"<code>test_invalid_excess_data_gas_in_header(_)</code>","text":"<p>Test rejection of a block with invalid excess_data_gas in the header.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@test_from(fork=Cancun)\ndef test_invalid_excess_data_gas_in_header(_: Fork):\n\"\"\"\n    Test rejection of a block with invalid excess_data_gas in the header.\n    \"\"\"\n    test_cases: List[InvalidExcessDataGasInHeaderTestCase] = []\n\n\"\"\"\n    Header excess data gas is either:\n        - Reduced to zero by a value &gt; TARGET_DATA_GAS_PER_BLOCK`\n        - Reduced too much (-1 * TARGET_DATA_GAS_PER_BLOCK)\n        - Increased too much (1 * TARGET_DATA_GAS_PER_BLOCK)\n        - Unchanged when it should be changed\n        - Changed when it should be unchanged\n        - Less than TARGET_DATA_GAS_PER_BLOCK\n        - A value greater than (2**256 - 1)\n    \"\"\"\n    for blob_count in range(MAX_BLOBS_PER_BLOCK + 1):\n        # Start test cases with a excess blob value of a mid point between\n        # MAX_BLOBS_PER_BLOCK and TARGET_BLOBS_PER_BLOCK\n        START_BLOBS = (MAX_BLOBS_PER_BLOCK + TARGET_BLOBS_PER_BLOCK) // 2 + 1\n\n        # Excess data gas cannot drop to zero because it can only decrease\n        # TARGET_DATA_GAS_PER_BLOCK in one block\n        test_cases.append(\n            InvalidExcessDataGasInHeaderTestCase(\n                new_blobs=blob_count,\n                parent_excess_blobs=START_BLOBS,\n                header_excess_data_gas=0,\n            )\n        )\n        # Can never decrease more than TARGET_DATA_GAS_PER_BLOCK in a single\n        # block\n        test_cases.append(\n            InvalidExcessDataGasInHeaderTestCase(\n                new_blobs=blob_count,\n                parent_excess_blobs=START_BLOBS,\n                header_excess_blobs_delta=-(TARGET_BLOBS_PER_BLOCK + 1),\n            )\n        )\n        # Can never increase more than TARGET_DATA_GAS_PER_BLOCK in a single\n        # block\n        test_cases.append(\n            InvalidExcessDataGasInHeaderTestCase(\n                new_blobs=blob_count,\n                parent_excess_blobs=START_BLOBS,\n                header_excess_blobs_delta=(TARGET_BLOBS_PER_BLOCK + 1),\n            )\n        )\n        if blob_count != TARGET_BLOBS_PER_BLOCK:\n            # Cannot remain unchanged if blobs != target blobs\n            test_cases.append(\n                InvalidExcessDataGasInHeaderTestCase(\n                    new_blobs=blob_count,\n                    parent_excess_blobs=START_BLOBS,\n                    header_excess_blobs_delta=0,\n                )\n            )\n        else:\n            # Cannot change if blobs == target blobs\n            test_cases.append(\n                InvalidExcessDataGasInHeaderTestCase(\n                    new_blobs=blob_count,\n                    parent_excess_blobs=START_BLOBS,\n                    header_excess_blobs_delta=-1,\n                )\n            )\n            test_cases.append(\n                InvalidExcessDataGasInHeaderTestCase(\n                    new_blobs=blob_count,\n                    parent_excess_blobs=START_BLOBS,\n                    header_excess_blobs_delta=1,\n                )\n            )\n\n    # Try to increase excess data gas to a value below target from zero\n    for blob_count in range(1, TARGET_BLOBS_PER_BLOCK):\n        test_cases.append(\n            InvalidExcessDataGasInHeaderTestCase(\n                new_blobs=blob_count,\n                parent_excess_blobs=0,\n                header_excess_blobs_delta=blob_count,\n            )\n        )\n\n    # Try to reduce excess data gas to a negative value (two's complement)\n    test_cases.append(\n        InvalidExcessDataGasInHeaderTestCase(\n            new_blobs=0,\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK - 1,\n            header_excess_data_gas=2**256 - DATA_GAS_PER_BLOB,\n        )\n    )\n\n    # Cannot change by anything that is not modulo zero of data gas per\n    # blob\n    test_cases.append(\n        InvalidExcessDataGasInHeaderTestCase(\n            new_blobs=TARGET_BLOBS_PER_BLOCK + 1,\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK,\n            header_excess_data_gas_delta=1,\n        )\n    )\n    test_cases.append(\n        InvalidExcessDataGasInHeaderTestCase(\n            new_blobs=TARGET_BLOBS_PER_BLOCK + 1,\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK,\n            header_excess_data_gas_delta=DATA_GAS_PER_BLOB - 1,\n        )\n    )\n    test_cases.append(\n        InvalidExcessDataGasInHeaderTestCase(\n            new_blobs=TARGET_BLOBS_PER_BLOCK - 1,\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK,\n            header_excess_data_gas_delta=-1,\n        )\n    )\n    test_cases.append(\n        InvalidExcessDataGasInHeaderTestCase(\n            new_blobs=TARGET_BLOBS_PER_BLOCK - 1,\n            parent_excess_blobs=TARGET_BLOBS_PER_BLOCK,\n            header_excess_data_gas_delta=-(DATA_GAS_PER_BLOB - 1),\n        )\n    )\n\n    for tc in test_cases:\n        yield tc.generate()\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.test_fork_transition_excess_data_gas_in_header","title":"<code>test_fork_transition_excess_data_gas_in_header(_)</code>","text":"<p>Test excess_data_gas calculation in the header when the fork is activated.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@test_only(fork=ShanghaiToCancunAtTime15k)\ndef test_fork_transition_excess_data_gas_in_header(_: Fork):\n\"\"\"\n    Test excess_data_gas calculation in the header when the fork is activated.\n    \"\"\"\n    env = Environment()\n    pre = {\n        TestAddress: Account(balance=10**40),\n    }\n    destination_account = to_address(0x100)\n\n    # Generate some blocks to reach Cancun fork\n    FORK_TIMESTAMP = 15_000\n    blocks: List[Block] = []\n    for t in range(999, FORK_TIMESTAMP, 1_000):\n        blocks.append(Block(timestamp=t))\n\n    # Try to append a block on the previous fork with excess data gas field set\n    yield BlockchainTest(\n        pre=pre,\n        post={},\n        blocks=blocks[:-1]\n        + [\n            Block(\n                timestamp=(FORK_TIMESTAMP - 1),\n                rlp_modifier=Header(excess_data_gas=0),\n                exception=\"invalid ExcessDataGas\",\n            )\n        ],\n        genesis_environment=env,\n        tag=\"invalid_pre_fork_excess_data_gas\",\n    )\n\n    # Try to append a post-fork block with excess data gas field removed\n    yield BlockchainTest(\n        pre=pre,\n        post={},\n        blocks=blocks\n        + [\n            Block(\n                timestamp=FORK_TIMESTAMP,\n                rlp_modifier=Header(excess_data_gas=Header.REMOVE_FIELD),\n                exception=\"missing ExcessDataGas\",\n            )\n        ],\n        genesis_environment=env,\n        tag=\"excess_data_gas_missing_post_fork\",\n    )\n\n    # Test N blocks until excess data gas after fork reaches data gas cost &gt; 1\n    BLOBS_TO_DATA_GAS_COST_INCREASE = 12\n    assert get_data_gasprice_from_blobs(\n        BLOBS_TO_DATA_GAS_COST_INCREASE - 1\n    ) != get_data_gasprice_from_blobs(BLOBS_TO_DATA_GAS_COST_INCREASE)\n\n    parent_excess_data_gas = 0\n    destination_account_value = 0\n    for i in range(\n        BLOBS_TO_DATA_GAS_COST_INCREASE\n        // (MAX_BLOBS_PER_BLOCK - TARGET_BLOBS_PER_BLOCK)\n        + 1\n    ):\n        blocks.append(\n            Block(\n                txs=[\n                    Transaction(\n                        ty=3,\n                        nonce=i,\n                        to=destination_account,\n                        value=1,\n                        gas_limit=3000000,\n                        max_fee_per_gas=1000000,\n                        max_priority_fee_per_gas=10,\n                        max_fee_per_data_gas=get_data_gasprice(\n                            excess_data_gas=parent_excess_data_gas\n                        ),\n                        access_list=[],\n                        blob_versioned_hashes=[\n                            to_hash_bytes(x)\n                            for x in range(MAX_BLOBS_PER_BLOCK)\n                        ],\n                    )\n                ],\n            )\n        )\n        destination_account_value += 1\n        parent_excess_data_gas = calc_excess_data_gas(\n            parent_excess_data_gas,\n            MAX_BLOBS_PER_BLOCK,\n        )\n\n    post: Mapping[str, Account] = {\n        destination_account: Account(balance=destination_account_value),\n    }\n\n    yield BlockchainTest(\n        pre=pre,\n        post=post,\n        blocks=blocks,\n        genesis_environment=env,\n        tag=\"correct_initial_data_gas_calc\",\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.InvalidBlobTransactionTestCase","title":"<code>InvalidBlobTransactionTestCase</code>  <code>dataclass</code>","text":"<p>Test case generator for invalid blob transactions.</p> <p>Transaction can be invalidated by modifying the following fields: - blobs_per_tx: Number of blobs in the transaction exceeds max blobs - tx_max_data_gas_cost: Transaction max_fee_per_data_gas is too low - tx_count: Number of transactions times blobs_per_tx exceeds max blobs</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@dataclass(kw_only=True)\nclass InvalidBlobTransactionTestCase:\n\"\"\"\n    Test case generator for invalid blob transactions.\n\n    Transaction can be invalidated by modifying the following fields:\n    - blobs_per_tx: Number of blobs in the transaction exceeds max blobs\n    - tx_max_data_gas_cost: Transaction max_fee_per_data_gas is too low\n    - tx_count: Number of transactions times blobs_per_tx exceeds max blobs\n    \"\"\"\n\n    tag: str\n    blobs_per_tx: int\n    tx_error: str\n    tx_count: int = 1\n    parent_excess_blobs: Optional[int] = None\n    tx_max_data_gas_cost: Optional[int] = None\n    account_balance_modifier: int = 0\n    block_base_fee: int = 7\n\n    def generate(self) -&gt; BlockchainTest:\n\"\"\"\n        Generate the test case.\n        \"\"\"\n        env = Environment()\n        data_gasprice = MIN_DATA_GASPRICE\n        destination_account = to_address(0x100)\n\n        if self.parent_excess_blobs is not None:\n            parent_excess_data_gas = (\n                self.parent_excess_blobs * DATA_GAS_PER_BLOB\n            )\n            env = Environment(excess_data_gas=parent_excess_data_gas)\n            data_gasprice = get_data_gasprice(\n                excess_data_gas=parent_excess_data_gas\n            )\n\n        total_account_minimum_balance = 0\n\n        tx_value = 1\n        tx_gas = 21000\n        fee_per_gas = self.block_base_fee\n        data_cost = data_gasprice * DATA_GAS_PER_BLOB * self.blobs_per_tx\n        tx_exact_cost = (tx_gas * fee_per_gas) + tx_value + data_cost\n\n        max_fee_per_data_gas = (\n            self.tx_max_data_gas_cost\n            if self.tx_max_data_gas_cost is not None\n            else data_gasprice\n        )\n\n        txs: List[Transaction] = []\n        for tx_i in range(self.tx_count):\n            tx = Transaction(\n                ty=3,\n                nonce=tx_i,\n                to=destination_account,\n                value=tx_value,\n                gas_limit=tx_gas,\n                max_fee_per_gas=fee_per_gas,\n                max_priority_fee_per_gas=0,\n                max_fee_per_data_gas=max_fee_per_data_gas,\n                access_list=[],\n                blob_versioned_hashes=[\n                    to_hash_bytes(x) for x in range(self.blobs_per_tx)\n                ],\n                error=self.tx_error if tx_i == (self.tx_count - 1) else None,\n            )\n            txs.append(tx)\n            total_account_minimum_balance += tx_exact_cost\n\n        pre = {\n            TestAddress: Account(\n                balance=total_account_minimum_balance\n                + self.account_balance_modifier\n            ),\n        }\n\n        return BlockchainTest(\n            pre=pre,\n            post={},\n            blocks=[\n                Block(\n                    txs=txs,\n                    exception=self.tx_error,\n                )\n            ],\n            genesis_environment=env,\n            tag=self.tag,\n        )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.InvalidBlobTransactionTestCase.generate","title":"<code>generate()</code>","text":"<p>Generate the test case.</p> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>def generate(self) -&gt; BlockchainTest:\n\"\"\"\n    Generate the test case.\n    \"\"\"\n    env = Environment()\n    data_gasprice = MIN_DATA_GASPRICE\n    destination_account = to_address(0x100)\n\n    if self.parent_excess_blobs is not None:\n        parent_excess_data_gas = (\n            self.parent_excess_blobs * DATA_GAS_PER_BLOB\n        )\n        env = Environment(excess_data_gas=parent_excess_data_gas)\n        data_gasprice = get_data_gasprice(\n            excess_data_gas=parent_excess_data_gas\n        )\n\n    total_account_minimum_balance = 0\n\n    tx_value = 1\n    tx_gas = 21000\n    fee_per_gas = self.block_base_fee\n    data_cost = data_gasprice * DATA_GAS_PER_BLOB * self.blobs_per_tx\n    tx_exact_cost = (tx_gas * fee_per_gas) + tx_value + data_cost\n\n    max_fee_per_data_gas = (\n        self.tx_max_data_gas_cost\n        if self.tx_max_data_gas_cost is not None\n        else data_gasprice\n    )\n\n    txs: List[Transaction] = []\n    for tx_i in range(self.tx_count):\n        tx = Transaction(\n            ty=3,\n            nonce=tx_i,\n            to=destination_account,\n            value=tx_value,\n            gas_limit=tx_gas,\n            max_fee_per_gas=fee_per_gas,\n            max_priority_fee_per_gas=0,\n            max_fee_per_data_gas=max_fee_per_data_gas,\n            access_list=[],\n            blob_versioned_hashes=[\n                to_hash_bytes(x) for x in range(self.blobs_per_tx)\n            ],\n            error=self.tx_error if tx_i == (self.tx_count - 1) else None,\n        )\n        txs.append(tx)\n        total_account_minimum_balance += tx_exact_cost\n\n    pre = {\n        TestAddress: Account(\n            balance=total_account_minimum_balance\n            + self.account_balance_modifier\n        ),\n    }\n\n    return BlockchainTest(\n        pre=pre,\n        post={},\n        blocks=[\n            Block(\n                txs=txs,\n                exception=self.tx_error,\n            )\n        ],\n        genesis_environment=env,\n        tag=self.tag,\n    )\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/excess_data_gas/#fillers.eips.eip4844.excess_data_gas.test_invalid_blob_txs","title":"<code>test_invalid_blob_txs(fork)</code>","text":"Reject blocks with invalid blob txs due to <ul> <li>The user cannot afford the data gas specified (but max_fee_per_gas     would be enough for current block)</li> <li>tx max_fee_per_data_gas is not enough</li> <li>tx max_fee_per_data_gas is zero</li> <li>blob count = 0 in type 3 transaction</li> <li>blob count &gt; MAX_BLOBS_PER_BLOCK in type 3 transaction</li> <li>block blob count &gt; MAX_BLOBS_PER_BLOCK</li> </ul> Source code in <code>fillers/eips/eip4844/excess_data_gas.py</code> <pre><code>@test_from(fork=Shanghai)\ndef test_invalid_blob_txs(fork: Fork):\n\"\"\"\n    Reject blocks with invalid blob txs due to:\n        - The user cannot afford the data gas specified (but max_fee_per_gas\n            would be enough for current block)\n        - tx max_fee_per_data_gas is not enough\n        - tx max_fee_per_data_gas is zero\n        - blob count = 0 in type 3 transaction\n        - blob count &gt; MAX_BLOBS_PER_BLOCK in type 3 transaction\n        - block blob count &gt; MAX_BLOBS_PER_BLOCK\n    \"\"\"\n    test_cases: List[InvalidBlobTransactionTestCase] = []\n    if is_fork(fork, Cancun):\n        test_cases = [\n            InvalidBlobTransactionTestCase(\n                tag=\"insufficient_max_fee_per_data_gas\",\n                parent_excess_blobs=15,  # data_gasprice = 2\n                tx_max_data_gas_cost=1,  # &lt; data_gasprice\n                tx_error=\"insufficient max fee per data gas\",\n                blobs_per_tx=1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"insufficient_balance_sufficient_fee\",\n                parent_excess_blobs=15,  # data_gasprice = 2\n                tx_max_data_gas_cost=100,  # &gt; data_gasprice\n                account_balance_modifier=-1,\n                tx_error=\"insufficient account balance\",\n                blobs_per_tx=1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"zero_max_fee_per_data_gas\",\n                parent_excess_blobs=0,  # data_gasprice = 1\n                tx_max_data_gas_cost=0,  # invalid value\n                tx_error=\"invalid max fee per data gas\",\n                blobs_per_tx=1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"blob_overflow\",\n                parent_excess_blobs=10,  # data_gasprice = 1\n                tx_error=\"too_many_blobs\",\n                blobs_per_tx=MAX_BLOBS_PER_BLOCK + 1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"multi_tx_blob_overflow\",\n                parent_excess_blobs=10,  # data_gasprice = 1\n                tx_error=\"too_many_blobs\",\n                tx_count=MAX_BLOBS_PER_BLOCK + 1,\n                blobs_per_tx=1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"blob_underflow\",\n                parent_excess_blobs=10,  # data_gasprice= 1\n                tx_error=\"too_few_blobs\",\n                blobs_per_tx=0,\n            ),\n        ]\n    else:\n        # Pre-Cancun, blocks with type 3 txs must be rejected\n        test_cases = [\n            InvalidBlobTransactionTestCase(\n                tag=\"type_3_tx_pre_fork\",\n                parent_excess_blobs=None,\n                tx_max_data_gas_cost=1,\n                tx_error=\"tx_type_3_not_allowed_yet\",\n                blobs_per_tx=1,\n            ),\n            InvalidBlobTransactionTestCase(\n                tag=\"empty_type_3_tx_pre_fork\",\n                parent_excess_blobs=None,\n                tx_max_data_gas_cost=1,\n                tx_error=\"tx_type_3_not_allowed_yet\",\n                blobs_per_tx=0,\n            ),\n        ]\n\n    for tc in test_cases:\n        yield tc.generate()\n</code></pre>"},{"location":"fillers/EIPs/EIP-4844/test_cases/","title":"\ud83e\uddea Execution Specification Test Cases","text":"<p>Note: This is still a WIP but the tests can still be used by any client team. The priority levels (\ud83d\udd34, \ud83d\udfe0, \ud83d\udfe1, \ud83d\udfe2) represent very high, high, medium, low  priorities respectively.</p>"},{"location":"fillers/EIPs/EIP-4844/test_cases/#datahash-opcode","title":"\ud83d\udcd6 Datahash Opcode","text":"<p>Test Module - <code>eip4844/datahash_opcode.py</code></p> <p>Verifies that the <code>DATAHASH</code> opcode, works as intended for a variety of contexts, retrieves the blob versioned hash correctly for a given index, returns the correct zeroed <code>bytes32</code> value for out-of-range indices, and consumes the correct amount of gas.</p> <p>1) \ud83d\udd34 test_datahash_opcode_contexts():</p> <p>Tests that the <code>DATAHASH</code> opcode functions correctly when called in different contexts including: - <code>DATAHASH</code> opcode on the top level of the call stack. - <code>DATAHASH</code> opcode on the max value. - <code>DATAHASH</code> opcode on <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, and <code>CALLCODE</code>. - <code>DATAHASH</code> opcode on Initcode. - <code>DATAHASH</code> opcode on <code>CREATE</code> and <code>CREATE2</code>. - <code>DATAHASH</code> opcode on transaction types 0, 1 and 2.</p> <p>2) \ud83d\udd34 test_datahash_blob_versioned_hash():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the correct versioned hash for various valid indexes. This test covers various scenarios with random <code>blob_versioned_hash</code> values within the valid range <code>[0, 2**256-1]</code>.</p> <p>3) \ud83d\udd34 test_datahash_invalid_blob_index():</p> <p>Tests that the <code>DATAHASH</code> opcode returns a zeroed <code>bytes32</code> value for invalid indexes. This test includes cases where the index is negative (<code>index &lt; 0</code>) or exceeds the maximum number of <code>blob_versioned_hash</code> values stored (<code>index &gt;= len(tx.message.blob_versioned_hashes)</code>). It confirms that the returned value is a zeroed <code>bytes32</code> value for these cases.</p> <p>4) \ud83d\udfe0 test_datahash_gas_cost():</p> <p>Asserts the gas consumption of the <code>DATAHASH</code> opcode is correct by ensuring it matches <code>HASH_OPCODE_GAS = 3</code>. It includes both valid and invalid random index sizes from the range <code>[0, 2**256-1]</code>, for tx types 2 and 3.</p> <p>5) \ud83d\udfe1 test_datahash_multiple_txs_in_block():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the appropriate values when there is more than one blob tx type within a block (for tx types 2 and 3). Scenarios involve tx type 3 followed by tx type 2 running the same code within a block. In this case <code>DATAHASH</code> returns 0, but for the opposite scenario <code>DATAHASH</code> returns the correct <code>blob_versioned_hash</code>.</p>"},{"location":"fillers/EIPs/EIP-4844/test_cases/#excess-data-gas","title":"\ud83d\udcbd\u26fd\ud83d\udcb8 Excess Data Gas","text":"<p>Test Module - <code>eip4844/excess_data_gas.py</code></p> <p>Predominantly verifies that <code>excess_data_gas</code> &amp; <code>data_gasprice</code> are calculated correctly ensuring both valid and invalid transactions are processed accordingly. Extra verification is added specifically for invalid blob transactions when the <code>max_fee_per_data_gas</code>, number of blobs or transaction type are errorneous. </p> <p>1) \ud83d\udd34 test_excess_data_gas_calculation():</p> <p>Tests that the <code>excess_data_gas</code> is calculated correctly within a single block for various contexts, where the <code>parent.excess_data_gas</code> and the proposed block <code>excess_data_gas</code> have a variety of values. The excess data gas is calculated using the following formula:</p> <pre><code>def calc_excess_data_gas(parent: Header, new_blobs: int) -&gt; int:\n    consumed_data_gas = new_blobs * DATA_GAS_PER_BLOB\n    if parent.excess_data_gas + consumed_data_gas &lt; TARGET_DATA_GAS_PER_BLOCK:\n        return 0\n    else:\n        return parent.excess_data_gas + consumed_data_gas - TARGET_DATA_GAS_PER_BLOCK\n</code></pre> <p>For blocks to be valid in these contexts they must meet the following conditions of the EIP:   - Each block can only have a maximum of <code>MAX_BLOBS_PER_BLOCK</code>.   - A type 5 blob transaction must have at least one blob - <code>len(versioned_hashes) &gt; 0</code>.   - The user is open to paying the current data gasprice for the transaction -<code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code>   - The account used for the blob transaction must have enough balance - <code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> <p>2) \ud83d\udd34 test_invalid_excess_data_gas_in_header():</p> <p>Asserts that blocks with invalid <code>excess_data_gas</code> values in the header are ignored, ensuring the blob transaction is rejected and no state changes occur. The invalidity of <code>excess_data_gas</code> within a new block header is tested across the following scenarios:</p> <ul> <li> <p><code>excess_data_gas</code> decreases or increases by <code>TARGET_DATA_GAS_PER_BLOCK + 1</code> in a single block. Note that the EIP only allows <code>excess_data_gas</code> to decrease &amp; increase by a maximum of <code>TARGET_DATA_GAS_PER_BLOCK</code>.</p> </li> <li> <p><code>excess_data_gas</code> is unchanged when the number of blobs in the proposed block doesn't equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are different from the target, <code>excess_data_gas</code> must change. </p> </li> <li> <p><code>excess_data_gas</code> is changed when the number of blobs in the proposed block does equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are equal to the target,<code>excess_data_gas</code> must remain the same value - <code>parent_excess_data_gas</code>.</p> </li> <li> <p><code>excess_data_gas</code> is less than the <code>TARGET_DATA_GAS_PER_BLOCK</code> when the parent has 0 blobs (<code>parent.excess_data_gas</code> = 0), and the calculated excess is non-zero. This is invalid as the first condition in the excess data gas calculation must be met, and hence return zero for this case. </p> </li> <li> <p><code>excess_data_gas</code> is a value greater than <code>2**256-1</code>. It must be a value that fits within 256-bits.</p> </li> </ul> <p>3) \ud83d\udd34 test_fork_transition_excess_data_gas_in_header():</p> <p>Tests that the <code>excess_data_gas</code> calculation is correct when transitioning from the Shanghai fork to the Cancun fork, where appended blocks are valid and state changes occur. Each block has a single transaction with <code>MAX_BLOBS_PER_BLOCK</code> blobs. The first block during the transition period has a parent of zero <code>excess_data_gas</code> in the header. Each block afterwards calculates <code>excess_data_gas</code> using the following <code>calc_excess_data_gas</code> function such that it continuously increases.</p> <p>4) \ud83d\udd34 test_invalid_blob_txs():</p> <p>Asserts that blocks with invalid blob transactions are rejected and no state changes occur. This is tested across the following scenarios:</p> <ul> <li><code>max_fee_per_data_gas</code> is less than the required <code>data_gasprice</code> for a set number of excess blobs. This is invaild as a valid block must obey the following condition:</li> <li> <p><code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> is greater than the required <code>data_gasprice</code> for a set number of excess blobs but the account doesn't have the required balance to cover the total cost of the transaction. A valid block must prove true for the following condition: </p> </li> <li> <p><code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> has an invalid value of zero. This value is invalid as it is less than <code>MIN_DATA_GASPRICE = 1</code>.</p> </li> <li> <p><code>len(blobs)</code> is greater than <code>MAX_BLOBS_PER_BLOCK =  MAX_DATA_GAS_PER_BLOCK // DATA_GAS_PER_BLOB</code> in a single transaction within one block. There cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(wrapper.tx.message)</code> is greater that <code>MAX_BLOBS_PER_BLOCK</code> but with <code>len(blobs) = 1</code> for each transaction. As before there cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(blobs)</code> is zero within a transaction. Valid blob txs (type 3) must have at least one blob within it, obeying the following condition:</p> </li> <li> <p><code>len(tx.message.blob_versioned_hashes) &gt; 0</code></p> </li> <li> <p>Blob transaction type 3 is used in a pre-Cancun fork. This transcation type can only be used in a post-Cancun fork.</p> </li> </ul>"},{"location":"fillers/VM/","title":"VM","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/vm\n</code></pre> <p>Cross-client Ethereum Virtual Machine Tests</p>"},{"location":"fillers/VM/chain_id/","title":"chain_id","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/vm/chain_id.py\n</code></pre> <p>Test EIP-1344 CHAINID opcode</p>"},{"location":"fillers/VM/chain_id/#fillers.vm.chain_id.test_chain_id","title":"<code>test_chain_id(state_test, fork)</code>","text":"<p>Test CHAINID opcode.</p> Source code in <code>fillers/vm/chain_id.py</code> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from(Istanbul))\ndef test_chain_id(state_test: StateTestFiller, fork: Fork):\n\"\"\"\n    Test CHAINID opcode.\n    \"\"\"\n    env = Environment(\n        coinbase=\"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\",\n        difficulty=0x20000,\n        gas_limit=10000000000,\n        number=1,\n        timestamp=1000,\n    )\n\n    pre = {\n        to_address(0x100): Account(code=Op.SSTORE(1, Op.CHAINID) + Op.STOP),\n        TestAddress: Account(balance=1000000000000000000000),\n    }\n\n    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=to_address(0x100),\n        gas_limit=100000000,\n        gas_price=10,\n        protected=False,\n    )\n\n    post = {\n        to_address(0x100): Account(\n            code=\"0x4660015500\", storage={\"0x01\": \"0x01\"}\n        ),\n    }\n\n    state_test(env=env, pre=pre, post=post, txs=[tx])\n</code></pre>"},{"location":"fillers/VM/dup/","title":"dup","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/vm/dup.py\n</code></pre> <p>Test DUP opcodes</p>"},{"location":"fillers/VM/dup/#fillers.vm.dup.test_dup","title":"<code>test_dup(state_test, fork)</code>","text":"<p>Test DUP1-DUP16 opcodes. Based on ethereum/tests: GeneralStateTests/VMTests/vmTests/dup Original test by: Ori Pomerantz qbzzt1@gmail.com</p> Source code in <code>fillers/vm/dup.py</code> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from(Istanbul))\ndef test_dup(state_test: StateTestFiller, fork: Fork):\n\"\"\"\n    Test DUP1-DUP16 opcodes.\n    Based on ethereum/tests: GeneralStateTests/VMTests/vmTests/dup\n    Original test by: Ori Pomerantz qbzzt1@gmail.com\n    \"\"\"\n    env = Environment()\n    pre = {\n        \"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\": Account(\n            balance=1000000000000000000000\n        )\n    }\n    txs = []\n    post = {}\n\n\"\"\"\n    We are setting up 16 accounts, ranging from 0x100 to 0x10f.\n    They push values into the stack from 0-16, but each contract uses a\n    different DUP opcode, and depending on the opcode used, the item copied\n    into the storage changes.\n    \"\"\"\n    for i in range(0, 16):\n\"\"\"\n        Account 0x100 uses DUP1,\n        Account 0x10f uses DUP16.\n        \"\"\"\n        account = to_address(0x100 + i)\n        dup_opcode = 0x80 + i\n\n        pre[account] = Account(\n            code=(\n                # Push 0 - 16 onto the stack\n\"\"\"0x6000 6001 6002 6003 6004 6005 6006 6007 6008 6009\n                         600A 600B 600C 600D 600E 600F 6010\"\"\"\n                +\n                # Use the DUP opcode for this account\n                hex(dup_opcode)[2:]\n                +\n                # Save each stack value into different keys in storage\n\"\"\"6000 55 6001 55 6002 55 6003 55 6004 55 6005 55\n                       6006 55 6007 55 6008 55 6009 55 600A 55 600B 55\n                       600C 55 600D 55 600E 55 600F 55 6010 55\"\"\"\n            )\n        )\n\n\"\"\"\n        Also we are sending one transaction to each account.\n        The storage of each will only change by one item: storage[0]\n        The value depends on the DUP opcode used.\n        \"\"\"\n        tx = Transaction(\n            ty=0x0,\n            nonce=i,\n            to=account,\n            gas_limit=500000,\n            gas_price=10,\n            protected=False,\n            data=\"\",\n        )\n        txs.append(tx)\n\n\"\"\"\n        Storage will be structured as follows:\n\n        0x00: 0x10-0x01 (Depending on DUP opcode)\n        0x01: 0x10\n        0x02: 0x0F\n        0x03: 0x0E\n        0x04: 0x0D\n        0x05: 0x0C\n        0x06: 0x0B\n        0x07: 0x0A\n        0x08: 0x09\n        0x09: 0x08\n        0x0A: 0x07\n        0x0B: 0x06\n        0x0C: 0x05\n        0x0D: 0x04\n        0x0E: 0x03\n        0x0F: 0x02\n        0x10: 0x01\n\n        DUP1 copies the first element of the stack (0x10).\n        DUP16 copies the 16th element of the stack (0x01).\n        \"\"\"\n        s: Dict[Union[str, int, bytes], Union[str, int, bytes]] = dict(\n            zip(range(1, 17), range(16, 0, -1))\n        )\n        s[0] = 16 - i\n\n        post[account] = Account(storage=s)\n\n    state_test(env=env, pre=pre, post=post, txs=txs)\n</code></pre>"},{"location":"fillers/example/","title":"example","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/example\n</code></pre> <p>Cross-client Ethereum State Test Examples</p>"},{"location":"fillers/example/acl_example/","title":"acl_example","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/example/acl_example.py\n</code></pre> <p>Test ACL Transaction Source Code Examples</p>"},{"location":"fillers/example/acl_example/#fillers.example.acl_example.test_access_list","title":"<code>test_access_list(state_test, fork)</code>","text":"<p>Test type 1 transaction.</p> Source code in <code>fillers/example/acl_example.py</code> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from_until(Berlin, London))\ndef test_access_list(state_test: StateTestFiller, fork: Fork):\n\"\"\"\n    Test type 1 transaction.\n    \"\"\"\n    env = Environment()\n\n    pre = {\n        \"0x000000000000000000000000000000000000aaaa\": Account(\n            balance=0x03,\n            code=Op.PC + Op.SLOAD + Op.POP + Op.PC + Op.SLOAD,\n            nonce=1,\n        ),\n        \"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\": Account(\n            balance=0x300000,\n            nonce=0,\n        ),\n    }\n\n    tx = Transaction(\n        ty=1,\n        chain_id=0x01,\n        nonce=0,\n        to=\"0x000000000000000000000000000000000000aaaa\",\n        value=1,\n        gas_limit=323328,\n        gas_price=7,\n        access_list=[\n            AccessList(\n                address=\"0x0000000000000000000000000000000000000000\",\n                storage_keys=[\n                    \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                ],\n            )\n        ],\n        secret_key=\"0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8\",  # noqa: E501\n        protected=True,\n    )\n\n    post = {\n        \"0x000000000000000000000000000000000000aaaa\": Account(\n            code=\"0x5854505854\",\n            balance=4,\n            nonce=1,\n        ),\n        \"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\": Account(\n            balance=0x1BC16D674EC80000\n            if is_fork(fork, London)\n            else 0x1BC16D674ECB26CE,\n        ),\n        \"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\": Account(\n            balance=0x2CD931,\n            nonce=1,\n        ),\n    }\n    state_test(env=env, pre=pre, post=post, txs=[tx])\n</code></pre>"},{"location":"fillers/example/yul_example/","title":"yul_example","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/example/yul_example.py\n</code></pre> <p>Test Yul Source Code Examples</p>"},{"location":"fillers/example/yul_example/#fillers.example.yul_example.test_yul","title":"<code>test_yul(state_test, fork)</code>","text":"<p>Test YUL compiled bytecode.</p> Source code in <code>fillers/example/yul_example.py</code> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from(Berlin))\ndef test_yul(state_test: StateTestFiller, fork: Fork):\n\"\"\"\n    Test YUL compiled bytecode.\n    \"\"\"\n    env = Environment()\n\n    pre = {\n        \"0x1000000000000000000000000000000000000000\": Account(\n            balance=0x0BA1A9CE0BA1A9CE,\n            code=Yul(\n\"\"\"\n            {\n                function f(a, b) -&gt; c {\n                    c := add(a, b)\n                }\n\n                sstore(0, f(1, 2))\n                return(0, 32)\n            }\n            \"\"\"\n            ),\n        ),\n        TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n    }\n\n    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=\"0x1000000000000000000000000000000000000000\",\n        gas_limit=500000,\n        gas_price=10,\n        protected=False,\n    )\n\n    post = {\n        \"0x1000000000000000000000000000000000000000\": Account(\n            storage={\n                0x00: 0x03,\n            },\n        ),\n    }\n\n    state_test(env=env, pre=pre, post=post, txs=[tx])\n</code></pre>"},{"location":"fillers/security/","title":"security","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/security\n</code></pre> <p>Cross-client Ethereum Security Tests</p>"},{"location":"fillers/security/selfdestruct_balance_bug/","title":"selfdestruct_balance_bug","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/security/selfdestruct_balance_bug.py\n</code></pre> <p>Tests the following consensus-vulnerability.</p> <p>https://github.com/ethereum/go-ethereum/security/advisories/GHSA-xw37-57qp-9mm4</p> <p>To reproduce the bug fill the test with the most recent geth evm version.</p> <p>Then run the fixture output within a vulnerable geth version: v1.9.20 &gt; geth &gt;= v1.9.4</p>"},{"location":"fillers/security/selfdestruct_balance_bug/#fillers.security.selfdestruct_balance_bug.test_tx_selfdestruct_balance_bug","title":"<code>test_tx_selfdestruct_balance_bug(blockchain_test, fork)</code>","text":"Checks balance of 0xaa after executing specific txs <ol> <li> <p>Start contract 0xaa that has initial balance of 3 wei.    0xaa contract code simply performs a self-destruct to itself.</p> </li> <li> <p>Send a transaction (tx 1) to invoke caller contract (with    1 wei balance), which in turn invokes 0xaa with a 1 wei call.</p> </li> <li> <p>Store the balance of 0xaa after the first transaction    is processed. 0xaa self-destructed. Expected outcome: 0 wei.</p> </li> <li> <p>Send another transaction (tx 2) to call 0xaa with 5 wei.</p> </li> <li> <p>Store the balance of 0xaa after the second transaction    is processed. No self-destruct. Expected outcome: 5 wei.</p> </li> <li> <p>Verify that:</p> <ul> <li>call within tx 1 is successful, i.e 0xaa self-destructed.</li> <li>the balances of 0xaa after each tx are correct.</li> <li>during tx 2, code in 0xaa does not execute,   hence self-destruct mechanism does not trigger.</li> </ul> </li> </ol> Source code in <code>fillers/security/selfdestruct_balance_bug.py</code> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from(Constantinople))\ndef test_tx_selfdestruct_balance_bug(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Checks balance of 0xaa after executing specific txs:\n\n        1. Start contract 0xaa that has initial balance of 3 wei.\n           0xaa contract code simply performs a self-destruct to itself.\n\n        2. Send a transaction (tx 1) to invoke caller contract (with\n           1 wei balance), which in turn invokes 0xaa with a 1 wei call.\n\n        3. Store the balance of 0xaa after the first transaction\n           is processed. 0xaa self-destructed. Expected outcome: 0 wei.\n\n        4. Send another transaction (tx 2) to call 0xaa with 5 wei.\n\n        5. Store the balance of 0xaa after the second transaction\n           is processed. No self-destruct. Expected outcome: 5 wei.\n\n        6. Verify that:\n            - call within tx 1 is successful, i.e 0xaa self-destructed.\n            - the balances of 0xaa after each tx are correct.\n            - during tx 2, code in 0xaa does not execute,\n              hence self-destruct mechanism does not trigger.\n    \"\"\"\n    aa_code = Yul(\n\"\"\"\n        {\n            /* 1st entrance is self-destruct */\n            if eq(0, callvalue()) {\n                selfdestruct(0x00000000000000000000000000000000000000AA)\n            }\n\n            /* 2nd entrance is other rnd code execution */\n            if eq(1, callvalue()) {\n                let x := selfbalance()\n                sstore(0, x)\n            }\n        }\n        \"\"\"\n    )\n\n    cc_code = Op.SSTORE(\n        0xCA1101, Op.CALL(100000, 0xAA, 0, 0, 0, 0, 0)\n    ) + Op.CALL(100000, 0xAA, 1, 0, 0, 0, 0)\n\n    balance_code = Op.SSTORE(0xBA1AA, Op.BALANCE(0xAA))\n\n    pre = {\n        # sender\n        TestAddress: Account(balance=1000000000),\n        # caller\n        to_address(0xCC): Account(balance=1000000000, code=cc_code),\n        # initial balance of 3 wei\n        to_address(0xAA): Account(balance=3, code=aa_code),\n        # stores balance of 0xaa after each tx 1\n        to_address(0xBA11): Account(code=balance_code),\n        # stores balance of 0xaa after each tx 2\n        to_address(0xBA12): Account(code=balance_code),\n    }\n\n    blocks = [\n        Block(\n            txs=[\n                # Sender invokes caller, caller invokes 0xaa:\n                # calling with 1 wei call\n                Transaction(\n                    nonce=0,\n                    to=to_address(0xCC),\n                    gas_limit=1000000,\n                    gas_price=10,\n                ),\n                # Dummy tx to store balance of 0xaa after first TX.\n                Transaction(\n                    nonce=1,\n                    to=to_address(0xBA11),\n                    gas_limit=100000,\n                    gas_price=10,\n                ),\n                # Sender calls 0xaa with 5 wei.\n                Transaction(\n                    nonce=2,\n                    to=to_address(0xAA),\n                    gas_limit=100000,\n                    gas_price=10,\n                    value=5,\n                ),\n                # Dummy tx to store balance of 0xaa after second TX.\n                Transaction(\n                    nonce=3,\n                    to=to_address(0xBA12),\n                    gas_limit=100000,\n                    gas_price=10,\n                ),\n            ],\n        ),\n    ]\n\n    post = {\n        # Check call from caller has succeeded.\n        to_address(0xCC): Account(storage={0xCA1101: 1}),\n        # Check balance of 0xaa after tx 1 is 0 wei, i.e self-destructed.\n        # Vulnerable versions should return 1 wei.\n        to_address(0xBA11): Account(storage={0xBA1AA: 0}),\n        # Check that 0xaa exists and balance after tx 2 is 5 wei.\n        # Vulnerable versions should return 6 wei.\n        to_address(0xBA12): Account(storage={0xBA1AA: 5}),\n        to_address(0xAA): Account(storage={0: 0}),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/","title":"withdrawals","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/withdrawals\n</code></pre> <p>Cross-client Withdrawals Tests</p>"},{"location":"fillers/withdrawals/withdrawals/","title":"withdrawals","text":"<p>Generate fixtures for these test cases with:</p> <pre><code>pytest -v fillers/withdrawals/withdrawals.py\n</code></pre> <p>Test Withdrawal system-level operation</p>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.set_withdrawal_index","title":"<code>set_withdrawal_index(withdrawals, start_index=0)</code>","text":"<p>Automatically set the index of each withdrawal in a list in sequential order.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def set_withdrawal_index(\n    withdrawals: List[Withdrawal], start_index: int = 0\n) -&gt; None:\n\"\"\"\n    Automatically set the index of each withdrawal in a list in sequential\n    order.\n    \"\"\"\n    for i, w in enumerate(withdrawals):\n        w.index = start_index + i\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx","title":"<code>TestUseValueInTx</code>","text":"<p>Test that the value from a withdrawal can be used in a transaction:</p> <ol> <li> <p>tx_in_withdrawals_block:   Test that the withdrawal value can not be used by a transaction in   the same block as the withdrawal.</p> </li> <li> <p>tx_after_withdrawals_block:   Test that the withdrawal value can be used by a transaction in the   subsequent block.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"test_case\",\n    [\"tx_in_withdrawals_block\", \"tx_after_withdrawals_block\"],\n    ids=lambda x: x,\n)\nclass TestUseValueInTx:\n\"\"\"\n    Test that the value from a withdrawal can be used in a transaction:\n\n    1. tx_in_withdrawals_block:\n      Test that the withdrawal value can not be used by a transaction in\n      the same block as the withdrawal.\n\n    2. tx_after_withdrawals_block:\n      Test that the withdrawal value can be used by a transaction in the\n      subsequent block.\n    \"\"\"\n\n    @pytest.fixture\n    def tx(self):  # noqa: D102\n        # Transaction sent from the `TestAddress`, which has 0 balance at start\n        return Transaction(\n            nonce=0,\n            gas_price=ONE_GWEI,\n            gas_limit=21000,\n            to=to_address(0x100),\n            data=\"0x\",\n        )\n\n    @pytest.fixture\n    def withdrawal(self, tx: Transaction):  # noqa: D102\n        return Withdrawal(\n            index=0,\n            validator=0,\n            address=TestAddress,\n            amount=tx.gas_limit + 1,\n        )\n\n    @pytest.fixture\n    def blocks(  # noqa: D102\n        self, tx: Transaction, withdrawal: Withdrawal, test_case\n    ):\n        if test_case == \"tx_in_withdrawals_block\":\n            return [\n                Block(\n                    txs=[\n                        tx.with_error(\n                            \"intrinsic gas too low: have 0, want 21000\"\n                        )\n                    ],\n                    withdrawals=[\n                        withdrawal,\n                    ],\n                    exception=\"Transaction without funds\",\n                )\n            ]\n        if test_case == \"tx_after_withdrawals_block\":\n            return [\n                Block(\n                    txs=[],\n                    withdrawals=[\n                        withdrawal,\n                    ],\n                ),\n                Block(\n                    txs=[tx],\n                    withdrawals=[],\n                ),\n            ]\n        raise Exception(\"Invalid test case.\")\n\n    @pytest.fixture\n    def post(self, test_case: str) -&gt; Dict:  # noqa: D102\n        if test_case == \"tx_in_withdrawals_block\":\n            return {}\n        if test_case == \"tx_after_withdrawals_block\":\n            return {TestAddress: Account(balance=ONE_GWEI)}\n        raise Exception(\"Invalid test case.\")\n\n    def test_use_value_in_tx(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        post: dict,\n        blocks: List[Block],\n    ):\n\"\"\"\n        Test sending withdrawal value in a transaction.\n        \"\"\"\n        pre = {TestAddress: Account(balance=0)}\n        blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx.test_use_value_in_tx","title":"<code>test_use_value_in_tx(blockchain_test, post, blocks)</code>","text":"<p>Test sending withdrawal value in a transaction.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_tx(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    post: dict,\n    blocks: List[Block],\n):\n\"\"\"\n    Test sending withdrawal value in a transaction.\n    \"\"\"\n    pre = {TestAddress: Account(balance=0)}\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_use_value_in_contract","title":"<code>test_use_value_in_contract(blockchain_test, fork)</code>","text":"<p>Test sending value from contract that has not received a withdrawal</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_contract(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test sending value from contract that has not received a withdrawal\n    \"\"\"\n    SEND_ONE_GWEI = Op.SSTORE(\n        Op.NUMBER,\n        Op.CALL(Op.GAS, 0x200, 1000000000, 0, 0, 0, 0),\n    )\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(balance=0, code=SEND_ONE_GWEI),\n        to_address(0x200): Account(balance=0),\n    }\n    tx = Transaction(\n        # Transaction sent from the `TestAddress`, which has 0 balance at start\n        nonce=0,\n        value=0,\n        gas_price=10,\n        gas_limit=100000,\n        to=to_address(0x100),\n        data=\"0x\",\n    )\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=to_address(0x100),\n        amount=1,\n    )\n\n    blocks = [\n        Block(\n            txs=[tx.with_nonce(0)],\n            withdrawals=[withdrawal],\n        ),\n        Block(\n            txs=[tx.with_nonce(1)],  # Same tx again, just increase nonce\n        ),\n    ]\n    post = {\n        to_address(0x100): Account(\n            storage={\n                0x1: 0x0,  # Call fails on the first attempt\n                0x2: 0x1,  # Succeeds on the second attempt\n            }\n        ),\n        to_address(0x200): Account(\n            balance=ONE_GWEI,\n        ),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_balance_within_block","title":"<code>test_balance_within_block(blockchain_test, fork)</code>","text":"<p>Test Withdrawal balance increase within the same block, inside contract call.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_balance_within_block(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test Withdrawal balance increase within the same block,\n    inside contract call.\n    \"\"\"\n    SAVE_BALANCE_ON_BLOCK_NUMBER = Op.SSTORE(\n        Op.NUMBER,\n        Op.BALANCE(Op.CALLDATALOAD(0)),\n    )\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=SAVE_BALANCE_ON_BLOCK_NUMBER,\n        ),\n        to_address(0x200): Account(\n            balance=ONE_GWEI,\n        ),\n    }\n    blocks = [\n        Block(\n            txs=[\n                Transaction(\n                    nonce=0,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                    data=to_hash(0x200),\n                )\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x200),\n                    amount=1,\n                )\n            ],\n        ),\n        Block(\n            txs=[\n                Transaction(\n                    nonce=1,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                    data=to_hash(0x200),\n                )\n            ]\n        ),\n    ]\n\n    post = {\n        to_address(0x100): Account(\n            storage={\n                1: ONE_GWEI,\n                2: 2 * ONE_GWEI,\n            }\n        )\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress","title":"<code>TestMultipleWithdrawalsSameAddress</code>","text":"<p>Test that multiple withdrawals can be sent to the same address in:</p> <ol> <li> <p>A single block.</p> </li> <li> <p>Multiple blocks.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\"test_case\", [\"single_block\", \"multiple_blocks\"])\nclass TestMultipleWithdrawalsSameAddress:\n\"\"\"\n    Test that multiple withdrawals can be sent to the same address in:\n\n    1. A single block.\n\n    2. Multiple blocks.\n    \"\"\"\n\n    ADDRESSES = [\n        to_address(0x0),  # Zero address\n        to_address(0x1),  # Pre-compiles\n        to_address(0x2),\n        to_address(0x3),\n        to_address(0x4),\n        to_address(0x5),\n        to_address(0x6),\n        to_address(0x7),\n        to_address(0x8),\n        to_address(0x9),\n        to_address(2**160 - 1),\n    ]\n\n    @pytest.fixture\n    def blocks(self, test_case: str):  # noqa: D102\n        if test_case == \"single_block\":\n            # Many repeating withdrawals of the same accounts in the same\n            # block.\n            return [\n                Block(\n                    withdrawals=[\n                        Withdrawal(\n                            index=i,\n                            validator=0,\n                            address=self.ADDRESSES[i % len(self.ADDRESSES)],\n                            amount=1,\n                        )\n                        for i in range(len(self.ADDRESSES) * 16)\n                    ],\n                ),\n            ]\n        if test_case == \"multiple_blocks\":\n            # Similar test but now use multiple blocks each with multiple\n            # withdrawals to the same withdrawal address.\n            return [\n                Block(\n                    withdrawals=[\n                        Withdrawal(\n                            index=i * 16 + j,\n                            validator=i,\n                            address=self.ADDRESSES[i],\n                            amount=1,\n                        )\n                        for j in range(16)\n                    ],\n                )\n                for i in range(len(self.ADDRESSES))\n            ]\n        raise Exception(\"Invalid test case.\")\n\n    def test_multiple_withdrawals_same_address(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        fork: Fork,\n        test_case: str,\n        blocks: List[Block],\n    ):\n\"\"\"\n        Test Withdrawals can be done to the same address multiple times in\n        the same block.\n        \"\"\"\n        pre = {\n            TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        }\n        for addr in self.ADDRESSES:\n            pre[addr] = Account(\n                code=SET_STORAGE,\n            )\n\n        # Expected post is the same for both test cases.\n        post = {}\n        for addr in self.ADDRESSES:\n            post[addr] = Account(\n                balance=16 * ONE_GWEI,\n                storage={},\n            )\n\n        blockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress.test_multiple_withdrawals_same_address","title":"<code>test_multiple_withdrawals_same_address(blockchain_test, fork, test_case, blocks)</code>","text":"<p>Test Withdrawals can be done to the same address multiple times in the same block.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_multiple_withdrawals_same_address(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    test_case: str,\n    blocks: List[Block],\n):\n\"\"\"\n    Test Withdrawals can be done to the same address multiple times in\n    the same block.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n    for addr in self.ADDRESSES:\n        pre[addr] = Account(\n            code=SET_STORAGE,\n        )\n\n    # Expected post is the same for both test cases.\n    post = {}\n    for addr in self.ADDRESSES:\n        post[addr] = Account(\n            balance=16 * ONE_GWEI,\n            storage={},\n        )\n\n    blockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_many_withdrawals","title":"<code>test_many_withdrawals(blockchain_test, fork)</code>","text":"<p>Test Withdrawals with a count of N withdrawals in a single block where N is a high number not expected to be seen in mainnet.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_many_withdrawals(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals with a count of N withdrawals in a single block where\n    N is a high number not expected to be seen in mainnet.\n    \"\"\"\n    N = 400\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n    withdrawals = []\n    post = {}\n    for i in range(N):\n        addr = to_address(0x100 * i)\n        amount = i * 1\n        pre[addr] = Account(\n            code=SET_STORAGE,\n        )\n        withdrawals.append(\n            Withdrawal(\n                index=i,\n                validator=i,\n                address=addr,\n                amount=amount,\n            )\n        )\n        post[addr] = Account(\n            code=SET_STORAGE,\n            balance=amount * ONE_GWEI,\n            storage={},\n        )\n\n    blocks = [\n        Block(\n            withdrawals=withdrawals,\n        ),\n    ]\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_self_destructing_account","title":"<code>test_self_destructing_account(blockchain_test, fork)</code>","text":"<p>Test withdrawals can be done to self-destructed accounts. Account <code>0x100</code> self-destructs and sends all its balance to <code>0x200</code>. Then, a withdrawal is received at <code>0x100</code> with 99 wei.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_self_destructing_account(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test withdrawals can be done to self-destructed accounts.\n    Account `0x100` self-destructs and sends all its balance to `0x200`.\n    Then, a withdrawal is received at `0x100` with 99 wei.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=Op.SELFDESTRUCT(Op.CALLDATALOAD(0)),\n            balance=(100 * ONE_GWEI),\n        ),\n        to_address(0x200): Account(\n            balance=0,\n        ),\n    }\n\n    tx_1 = Transaction(\n        # Transaction sent from the `TestAddress`, that calls a\n        # self-destructing contract.\n        nonce=0,\n        gas_price=10,\n        gas_limit=100000,\n        to=to_address(0x100),\n        data=to_hash(0x200),\n    )\n\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=to_address(0x100),\n        amount=(99),\n    )\n\n    block = Block(\n        txs=[tx_1],\n        withdrawals=[withdrawal],\n    )\n\n    post = {\n        to_address(0x100): Account(\n            code=None,\n            balance=(99 * ONE_GWEI),\n        ),\n        to_address(0x200): Account(\n            code=None,\n            balance=(100 * ONE_GWEI),\n        ),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=[block])\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_newly_created_contract","title":"<code>test_newly_created_contract(blockchain_test, fork, include_value_in_tx, request)</code>","text":"<p>Test Withdrawing to a newly created contract.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"include_value_in_tx\",\n    [False, True],\n    ids=[\"without_tx_value\", \"with_tx_value\"],\n)\ndef test_newly_created_contract(\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    include_value_in_tx: bool,\n    request,\n):\n\"\"\"\n    Test Withdrawing to a newly created contract.\n    \"\"\"\n    created_contract = compute_create_address(TestAddress, 0)\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n\n    initcode = Yul(\n\"\"\"\n        {\n            return(0, 1)\n        }\n        \"\"\"\n    )\n\n    tx = Transaction(\n        # Transaction sent from the `TestAddress`, that creates a\n        # new contract.\n        nonce=0,\n        gas_price=10,\n        gas_limit=1000000,\n        to=None,\n        data=initcode,\n    )\n\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=created_contract,\n        amount=1,\n    )\n\n    block = Block(\n        txs=[tx],\n        withdrawals=[withdrawal],\n    )\n\n    post = {\n        created_contract: Account(\n            code=\"0x00\",\n            balance=ONE_GWEI,\n        ),\n    }\n    if include_value_in_tx:\n        tx.value = ONE_GWEI\n        post[created_contract].balance = 2 * ONE_GWEI\n\n    tag = request.node.callspec.id.split(\"-\")[0]  # remove fork; brittle\n    blockchain_test(pre=pre, post=post, blocks=[block], tag=tag)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_no_evm_execution","title":"<code>test_no_evm_execution(blockchain_test, fork)</code>","text":"<p>Test Withdrawals don't trigger EVM execution.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_no_evm_execution(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals don't trigger EVM execution.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x200): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x300): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x400): Account(\n            code=SET_STORAGE,\n        ),\n    }\n    blocks = [\n        Block(\n            txs=[\n                Transaction(\n                    nonce=0,\n                    gas_limit=100000,\n                    to=to_address(0x300),\n                ),\n                Transaction(\n                    nonce=1,\n                    gas_limit=100000,\n                    to=to_address(0x400),\n                ),\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x100),\n                    amount=1,\n                ),\n                Withdrawal(\n                    index=1,\n                    validator=1,\n                    address=to_address(0x200),\n                    amount=1,\n                ),\n            ],\n        ),\n        Block(\n            txs=[\n                Transaction(\n                    nonce=2,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                ),\n                Transaction(\n                    nonce=3,\n                    gas_limit=100000,\n                    to=to_address(0x200),\n                ),\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x300),\n                    amount=1,\n                ),\n                Withdrawal(\n                    index=1,\n                    validator=1,\n                    address=to_address(0x400),\n                    amount=1,\n                ),\n            ],\n        ),\n    ]\n\n    post = {\n        to_address(0x100): Account(storage={2: 1}),\n        to_address(0x200): Account(storage={2: 1}),\n        to_address(0x300): Account(storage={1: 1}),\n        to_address(0x400): Account(storage={1: 1}),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount","title":"<code>TestZeroAmount</code>","text":"<p>Test withdrawals with zero amount for the following cases, all withdrawals are included in one block:</p> <ol> <li> <p>Two withdrawals of zero amount to two different addresses; one to an    untouched account, one to an account with a balance.</p> </li> <li> <p>As 1., but with an additional withdrawal with positive value.</p> </li> <li> <p>As 2., but with an additional withdrawal containing the maximum value    possible.</p> </li> <li> <p>As 3., but with order of withdrawals in the block reversed.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"test_case\",\n    [case for case in ZeroAmountTestCases],\n    ids=[case.value for case in ZeroAmountTestCases],\n)\nclass TestZeroAmount:\n\"\"\"\n    Test withdrawals with zero amount for the following cases, all withdrawals\n    are included in one block:\n\n    1. Two withdrawals of zero amount to two different addresses; one to an\n       untouched account, one to an account with a balance.\n\n    2. As 1., but with an additional withdrawal with positive value.\n\n    3. As 2., but with an additional withdrawal containing the maximum value\n       possible.\n\n    4. As 3., but with order of withdrawals in the block reversed.\n\n    \"\"\"\n\n    @pytest.fixture(scope=\"function\")\n    def test_case_parameters(self, test_case):  # noqa: D102\n        withdrawals = [\n            # No value, untouched account\n            Withdrawal(\n                index=0,\n                validator=0,\n                address=to_address(0x100),\n                amount=0,\n            ),\n            # No value, touched account\n            Withdrawal(\n                index=0,\n                validator=0,\n                address=to_address(0x200),\n                amount=0,\n            ),\n            # Withdrawal with value\n            Withdrawal(\n                index=1,\n                validator=0,\n                address=to_address(0x300),\n                amount=1,\n            ),\n            # Withdrawal with maximum amount\n            Withdrawal(\n                index=2,\n                validator=0,\n                address=to_address(0x400),\n                amount=2**64 - 1,\n            ),\n        ]\n        post = {\n            to_address(0x100): Account.NONEXISTENT,\n            to_address(0x200): Account(code=\"0x00\", balance=0),\n            to_address(0x300): Account(balance=ONE_GWEI),\n            to_address(0x400): Account(balance=(2**64 - 1) * ONE_GWEI),\n        }\n        if test_case == ZeroAmountTestCases.TWO_ZERO:\n            return {\n                \"withdrawals\": withdrawals[0:2],\n                \"post\": {\n                    account: post[account]\n                    for account in post\n                    if account in [to_address(0x100), to_address(0x200)]\n                },\n            }\n        if test_case == ZeroAmountTestCases.THREE_ONE_WITH_VALUE:\n            return {\n                \"withdrawals\": withdrawals[0:3],\n                \"post\": {\n                    account: post[account]\n                    for account in post\n                    if account\n                    in [\n                        to_address(0x100),\n                        to_address(0x200),\n                        to_address(0x300),\n                    ]\n                },\n            }\n        if test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX:\n            return {\"withdrawals\": withdrawals, \"post\": post}\n        if test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX_REVERSED:\n            withdrawals.reverse()\n            set_withdrawal_index(withdrawals)\n            return {\"withdrawals\": withdrawals, \"post\": post}\n        raise Exception(\"Unknown test case.\")\n\n    def test_zero_amount(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        fork: Fork,\n        test_case: ZeroAmountTestCases,\n        test_case_parameters: Dict,\n    ):\n\"\"\"\n        Test Withdrawals where one of the withdrawal has a zero amount.\n        \"\"\"\n        pre = {\n            TestAddress: Account(balance=1000000000000000000000, nonce=0),\n            to_address(0x200): Account(\n                code=\"0x00\",\n                balance=0,\n            ),\n        }\n\n        blockchain_test(\n            pre=pre,\n            post=test_case_parameters[\"post\"],\n            blocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\n            tag=test_case.value,\n        )\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount.test_zero_amount","title":"<code>test_zero_amount(blockchain_test, fork, test_case, test_case_parameters)</code>","text":"<p>Test Withdrawals where one of the withdrawal has a zero amount.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_zero_amount(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    test_case: ZeroAmountTestCases,\n    test_case_parameters: Dict,\n):\n\"\"\"\n    Test Withdrawals where one of the withdrawal has a zero amount.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x200): Account(\n            code=\"0x00\",\n            balance=0,\n        ),\n    }\n\n    blockchain_test(\n        pre=pre,\n        post=test_case_parameters[\"post\"],\n        blocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\n        tag=test_case.value,\n    )\n</code></pre>"},{"location":"fillers/withdrawals/withdrawals/#fillers.withdrawals.withdrawals.test_large_amount","title":"<code>test_large_amount(blockchain_test, fork)</code>","text":"<p>Test Withdrawals that have a large gwei amount, so that (gwei * 1e9) could overflow uint64 but not uint256.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_large_amount(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals that have a large gwei amount, so that (gwei * 1e9)\n    could overflow uint64 but not uint256.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n\n    withdrawals: List[Withdrawal] = []\n    amounts: List[int] = [\n        (2**35),\n        (2**64) - 1,\n        (2**63) + 1,\n        (2**63),\n        (2**63) - 1,\n    ]\n\n    post = {}\n\n    for i, amount in enumerate(amounts):\n        addr = to_address(0x100 * (i + 1))\n        withdrawals.append(\n            Withdrawal(\n                index=i,\n                validator=i,\n                address=addr,\n                amount=amount,\n            )\n        )\n        post[addr] = Account(balance=(amount * ONE_GWEI))\n\n    blocks = [\n        Block(\n            withdrawals=withdrawals,\n        )\n    ]\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"getting_help/","title":"Getting Help","text":"<p>The tests in this repository are a community effort to help improve the development cycle of all Ethereum execution clients.</p> <p>We encourage contributions and recognize that Python is not everyone's  primary language - if you stumble over issues or need help, please reach out to one of the execution-spec-tests maintainers either directly or in the <code>#testing</code> channel in the Ethereum R&amp;D Discord Server.</p>"},{"location":"getting_help/#maintainers-discord-handles","title":"Maintainers Discord Handles","text":"<p><pre><code>danceratopz#6962\n</code></pre> <pre><code>Spencer Taylor-Brown#8478\n</code></pre> <pre><code>Mario Vega#7267\n</code></pre></p> <p></p>"},{"location":"getting_started/executing_tests_command_line/","title":"Executing Tests at a Prompt","text":""},{"location":"getting_started/executing_tests_command_line/#collection-test-exploration","title":"Collection - Test Exploration","text":"<p>The test fillers implemented in the <code>./fillers</code> sub-directory can be listed in the console using: <pre><code>pytest --collect-only\n</code></pre> and can be filtered (by test path, function and parameter substring): <pre><code>pytest --collect-only -k warm_coinbase\n</code></pre> Docstrings are additionally displayed when ran verbosely: <pre><code>pytest --collect-only -k warm_coinbase -vv\n</code></pre></p>"},{"location":"getting_started/executing_tests_command_line/#execution","title":"Execution","text":"<p>To generate all the test fixtures defined in the <code>./fillers</code> sub-directory and write them to the <code>./fixtures</code> directory, run <code>pytest</code> in the top-level directory as: <pre><code>pytest --output=\"fixtures\"\n</code></pre></p> <p>Test case verification</p> <p>Note, that the test <code>post</code> conditions are tested against the output of the <code>evm t8n</code> command for transition tests, respectively <code>evm b11r</code> command for blockchain tests, during test generation.</p> <p>To generate all the test fixtures in the <code>./fillers/eips/</code> sub-directory (category), for example, run: <pre><code>pytest fillers/eips\n</code></pre></p> <p>To generate all the test fixtures in the <code>./fillers/eips/eip3651.py</code> module, for example, run: <pre><code>pytest ./fillers/eips/eip3651.py\n</code></pre></p> <p>To generate specific test fixtures, such as those from the test function <code>test_warm_coinbase_call_out_of_gas()</code>, for example, run: <pre><code>pytest -k \"test_warm_coinbase_call_out_of_gas\"\n</code></pre> or, additionally, only for the for Shanghai fork: <pre><code>pytest -k \"test_warm_coinbase_call_out_of_gas and shanghai\"\n</code></pre></p>"},{"location":"getting_started/executing_tests_command_line/#execution-for-development-forks","title":"Execution for Development Forks","text":"<p>By default, test cases are not executed with upcoming Ethereum forks so that they can be readily executed against the <code>evm</code> tool from the latest <code>geth</code> release. </p> <p>In order to execute test cases for an upcoming fork, ensure that the <code>evm</code> tool used supports that fork and features under test and use the <code>--latest-fork</code> flag.</p> <p>For example, as of May 2023, the current fork under active development is <code>Cancun</code>: <pre><code>pytest --latest-fork Cancun\n</code></pre></p> <p>See: Executing Tests for Features under Development.</p>"},{"location":"getting_started/executing_tests_command_line/#useful-pytest-command-line-options","title":"Useful pytest Command-Line Options","text":"<pre><code>pytest -vv            # More verbose output\npytest -x             # Exit instantly on first error or failed test filler:\npytest --pdb          # drop into the debugger upon error in a test filler\npytest --traces       # Collect traces of the execution information from the transition tool\npytest --evm=EVM_BIN  # Specify the evm executable to generate fillers with\n</code></pre>"},{"location":"getting_started/executing_tests_dev_fork/","title":"Executing Tests for Features under Development","text":""},{"location":"getting_started/executing_tests_dev_fork/#requirements","title":"Requirements","text":"<p>By default, execution-spec-tests only generates fixtures for forks that have been deployed to mainnet. In order to generate fixtures for evm features that are actively under development:</p> <ol> <li>A version of the <code>evm</code> and <code>solc</code> tools that implement the feature must be available (although, typically only a developer version of the <code>evm</code> tool is required, usually the latest stable release of <code>solc</code> is adequate), and,</li> <li>The development fork to test must be explicitly specified on the command-line when generating tests:     <pre><code>pytest -v -k 4844 --latest-fork=Cancun\n</code></pre></li> </ol> <p>Specifying the <code>evm</code> binary via <code>evm-bin</code></p> <p>It is possible to explicitly specify the <code>evm</code> binary used to generate fixtures via the <code>--evm-bin</code> flag, for example,  <pre><code>pytest -v --latest-fork=Cancun --evm-bin=/opt/bin/evm\n</code></pre></p>"},{"location":"getting_started/executing_tests_dev_fork/#further-help","title":"Further Help","text":"<ol> <li><code>geth</code>/<code>evm</code> build documentation.</li> <li><code>solc</code> build documentation.</li> </ol> <p>Verifying <code>evm</code> and <code>solc</code> versions used</p> <p>The versions used to generate fixtures are displayed in the console output:   </p>"},{"location":"getting_started/executing_tests_dev_fork/#vs-code-setup","title":"VS Code Setup","text":"<p>By default, VS Code's Testing View will only show tests for stable forks. To show tests for development forks, uncomment the relevant line in the <code>python.testing.pytestArgs</code> configuration section of included settings file (<code>.vscode/settings.json</code>) to enable the <code>--latest-fork=FORK</code> flag. See VS Code Setup for help finding the settings files.</p>"},{"location":"getting_started/executing_tests_vs_code/","title":"Executing Tests in VS Code","text":"<p>Prerequisite: VS Code Setup.</p>"},{"location":"getting_started/executing_tests_vs_code/#exploring-test-cases","title":"Exploring Test Cases","text":"<p>Implemented test cases can be explored in VS Code's \"Testing\" View; click on the conical flask highlighted in the screenshot below.</p> <p></p> <p>Testing EVM Features Under Active Development</p> <p>See the VS Code section in Executing Tests for Features under Development to explore tests targeting EVM features under development.</p>"},{"location":"getting_started/executing_tests_vs_code/#executing-and-debugging-test-cases","title":"Executing and Debugging Test Cases","text":""},{"location":"getting_started/quick_start/","title":"Quick Start","text":"<p>Testing features under active development</p> <p>The EVM features under test must be implemented in the <code>evm</code> tool and <code>solc</code> executables that are used by the execution-spec-tests framework. The following guide installs stable versions of these tools. </p> <p>To test features under active development, start with this base configuration and then follow the steps in executing tests for features under development. </p> <p>The following requires a Python 3.10 installation.</p> <ol> <li> <p>Ensure go-ethereum's <code>evm</code> tool and <code>solc</code> are in your path. Either build the required versions, or alternatively:</p> UbuntumacosWindows <p><pre><code>sudo add-apt-repository -y ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install ethereum solc\n</code></pre>   More help:</p> <ul> <li>geth installation doc.</li> <li>solc installation doc.</li> </ul> <p><pre><code>brew update\nbrew upgrade\nbrew tap ethereum/ethereum\nbrew install ethereum solidity\n</code></pre>   More help:</p> <ul> <li>geth installation doc.</li> <li>solc installation doc.</li> </ul> <p>Binaries available here:</p> <ul> <li>geth (binary or installer).</li> <li>solc.</li> </ul> <p>More help:</p> <ul> <li>geth installation doc.</li> <li>solc static binaries doc.</li> </ul> </li> <li> <p>Clone the execution-spec-tests repo and install its and dependencies (it's recommended to use a virtual environment for the installation):    <pre><code>git clone https://github.com/ethereum/execution-spec-tests\ncd execution-spec-tests\npython3 -m venv ./venv/\nsource ./venv/bin/activate\npip install -e .[docs,lint,test]\n</code></pre></p> </li> <li> <p>Verify installation:</p> <ol> <li> <p>Explore test cases:    <pre><code>pytest --collect-only\n</code></pre>    Expected console output:     </p> </li> <li> <p>Execute the test cases (verbosely) in the <code>./fillers/example/acl_example.py</code> module:     <pre><code>pytest -v fillers/example/acl_example.py\n</code></pre>     Expected console output:           Check:</p> <ol> <li>The versions of the <code>evm</code> and <code>solc</code> tools are as expected (your versions may differ from those in the highlighted box).</li> <li>The fixture file <code>out/example/acl_example/test_access_list.json</code> has been generated.</li> </ol> </li> </ol> </li> </ol>"},{"location":"getting_started/quick_start/#next-steps","title":"Next Steps:","text":"<ol> <li>Learn useful command-line flags.</li> <li>Execute tests for features under development via the <code>--latest-fork</code> flag.</li> <li>Optional: Configure VS Code to auto-format Python code and execute tests within VS Code.</li> <li>Implement a new test case, see Writing Tests.</li> </ol>"},{"location":"getting_started/repository_overview/","title":"Repository Overview","text":"<p>The most relevant folders and file in the repo are: <pre><code>\ud83d\udcc1 execution-test-specs/\n\u251c\u2500\u2574\ud83d\udcc1 fillers/                   # test cases\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 eips/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 vm/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 out/                       # default fixture output dir\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 eips/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 vm/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 src/                       # library &amp; framework packages\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 ethereum_test_fork/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 ethereum_test_tools/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 docs/                      # markdown documentation\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 getting_started\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 dev\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n\u251c\u2500\u2574\ud83d\udcc1 .vscode/                   # visual studio code config\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 settings.recommended.json # copy to settings.json\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 launch.recommended.json\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 extensions.json\n\u2514\u2500\u2500 \ud83d\udcc4 whitelist.txt             # spellcheck dictionary\n</code></pre></p>"},{"location":"getting_started/repository_overview/#fillers","title":"<code>fillers/</code>","text":"<p>Contains the implementation of the Ethereum consensus tests available in this repository.</p>"},{"location":"getting_started/repository_overview/#src","title":"<code>src/</code>","text":"<p>Contains various packages that help to define test cases and to interface with the <code>evm t8n</code> and <code>evm b11r</code> commands. Additionally, it contains some packages that enable test case (filler) execution by customizing pytest which acts as the test framework.</p>"},{"location":"getting_started/repository_overview/#docs","title":"<code>docs/</code>","text":"<p>Contains documentation configuration and source files.</p>"},{"location":"getting_started/repository_overview/#vscode","title":"<code>.vscode/</code>","text":"<p>See VS Code Setup.</p>"},{"location":"getting_started/setup_vs_code/","title":"VS Code Setup","text":"<p>VS Code setup is optional, but does offer the following advantages:</p> <ul> <li>Auto-format your Python code to conform to the repository's code standards (black).</li> <li>Inline linting and auto-completion (thanks to Python type hints).</li> <li>Spell-check your code and docs.</li> <li>Graphical exploration of test cases and easy test execution/debug.</li> </ul>"},{"location":"getting_started/setup_vs_code/#installation","title":"Installation","text":"<p>Please refer to the Visual Studio Code docs for help with installation.</p>"},{"location":"getting_started/setup_vs_code/#vs-code-settings-file","title":"VS Code Settings file","text":"<p>The ethereum/execution-spec-tests repo includes configuration files for VS Code in the <code>.vscode/</code> sub-directory:</p> <pre><code>\ud83d\udcc1 execution-test-specs/\n\u2514\u2500\u2500\ud83d\udcc1 .vscode/\n    \u251c\u2500\u2500 \ud83d\udcc4 settings.recommended.json\n    \u251c\u2500\u2500 \ud83d\udcc4 extensions.json\n    \u2514\u2500\u2500 \ud83d\udcc4 launch.recommended.json\n</code></pre> <p>To enable the recommended settings, copy the settings file to the expected location:</p> <pre><code>cp .vscode/settings.recommended.json .vscode/settings.json\n</code></pre> <p>To additionally enable the recommended launch configurations:</p> <pre><code>cp .vscode/launch.recommended.json .vscode/launch.json\n</code></pre>"},{"location":"getting_started/setup_vs_code/#additional-vs-code-extensions","title":"Additional VS Code Extensions","text":"<p>Open the folder in VS Code where execution-spec-tests is cloned: VS Code should prompt to install the repository's required extensions from <code>.vscode/extensions.json</code>:</p> <ul> <li><code>ms-python.python</code></li> <li><code>ms-python.isort</code></li> <li><code>ms-python.flake8</code></li> <li><code>ms-python.black-formatter</code></li> <li><code>esbenp.prettier-vscode</code></li> <li><code>streetsidesoftware.code-spell-checker</code></li> <li><code>tamasfe.even-better-toml</code></li> </ul> <p>Workspace Trust</p> <p>Trust the <code>execution-specs-test</code> repository when opening in VS Code to be prompted to install the plugins recommended via the <code>extensions.json</code> file.</p>"},{"location":"getting_started/setup_vs_code/#configuration-for-testing-evm-features-under-active-development","title":"Configuration for Testing EVM Features Under Active Development","text":"<p>An additional step is required to enable fixture generations for features from forks that are under active development and have not been deployed to mainnet, see Executing Tests for Features under Development.</p>"},{"location":"library/","title":"Library (Tools) Reference Documentation","text":"<p>Execution spec tests consists of several packages that implement helper classes and tools that enable and simplify filler implementation. This section contains their reference documentation:</p> <ul> <li><code>evm_transition_tool</code> - a wrapper for the transition (<code>t8n</code>) tool.</li> <li><code>evm_block_builder</code> - a wrapper for the block builder (<code>b11r</code>) tool.</li> <li><code>ethereum_test_tools</code> - provides primitives and helpers to test Ethereum execution clients. </li> <li><code>ethereum_test_forks</code> - provides definitions for supported forks used in tests.</li> <li><code>pytest_plugins</code> - contains pytest customizations that provide additional functionality for generating test fixtures.</li> </ul>"},{"location":"library/ethereum_test_forks/","title":"Ethereum Test Forks package","text":"<p>Ethereum test fork definitions.</p>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier","title":"<code>Frontier</code>","text":"<p>         Bases: <code>BaseFork</code></p> <p>Frontier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Frontier(BaseFork):\n\"\"\"\n    Frontier fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain base fee\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_prev_randao_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain Prev Randao value\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_zero_difficulty_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not have difficulty zero\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_withdrawals_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain withdrawals\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_excess_data_gas_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain excess data gas\n        \"\"\"\n        return False\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Genesis the expected reward amount in wei is\n        5_000_000_000_000_000_000\n        \"\"\"\n        return 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain base fee</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain base fee\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain Prev Randao value</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain Prev Randao value\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not have difficulty zero</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not have difficulty zero\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain withdrawals</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain withdrawals\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain excess data gas</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain excess data gas\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Genesis the expected reward amount in wei is 5_000_000_000_000_000_000</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Genesis the expected reward amount in wei is\n    5_000_000_000_000_000_000\n    \"\"\"\n    return 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun","title":"<code>Cancun</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Cancun fork</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>class Cancun(Shanghai):\n\"\"\"\n    Cancun fork\n    \"\"\"\n\n    @classmethod\n    def header_excess_data_gas_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Excess data gas is required starting from Cancun.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.upcoming.Cancun.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Excess data gas is required starting from Cancun.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.BerlinToLondonAt5","title":"<code>BerlinToLondonAt5</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>Berlin to London transition at Block 5 fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=London)\nclass BerlinToLondonAt5(Berlin):\n\"\"\"\n    Berlin to London transition at Block 5 fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\n        return block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.BerlinToLondonAt5.header_base_fee_required","title":"<code>header_base_fee_required(block_number, _)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\n    return block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MergeToShanghaiAtTime15k","title":"<code>MergeToShanghaiAtTime15k</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Merge to Shanghai transition at Timestamp 15k fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Shanghai)\nclass MergeToShanghaiAtTime15k(Merge):\n\"\"\"\n    Merge to Shanghai transition at Timestamp 15k fork\n    \"\"\"\n\n    @classmethod\n    def header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\n        return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.MergeToShanghaiAtTime15k.header_withdrawals_required","title":"<code>header_withdrawals_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\n    return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.InvalidForkError","title":"<code>InvalidForkError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Invalid fork error raised when the fork specified by command-line option --latest-fork is not found.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>class InvalidForkError(Exception):\n\"\"\"\n    Invalid fork error raised when the fork specified by command-line option\n    --latest-fork is not found.\n    \"\"\"\n\n    def __init__(self, message):\n        super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork","title":"<code>set_latest_fork(fork)</code>","text":"<p>Sets the latest fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork(fork: Fork) -&gt; None:\n\"\"\"\n    Sets the latest fork\n    \"\"\"\n    latest_fork_resolver.latest_fork = fork\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ShanghaiToCancunAtTime15k","title":"<code>ShanghaiToCancunAtTime15k</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Shanghai to Cancun transition at Timestamp 15k</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Cancun)\nclass ShanghaiToCancunAtTime15k(Shanghai):\n\"\"\"\n    Shanghai to Cancun transition at Timestamp 15k\n    \"\"\"\n\n    @classmethod\n    def header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Excess data gas is required if transitioning to Cancun.\n        \"\"\"\n        return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.ShanghaiToCancunAtTime15k.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required if transitioning to Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Excess data gas is required if transitioning to Cancun.\n    \"\"\"\n    return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork_by_name","title":"<code>set_latest_fork_by_name(fork_name)</code>","text":"<p>Sets the latest fork by name</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork_by_name(fork_name: str) -&gt; None:\n\"\"\"\n    Sets the latest fork by name\n    \"\"\"\n    if fork_name in forks.__dict__:\n        set_latest_fork(forks.__dict__[fork_name])\n    elif fork_name in upcoming.__dict__:\n        set_latest_fork(upcoming.__dict__[fork_name])\n    else:\n        raise InvalidForkError(f'fork \"{fork_name}\" not found')\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from_until","title":"<code>forks_from_until(fork_from, fork_until)</code>","text":"<p>Returns the specified fork and all forks after it until and including the second specified fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from_until(fork_from: Fork, fork_until: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it until and including the\n    second specified fork\n    \"\"\"\n    prev_fork = fork_until\n\n    forks: List[Fork] = []\n\n    while prev_fork != BaseFork and prev_fork != fork_from:\n        forks.insert(0, prev_fork)\n\n        prev_fork = prev_fork.__base__\n\n    if prev_fork == BaseFork:\n        return []\n\n    forks.insert(0, fork_from)\n\n    return forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead","title":"<code>Homestead</code>","text":"<p>         Bases: <code>Frontier</code></p> <p>Homestead fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Homestead(Frontier):\n\"\"\"\n    Homestead fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium","title":"<code>Byzantium</code>","text":"<p>         Bases: <code>Homestead</code></p> <p>Byzantium fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Byzantium(Homestead):\n\"\"\"\n    Byzantium fork\n    \"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Byzantium, the block reward is reduced to\n        3_000_000_000_000_000_000 wei\n        \"\"\"\n        return 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Byzantium.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Byzantium, the block reward is reduced to 3_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Byzantium, the block reward is reduced to\n    3_000_000_000_000_000_000 wei\n    \"\"\"\n    return 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from","title":"<code>forks_from(fork)</code>","text":"<p>Returns the specified fork and all forks after it</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it\n    \"\"\"\n    return forks_from_until(fork, latest_fork_resolver.latest_fork)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople","title":"<code>Constantinople</code>","text":"<p>         Bases: <code>Byzantium</code></p> <p>Constantinople fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Constantinople(Byzantium):\n\"\"\"\n    Constantinople fork\n    \"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Constantinople, the block reward is reduced to\n        2_000_000_000_000_000_000 wei\n        \"\"\"\n        return 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Constantinople.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Constantinople, the block reward is reduced to 2_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Constantinople, the block reward is reduced to\n    2_000_000_000_000_000_000 wei\n    \"\"\"\n    return 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.is_fork","title":"<code>is_fork(fork, which)</code>","text":"<p>Returns <code>True</code> if <code>fork</code> is <code>which</code> or beyond, `False otherwise.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def is_fork(fork: Fork, which: Fork) -&gt; bool:\n\"\"\"\n    Returns `True` if `fork` is `which` or beyond, `False otherwise.\n    \"\"\"\n    prev_fork = fork\n\n    while prev_fork != BaseFork:\n        if prev_fork == which:\n            return True\n\n        prev_fork = prev_fork.__base__\n\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ConstantinopleFix","title":"<code>ConstantinopleFix</code>","text":"<p>         Bases: <code>Constantinople</code></p> <p>Constantinople Fix fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ConstantinopleFix(Constantinople):\n\"\"\"\n    Constantinople Fix fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.fork_only","title":"<code>fork_only(fork)</code>","text":"<p>Returns the specified fork only if it's a fork that precedes the latest</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def fork_only(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork only if it's a fork that precedes the latest\n    \"\"\"\n    if issubclass(fork, TransitionBaseClass):\n        if fork.transitions_to() is not None:\n            if is_fork(\n                latest_fork_resolver.latest_fork, fork.transitions_to()\n            ):\n                return [fork]\n        return []\n    if is_fork(latest_fork_resolver.latest_fork, fork):\n        return [fork]\n    return []\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul","title":"<code>Istanbul</code>","text":"<p>         Bases: <code>ConstantinopleFix</code></p> <p>Istanbul fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Istanbul(ConstantinopleFix):\n\"\"\"\n    Istanbul fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MuirGlacier","title":"<code>MuirGlacier</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Muir Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class MuirGlacier(Istanbul):\n\"\"\"\n    Muir Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin","title":"<code>Berlin</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Berlin fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Berlin(Istanbul):\n\"\"\"\n    Berlin fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London","title":"<code>London</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>London fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class London(Berlin):\n\"\"\"\n    London fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.London.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ArrowGlacier","title":"<code>ArrowGlacier</code>","text":"<p>         Bases: <code>London</code></p> <p>Arrow Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ArrowGlacier(London):\n\"\"\"\n    Arrow Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.GrayGlacier","title":"<code>GrayGlacier</code>","text":"<p>         Bases: <code>ArrowGlacier</code></p> <p>Gray Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class GrayGlacier(ArrowGlacier):\n\"\"\"\n    Gray Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Merge","title":"<code>Merge</code>","text":"<p>         Bases: <code>London</code></p> <p>Merge fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Merge(London):\n\"\"\"\n    Merge fork\n    \"\"\"\n\n    @classmethod\n    def header_prev_randao_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Prev Randao is required starting from Merge.\n        \"\"\"\n        return True\n\n    @classmethod\n    def header_zero_difficulty_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Zero difficulty is required starting from Merge.\n        \"\"\"\n        return True\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        Merge updates the reward to 0.\n        \"\"\"\n        return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Prev Randao is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Prev Randao is required starting from Merge.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Zero difficulty is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Zero difficulty is required starting from Merge.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Merge updates the reward to 0.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    Merge updates the reward to 0.\n    \"\"\"\n    return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai","title":"<code>Shanghai</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Shanghai fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Shanghai(Merge):\n\"\"\"\n    Shanghai fork\n    \"\"\"\n\n    @classmethod\n    def header_withdrawals_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Shanghai.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_tools/","title":"Ethereum Test Tools Package","text":"<p>Module containing tools for generating cross-client Ethereum execution layer tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Code","title":"<code>Code</code>  <code>dataclass</code>","text":"<p>Generic code object.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>@dataclass(kw_only=True)\nclass Code:\n\"\"\"\n    Generic code object.\n    \"\"\"\n\n    bytecode: Optional[bytes] = None\n\"\"\"\n    bytes array that represents the bytecode of this object.\n    \"\"\"\n    name: Optional[str] = None\n\"\"\"\n    Name used to describe this code.\n    Usually used to add extra information to a test case.\n    \"\"\"\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Transform the Code object into bytes.\n        Normally will be overriden by the classes that inherit this class.\n        \"\"\"\n        if self.bytecode is None:\n            return bytes()\n        else:\n            return self.bytecode\n\n    def __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\n        return Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\n\n    def __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\n        return Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.bytecode","title":"<code>bytecode: Optional[bytes] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>bytes array that represents the bytecode of this object.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name used to describe this code. Usually used to add extra information to a test case.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.assemble","title":"<code>assemble()</code>","text":"<p>Transform the Code object into bytes. Normally will be overriden by the classes that inherit this class.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Transform the Code object into bytes.\n    Normally will be overriden by the classes that inherit this class.\n    \"\"\"\n    if self.bytecode is None:\n        return bytes()\n    else:\n        return self.bytecode\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\n    return Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\n    return Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ceiling_division","title":"<code>ceiling_division(a, b)</code>","text":"<p>Calculates the ceil without using floating point. Used by many of the EVM's formulas</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def ceiling_division(a: int, b: int) -&gt; int:\n\"\"\"\n    Calculates the ceil without using floating point.\n    Used by many of the EVM's formulas\n    \"\"\"\n    return -(a // -b)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode","title":"<code>Initcode</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate initcode for the specified deployment code.</p> <p>The execution gas cost of the initcode is calculated, and also the deployment gas costs for the deployed code.</p> <p>The initcode can be padded to a certain length if necessary, which does not affect the deployed code.</p> <p>Other costs such as the CREATE2 hashing costs or the initcode_word_cost of EIP-3860 are not taken into account by any of these calculated costs.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Initcode(Code):\n\"\"\"\n    Helper class used to generate initcode for the specified deployment code.\n\n    The execution gas cost of the initcode is calculated, and also the\n    deployment gas costs for the deployed code.\n\n    The initcode can be padded to a certain length if necessary, which\n    does not affect the deployed code.\n\n    Other costs such as the CREATE2 hashing costs or the initcode_word_cost\n    of EIP-3860 are *not* taken into account by any of these calculated\n    costs.\n    \"\"\"\n\n    deploy_code: bytes | str | Code\n\"\"\"\n    Bytecode to be deployed by the initcode.\n    \"\"\"\n    execution_gas: int\n\"\"\"\n    Gas cost of executing the initcode, without considering deployment gas\n    costs.\n    \"\"\"\n    deployment_gas: int\n\"\"\"\n    Gas cost of deploying the cost, subtracted after initcode execution,\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        deploy_code: str | bytes | Code,\n        initcode_length: Optional[int] = None,\n        padding_byte: int = 0x00,\n        name: Optional[str] = None,\n    ):\n\"\"\"\n        Generate legacy initcode that inits a contract with the specified code.\n        The initcode can be padded to a specified length for testing purposes.\n        \"\"\"\n        self.execution_gas = 0\n        self.deploy_code = deploy_code\n        deploy_code_bytes = code_to_bytes(self.deploy_code)\n        code_length = len(deploy_code_bytes)\n\n        initcode = bytearray()\n\n        # PUSH2: length=&lt;bytecode length&gt;\n        initcode.append(0x61)\n        initcode += code_length.to_bytes(length=2, byteorder=\"big\")\n        self.execution_gas += 3\n\n        # PUSH1: offset=0\n        initcode.append(0x60)\n        initcode.append(0x00)\n        self.execution_gas += 3\n\n        # DUP2\n        initcode.append(0x81)\n        self.execution_gas += 3\n\n        # PUSH1: initcode_length=11 (constant)\n        initcode.append(0x60)\n        initcode.append(0x0B)\n        self.execution_gas += 3\n\n        # DUP3\n        initcode.append(0x82)\n        self.execution_gas += 3\n\n        # CODECOPY: destinationOffset=0, offset=0, length\n        initcode.append(0x39)\n        self.execution_gas += (\n            3\n            + (3 * ceiling_division(code_length, 32))\n            + (3 * code_length)\n            + ((code_length * code_length) // 512)\n        )\n\n        # RETURN: offset=0, length\n        initcode.append(0xF3)\n        self.execution_gas += 0\n\n        pre_padding_bytes = bytes(initcode) + deploy_code_bytes\n\n        if initcode_length is not None:\n            if len(pre_padding_bytes) &gt; initcode_length:\n                raise Exception(\"Invalid specified length for initcode\")\n\n            padding_bytes = bytes(\n                [padding_byte] * (initcode_length - len(pre_padding_bytes))\n            )\n        else:\n            padding_bytes = bytes()\n\n        self.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\n            deploy_code_bytes\n        )\n\n        super().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.__init__","title":"<code>__init__(*, deploy_code, initcode_length=None, padding_byte=0, name=None)</code>","text":"<p>Generate legacy initcode that inits a contract with the specified code. The initcode can be padded to a specified length for testing purposes.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __init__(\n    self,\n    *,\n    deploy_code: str | bytes | Code,\n    initcode_length: Optional[int] = None,\n    padding_byte: int = 0x00,\n    name: Optional[str] = None,\n):\n\"\"\"\n    Generate legacy initcode that inits a contract with the specified code.\n    The initcode can be padded to a specified length for testing purposes.\n    \"\"\"\n    self.execution_gas = 0\n    self.deploy_code = deploy_code\n    deploy_code_bytes = code_to_bytes(self.deploy_code)\n    code_length = len(deploy_code_bytes)\n\n    initcode = bytearray()\n\n    # PUSH2: length=&lt;bytecode length&gt;\n    initcode.append(0x61)\n    initcode += code_length.to_bytes(length=2, byteorder=\"big\")\n    self.execution_gas += 3\n\n    # PUSH1: offset=0\n    initcode.append(0x60)\n    initcode.append(0x00)\n    self.execution_gas += 3\n\n    # DUP2\n    initcode.append(0x81)\n    self.execution_gas += 3\n\n    # PUSH1: initcode_length=11 (constant)\n    initcode.append(0x60)\n    initcode.append(0x0B)\n    self.execution_gas += 3\n\n    # DUP3\n    initcode.append(0x82)\n    self.execution_gas += 3\n\n    # CODECOPY: destinationOffset=0, offset=0, length\n    initcode.append(0x39)\n    self.execution_gas += (\n        3\n        + (3 * ceiling_division(code_length, 32))\n        + (3 * code_length)\n        + ((code_length * code_length) // 512)\n    )\n\n    # RETURN: offset=0, length\n    initcode.append(0xF3)\n    self.execution_gas += 0\n\n    pre_padding_bytes = bytes(initcode) + deploy_code_bytes\n\n    if initcode_length is not None:\n        if len(pre_padding_bytes) &gt; initcode_length:\n            raise Exception(\"Invalid specified length for initcode\")\n\n        padding_bytes = bytes(\n            [padding_byte] * (initcode_length - len(pre_padding_bytes))\n        )\n    else:\n        padding_bytes = bytes()\n\n    self.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\n        deploy_code_bytes\n    )\n\n    super().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.execution_gas","title":"<code>execution_gas: int = 0</code>  <code>instance-attribute</code>","text":"<p>Gas cost of executing the initcode, without considering deployment gas costs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deploy_code","title":"<code>deploy_code: bytes | str | Code = deploy_code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be deployed by the initcode.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deployment_gas","title":"<code>deployment_gas: int = GAS_PER_DEPLOYED_CODE_BYTE * len(deploy_code_bytes)</code>  <code>instance-attribute</code>","text":"<p>Gas cost of deploying the cost, subtracted after initcode execution,</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.fill_test","title":"<code>fill_test(t8n, b11r, test_spec, fork, engine, spec, eips=None)</code>","text":"<p>Fills fixtures for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/fill.py</code> <pre><code>def fill_test(\n    t8n: TransitionTool,\n    b11r: BlockBuilder,\n    test_spec: BaseTest,\n    fork: Fork,\n    engine: str,\n    spec: ReferenceSpec | None,\n    eips: Optional[List[int]] = None,\n) -&gt; Fixture:\n\"\"\"\n    Fills fixtures for the specified fork.\n    \"\"\"\n    t8n.reset_traces()\n\n    genesis_rlp, genesis = test_spec.make_genesis(b11r, t8n, fork)\n\n    (blocks, head, alloc) = test_spec.make_blocks(\n        b11r,\n        t8n,\n        genesis,\n        fork,\n        eips=eips,\n    )\n\n    fork_name = fork.name()\n    fixture = Fixture(\n        blocks=blocks,\n        genesis=genesis,\n        genesis_rlp=genesis_rlp,\n        head=head,\n        fork=\"+\".join([fork_name] + [str(eip) for eip in eips])\n        if eips is not None\n        else fork_name,\n        pre_state=copy(test_spec.pre),\n        post_state=alloc_to_accounts(alloc),\n        seal_engine=engine,\n        name=test_spec.tag,\n    )\n    fixture.fill_info(t8n, b11r, spec)\n\n    return fixture\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Yul","title":"<code>Yul</code>","text":"<p>         Bases: <code>Code</code></p> <p>Yul compiler. Compiles Yul source code into bytecode.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>class Yul(Code):\n\"\"\"\n    Yul compiler.\n    Compiles Yul source code into bytecode.\n    \"\"\"\n\n    source: str\n    compiled: Optional[bytes] = None\n\n    def __init__(self, source: str):\n        self.source = source\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Assembles using `solc --assemble`.\n        \"\"\"\n        if not self.compiled:\n            result = run(\n                SOLC_ARGS,\n                input=str.encode(self.source),\n                stdout=PIPE,\n                stderr=PIPE,\n            )\n\n            if result.returncode != 0:\n                stderr_lines = result.stderr.decode().split(\"\\n\")\n                stderr_message = \"\\n\".join(\n                    line.strip() for line in stderr_lines\n                )\n                raise Exception(\n                    f\"failed to compile yul source:\\n{stderr_message[7:]}\"\n                )\n\n            lines = result.stdout.decode().split(\"\\n\")\n\n            hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n            self.compiled = bytes.fromhex(hex_str)\n        return self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.yul.Yul.assemble","title":"<code>assemble()</code>","text":"<p>Assembles using <code>solc --assemble</code>.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assembles using `solc --assemble`.\n    \"\"\"\n    if not self.compiled:\n        result = run(\n            SOLC_ARGS,\n            input=str.encode(self.source),\n            stdout=PIPE,\n            stderr=PIPE,\n        )\n\n        if result.returncode != 0:\n            stderr_lines = result.stderr.decode().split(\"\\n\")\n            stderr_message = \"\\n\".join(\n                line.strip() for line in stderr_lines\n            )\n            raise Exception(\n                f\"failed to compile yul source:\\n{stderr_message[7:]}\"\n            )\n\n        lines = result.stdout.decode().split(\"\\n\")\n\n        hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n        self.compiled = bytes.fromhex(hex_str)\n    return self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create_address","title":"<code>compute_create_address(address, nonce)</code>","text":"<p>Compute address of the resulting contract created using a transaction or the <code>CREATE</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create_address(address: str | int, nonce: int) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using a transaction\n    or the `CREATE` opcode.\n    \"\"\"\n    if type(address) is str:\n        if address.startswith(\"0x\"):\n            address = address[2:]\n        address_bytes = bytes.fromhex(address)\n    elif type(address) is int:\n        address_bytes = address.to_bytes(length=20, byteorder=\"big\")\n    if nonce == 0:\n        nonce_bytes = bytes()\n    else:\n        nonce_bytes = nonce.to_bytes(length=1, byteorder=\"big\")\n    hash = keccak256(encode([address_bytes, nonce_bytes]))\n    return \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode","title":"<code>Opcode</code>","text":"<p>         Bases: <code>bytes</code></p> <p>Represents a single Opcode instruction in the EVM, with extra metadata useful to parametrize tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode--parameters","title":"Parameters","text":"<ul> <li>popped_stack_items: number of items the opcode pops from the stack</li> <li>pushed_stack_items: number of items the opcode pushes to the stack</li> <li>min_stack_height: minimum stack height required by the opcode</li> <li>data_portion_length: number of bytes after the opcode in the bytecode     that represent data</li> </ul> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcode(bytes):\n\"\"\"\n    Represents a single Opcode instruction in the EVM, with extra\n    metadata useful to parametrize tests.\n\n    Parameters\n    ----------\n    - popped_stack_items: number of items the opcode pops from the stack\n    - pushed_stack_items: number of items the opcode pushes to the stack\n    - min_stack_height: minimum stack height required by the opcode\n    - data_portion_length: number of bytes after the opcode in the bytecode\n        that represent data\n    \"\"\"\n\n    popped_stack_items: int\n    pushed_stack_items: int\n    min_stack_height: int\n    data_portion_length: int\n\n    def __new__(\n        cls,\n        opcode_or_byte: Union[int, \"Opcode\"],\n        *,\n        popped_stack_items: int = 0,\n        pushed_stack_items: int = 0,\n        min_stack_height: int = 0,\n        data_portion_length: int = 0\n    ):\n\"\"\"\n        Creates a new opcode instance.\n        \"\"\"\n        if type(opcode_or_byte) is Opcode:\n            # Required because Enum class calls the base class with the\n            # instantiated object as parameter.\n            return opcode_or_byte\n        elif isinstance(opcode_or_byte, int):\n            obj = super().__new__(cls, [opcode_or_byte])\n            obj.popped_stack_items = popped_stack_items\n            obj.pushed_stack_items = pushed_stack_items\n            obj.min_stack_height = min_stack_height\n            obj.data_portion_length = data_portion_length\n            return obj\n\n    def __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n        Makes all opcode instances callable to return formatted bytecode,\n        which constitutes a data portion, that is located after the opcode\n        byte, and pre-opcode bytecode, which is normally used to set up the\n        stack.\n\n        This useful to automatically format, e.g., push opcodes and their\n        data sections as `Opcodes.PUSH1(0x00)`.\n\n        Data sign is automatically detected but for this reason the range\n        of the input must be:\n        `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n        where:\n        `data_portion_bits == data_portion_length * 8`\n\n        For the stack, the arguments are set up in the opposite order they are\n        given, so the first argument is the last item pushed to the stack.\n\n        The resulting stack arrangement does not take into account opcode stack\n        element consumption, so the stack height is not guaranteed to be\n        correct and the user must take this into consideration.\n\n        Integers can also be used as stack elements, in which case they are\n        automatically converted to PUSH operations, and negative numbers always\n        use a PUSH32 operation.\n\n\n        \"\"\"\n        args: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\n        pre_opcode_bytecode = bytes()\n        data_portion = bytes()\n\n        if self.data_portion_length &gt; 0:\n            # For opcodes with a data portion, the first argument is the data\n            # and the rest of the arguments form the stack.\n            if len(args) == 0:\n                raise ValueError(\n                    \"Opcode with data portion requires at least one argument\"\n                )\n            data = args.pop(0)\n            if isinstance(data, bytes):\n                data_portion = data\n            elif isinstance(data, int):\n                signed = data &lt; 0\n                data_portion = data.to_bytes(\n                    length=self.data_portion_length,\n                    byteorder=\"big\",\n                    signed=signed,\n                )\n            else:\n                raise TypeError(\n                    \"Opcode data portion must be either an int or a bytes\"\n                )\n\n        # The rest of the arguments conform the stack.\n        while len(args) &gt; 0:\n            data = args.pop()\n            if isinstance(data, bytes):\n                pre_opcode_bytecode += data\n            elif isinstance(data, int):\n                # We are going to push a constant to the stack.\n                signed = data &lt; 0\n                data_size = _get_int_size(data)\n                if data_size &gt; 32:\n                    raise ValueError(\n                        \"Opcode stack data must be less than 32 bytes\"\n                    )\n                elif data_size == 0:\n                    # Pushing 0 is done with the PUSH1 opcode for compatibility\n                    # reasons.\n                    data_size = 1\n\n                pre_opcode_bytecode += _push_opcodes_byte_list[data_size]\n                pre_opcode_bytecode += data.to_bytes(\n                    length=data_size,\n                    byteorder=\"big\",\n                    signed=signed,\n                )\n\n            else:\n                raise TypeError(\n                    \"Opcode stack data must be either an int or a bytes\"\n                )\n\n        return pre_opcode_bytecode + self + data_portion\n\n    def __len__(self) -&gt; int:\n\"\"\"\n        Returns the total bytecode length of the opcode, taking into account\n        its data portion.\n        \"\"\"\n        return self.data_portion_length + 1\n\n    def int(self) -&gt; int:\n\"\"\"\n        Returns the integer representation of the opcode.\n        \"\"\"\n        return int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__new__","title":"<code>__new__(opcode_or_byte, *, popped_stack_items=0, pushed_stack_items=0, min_stack_height=0, data_portion_length=0)</code>","text":"<p>Creates a new opcode instance.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __new__(\n    cls,\n    opcode_or_byte: Union[int, \"Opcode\"],\n    *,\n    popped_stack_items: int = 0,\n    pushed_stack_items: int = 0,\n    min_stack_height: int = 0,\n    data_portion_length: int = 0\n):\n\"\"\"\n    Creates a new opcode instance.\n    \"\"\"\n    if type(opcode_or_byte) is Opcode:\n        # Required because Enum class calls the base class with the\n        # instantiated object as parameter.\n        return opcode_or_byte\n    elif isinstance(opcode_or_byte, int):\n        obj = super().__new__(cls, [opcode_or_byte])\n        obj.popped_stack_items = popped_stack_items\n        obj.pushed_stack_items = pushed_stack_items\n        obj.min_stack_height = min_stack_height\n        obj.data_portion_length = data_portion_length\n        return obj\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__call__","title":"<code>__call__(*args_t)</code>","text":"<p>Makes all opcode instances callable to return formatted bytecode, which constitutes a data portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally used to set up the stack.</p> <p>This useful to automatically format, e.g., push opcodes and their data sections as <code>Opcodes.PUSH1(0x00)</code>.</p> <p>Data sign is automatically detected but for this reason the range of the input must be: <code>[-2^(data_portion_bits-1), 2^(data_portion_bits)]</code> where: <code>data_portion_bits == data_portion_length * 8</code></p> <p>For the stack, the arguments are set up in the opposite order they are given, so the first argument is the last item pushed to the stack.</p> <p>The resulting stack arrangement does not take into account opcode stack element consumption, so the stack height is not guaranteed to be correct and the user must take this into consideration.</p> <p>Integers can also be used as stack elements, in which case they are automatically converted to PUSH operations, and negative numbers always use a PUSH32 operation.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n    Makes all opcode instances callable to return formatted bytecode,\n    which constitutes a data portion, that is located after the opcode\n    byte, and pre-opcode bytecode, which is normally used to set up the\n    stack.\n\n    This useful to automatically format, e.g., push opcodes and their\n    data sections as `Opcodes.PUSH1(0x00)`.\n\n    Data sign is automatically detected but for this reason the range\n    of the input must be:\n    `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n    where:\n    `data_portion_bits == data_portion_length * 8`\n\n    For the stack, the arguments are set up in the opposite order they are\n    given, so the first argument is the last item pushed to the stack.\n\n    The resulting stack arrangement does not take into account opcode stack\n    element consumption, so the stack height is not guaranteed to be\n    correct and the user must take this into consideration.\n\n    Integers can also be used as stack elements, in which case they are\n    automatically converted to PUSH operations, and negative numbers always\n    use a PUSH32 operation.\n\n\n    \"\"\"\n    args: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\n    pre_opcode_bytecode = bytes()\n    data_portion = bytes()\n\n    if self.data_portion_length &gt; 0:\n        # For opcodes with a data portion, the first argument is the data\n        # and the rest of the arguments form the stack.\n        if len(args) == 0:\n            raise ValueError(\n                \"Opcode with data portion requires at least one argument\"\n            )\n        data = args.pop(0)\n        if isinstance(data, bytes):\n            data_portion = data\n        elif isinstance(data, int):\n            signed = data &lt; 0\n            data_portion = data.to_bytes(\n                length=self.data_portion_length,\n                byteorder=\"big\",\n                signed=signed,\n            )\n        else:\n            raise TypeError(\n                \"Opcode data portion must be either an int or a bytes\"\n            )\n\n    # The rest of the arguments conform the stack.\n    while len(args) &gt; 0:\n        data = args.pop()\n        if isinstance(data, bytes):\n            pre_opcode_bytecode += data\n        elif isinstance(data, int):\n            # We are going to push a constant to the stack.\n            signed = data &lt; 0\n            data_size = _get_int_size(data)\n            if data_size &gt; 32:\n                raise ValueError(\n                    \"Opcode stack data must be less than 32 bytes\"\n                )\n            elif data_size == 0:\n                # Pushing 0 is done with the PUSH1 opcode for compatibility\n                # reasons.\n                data_size = 1\n\n            pre_opcode_bytecode += _push_opcodes_byte_list[data_size]\n            pre_opcode_bytecode += data.to_bytes(\n                length=data_size,\n                byteorder=\"big\",\n                signed=signed,\n            )\n\n        else:\n            raise TypeError(\n                \"Opcode stack data must be either an int or a bytes\"\n            )\n\n    return pre_opcode_bytecode + self + data_portion\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total bytecode length of the opcode, taking into account its data portion.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Returns the total bytecode length of the opcode, taking into account\n    its data portion.\n    \"\"\"\n    return self.data_portion_length + 1\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.int","title":"<code>int()</code>","text":"<p>Returns the integer representation of the opcode.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def int(self) -&gt; int:\n\"\"\"\n    Returns the integer representation of the opcode.\n    \"\"\"\n    return int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec","title":"<code>ReferenceSpec</code>","text":"<p>Reference Specification Description Abstract Class.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>class ReferenceSpec:\n\"\"\"\n    Reference Specification Description Abstract Class.\n    \"\"\"\n\n    @abstractmethod\n    def name(self) -&gt; str:\n\"\"\"\n        Returns the name of the spec.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def has_known_version(self) -&gt; bool:\n\"\"\"\n        Returns true if the reference spec object is hard-coded with a latest\n        known version.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def known_version(self) -&gt; str:\n\"\"\"\n        Returns the latest known version in the reference.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def latest_version(self) -&gt; str:\n\"\"\"\n        Returns a digest that points to the latest version of the spec.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_outdated(self) -&gt; bool:\n\"\"\"\n        Checks whether the reference specification has been updated since the\n        test was last updated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def write_info(self, info: Dict[str, str]):\n\"\"\"\n        Writes info about the reference specification used into the output\n        fixture.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n        Checks whether the module's dict contains required reference spec\n        information.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n        Parses the module's dict into a reference spec.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Returns the name of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n\"\"\"\n    Returns the name of the spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.has_known_version","title":"<code>has_known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns true if the reference spec object is hard-coded with a latest known version.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef has_known_version(self) -&gt; bool:\n\"\"\"\n    Returns true if the reference spec object is hard-coded with a latest\n    known version.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.known_version","title":"<code>known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns the latest known version in the reference.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef known_version(self) -&gt; str:\n\"\"\"\n    Returns the latest known version in the reference.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.latest_version","title":"<code>latest_version()</code>  <code>abstractmethod</code>","text":"<p>Returns a digest that points to the latest version of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef latest_version(self) -&gt; str:\n\"\"\"\n    Returns a digest that points to the latest version of the spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.is_outdated","title":"<code>is_outdated()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the reference specification has been updated since the test was last updated.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef is_outdated(self) -&gt; bool:\n\"\"\"\n    Checks whether the reference specification has been updated since the\n    test was last updated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.write_info","title":"<code>write_info(info)</code>  <code>abstractmethod</code>","text":"<p>Writes info about the reference specification used into the output fixture.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef write_info(self, info: Dict[str, str]):\n\"\"\"\n    Writes info about the reference specification used into the output\n    fixture.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parseable_from_module","title":"<code>parseable_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Checks whether the module's dict contains required reference spec information.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n    Checks whether the module's dict contains required reference spec\n    information.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parse_from_module","title":"<code>parse_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Parses the module's dict into a reference spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n    Parses the module's dict into a reference spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest","title":"<code>StateTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests transactions over the period of a single block.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass StateTest(BaseTest):\n\"\"\"\n    Filler type that tests transactions over the period of a single block.\n    \"\"\"\n\n    env: Environment\n    pre: Mapping[str, Account]\n    post: Mapping[str, Account]\n    txs: List[Transaction]\n    tag: str = \"\"\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\n        return \"state_test\"\n\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\n        env = self.env.set_fork_requirements(fork)\n\n        genesis = FixtureHeader(\n            parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            coinbase=\"0x0000000000000000000000000000000000000000\",\n            state_root=t8n.calc_state_root(\n                to_json(self.pre),\n                fork,\n            ),\n            transactions_root=EmptyTrieRoot,\n            receipt_root=EmptyTrieRoot,\n            bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=env.number - 1,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=\"0x00\",\n            mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            nonce=\"0x0000000000000000\",\n            base_fee=env.base_fee,\n            excess_data_gas=env.excess_data_gas,\n            withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n            if env.withdrawals is not None\n            else None,\n        )\n\n        (genesis_rlp, genesis.hash) = b11r.build(\n            header=genesis.to_geth_dict(),\n            txs=\"\",\n            ommers=[],\n            withdrawals=env.withdrawals,\n        )\n        return genesis_rlp, genesis\n\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block from the state test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\n        env = self.env.apply_new_parent(genesis)\n        env = env.set_fork_requirements(fork)\n\n        (alloc, result, txs_rlp) = t8n.evaluate(\n            alloc=to_json(self.pre),\n            txs=to_json(self.txs),\n            env=to_json(env),\n            fork=fork,\n            chain_id=chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            eips=eips,\n        )\n\n        rejected_txs = verify_transactions(self.txs, result)\n        if len(rejected_txs) &gt; 0:\n            raise Exception(\n                \"one or more transactions in `StateTest` are \"\n                + \"intrinsically invalid, which are not allowed. \"\n                + \"Use `BlockchainTest` to verify rejection of blocks \"\n                + \"that include invalid transactions.\"\n            )\n\n        try:\n            verify_post_alloc(self.post, alloc)\n        except Exception as e:\n            print_traces(traces=t8n.get_traces())\n            raise e\n\n        header = FixtureHeader.from_dict(\n            result\n            | {\n                \"parentHash\": genesis.hash,\n                \"miner\": env.coinbase,\n                \"transactionsRoot\": result.get(\"txRoot\"),\n                \"difficulty\": str_or_none(\n                    env.difficulty, result.get(\"currentDifficulty\")\n                ),\n                \"number\": str(env.number),\n                \"gasLimit\": str(env.gas_limit),\n                \"timestamp\": str(env.timestamp),\n                \"extraData\": \"0x00\",\n                \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                \"nonce\": \"0x0000000000000000\",\n                \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n            }\n        )\n\n        block, head = b11r.build(\n            header=header.to_geth_dict(),\n            txs=txs_rlp,\n            ommers=[],\n            withdrawals=to_json_or_none(env.withdrawals),\n        )\n        header.hash = head\n\n        return (\n            [\n                FixtureBlock(\n                    rlp=block,\n                    block_header=header,\n                    txs=self.txs if self.txs is not None else [],\n                    ommers=[],\n                    withdrawals=env.withdrawals,\n                )\n            ],\n            head,\n            alloc,\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\n    return \"state_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\n    env = self.env.set_fork_requirements(fork)\n\n    genesis = FixtureHeader(\n        parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n        coinbase=\"0x0000000000000000000000000000000000000000\",\n        state_root=t8n.calc_state_root(\n            to_json(self.pre),\n            fork,\n        ),\n        transactions_root=EmptyTrieRoot,\n        receipt_root=EmptyTrieRoot,\n        bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=env.number - 1,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=\"0x00\",\n        mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        nonce=\"0x0000000000000000\",\n        base_fee=env.base_fee,\n        excess_data_gas=env.excess_data_gas,\n        withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n        if env.withdrawals is not None\n        else None,\n    )\n\n    (genesis_rlp, genesis.hash) = b11r.build(\n        header=genesis.to_geth_dict(),\n        txs=\"\",\n        ommers=[],\n        withdrawals=env.withdrawals,\n    )\n    return genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block from the state test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block from the state test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\n    env = self.env.apply_new_parent(genesis)\n    env = env.set_fork_requirements(fork)\n\n    (alloc, result, txs_rlp) = t8n.evaluate(\n        alloc=to_json(self.pre),\n        txs=to_json(self.txs),\n        env=to_json(env),\n        fork=fork,\n        chain_id=chain_id,\n        reward=fork.get_reward(env.number, env.timestamp),\n        eips=eips,\n    )\n\n    rejected_txs = verify_transactions(self.txs, result)\n    if len(rejected_txs) &gt; 0:\n        raise Exception(\n            \"one or more transactions in `StateTest` are \"\n            + \"intrinsically invalid, which are not allowed. \"\n            + \"Use `BlockchainTest` to verify rejection of blocks \"\n            + \"that include invalid transactions.\"\n        )\n\n    try:\n        verify_post_alloc(self.post, alloc)\n    except Exception as e:\n        print_traces(traces=t8n.get_traces())\n        raise e\n\n    header = FixtureHeader.from_dict(\n        result\n        | {\n            \"parentHash\": genesis.hash,\n            \"miner\": env.coinbase,\n            \"transactionsRoot\": result.get(\"txRoot\"),\n            \"difficulty\": str_or_none(\n                env.difficulty, result.get(\"currentDifficulty\")\n            ),\n            \"number\": str(env.number),\n            \"gasLimit\": str(env.gas_limit),\n            \"timestamp\": str(env.timestamp),\n            \"extraData\": \"0x00\",\n            \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            \"nonce\": \"0x0000000000000000\",\n            \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n            \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n        }\n    )\n\n    block, head = b11r.build(\n        header=header.to_geth_dict(),\n        txs=txs_rlp,\n        ommers=[],\n        withdrawals=to_json_or_none(env.withdrawals),\n    )\n    header.hash = head\n\n    return (\n        [\n            FixtureBlock(\n                rlp=block,\n                block_header=header,\n                txs=self.txs if self.txs is not None else [],\n                ommers=[],\n                withdrawals=env.withdrawals,\n            )\n        ],\n        head,\n        alloc,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest","title":"<code>BlockchainTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests multiple blocks (valid or invalid) in a chain.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass BlockchainTest(BaseTest):\n\"\"\"\n    Filler type that tests multiple blocks (valid or invalid) in a chain.\n    \"\"\"\n\n    pre: Mapping[str, Account]\n    post: Mapping[str, Account]\n    blocks: List[Block]\n    genesis_environment: Environment = Environment()\n    tag: str = \"\"\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\n        return \"blockchain_test\"\n\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\n        env = self.genesis_environment.set_fork_requirements(fork)\n\n        genesis = FixtureHeader(\n            parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            coinbase=\"0x0000000000000000000000000000000000000000\",\n            state_root=t8n.calc_state_root(\n                to_json(self.pre),\n                fork,\n            ),\n            transactions_root=EmptyTrieRoot,\n            receipt_root=EmptyTrieRoot,\n            bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=0,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=\"0x00\",\n            mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            nonce=\"0x0000000000000000\",\n            base_fee=env.base_fee,\n            excess_data_gas=env.excess_data_gas,\n            withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n            if env.withdrawals is not None\n            else None,\n        )\n\n        (genesis_rlp, genesis.hash) = b11r.build(\n            header=genesis.to_geth_dict(),\n            txs=\"\",\n            ommers=[],\n            withdrawals=env.withdrawals,\n        )\n        return genesis_rlp, genesis\n\n    def make_block(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n        block: Block,\n        previous_env: Environment,\n        previous_alloc: Dict[str, Any],\n        previous_head: str,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n        Produces a block based on the previous environment and allocation.\n        If the block is an invalid block, the environment and allocation\n        returned are the same as passed as parameters.\n        Raises exception on invalid test behavior.\n\n        Returns\n        -------\n            FixtureBlock: Block to be appended to the fixture.\n            Environment: Environment for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                environment as the one passed as parameter.\n            Dict[str, Any]: Allocation for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                allocation as the one passed as parameter.\n            str: Hash of the head of the chain, only updated if the produced\n                block is not invalid.\n\n        \"\"\"\n        if block.rlp and block.exception is not None:\n            raise Exception(\n                \"test correctness: post-state cannot be verified if the \"\n                + \"block's rlp is supplied and the block is not supposed \"\n                + \"to produce an exception\"\n            )\n\n        if block.rlp is None:\n            # This is the most common case, the RLP needs to be constructed\n            # based on the transactions to be included in the block.\n            # Set the environment according to the block to execute.\n            env = block.set_environment(previous_env)\n            env = env.set_fork_requirements(fork)\n\n            (next_alloc, result, txs_rlp) = t8n.evaluate(\n                alloc=previous_alloc,\n                txs=to_json_or_none(block.txs),\n                env=to_json(env),\n                fork=fork,\n                chain_id=chain_id,\n                reward=fork.get_reward(env.number, env.timestamp),\n                eips=eips,\n            )\n            try:\n                rejected_txs = verify_transactions(block.txs, result)\n            except Exception as e:\n                print_traces(t8n.get_traces())\n                pprint(result)\n                pprint(previous_alloc)\n                pprint(next_alloc)\n                raise e\n\n            if len(rejected_txs) &gt; 0 and block.exception is None:\n                print_traces(t8n.get_traces())\n                raise Exception(\n                    \"one or more transactions in `BlockchainTest` are \"\n                    + \"intrinsically invalid, but the block was not expected \"\n                    + \"to be invalid. Please verify whether the transaction \"\n                    + \"was indeed expected to fail and add the proper \"\n                    + \"`block.exception`\"\n                )\n\n            header = FixtureHeader.from_dict(\n                result\n                | {\n                    \"parentHash\": env.parent_hash(),\n                    \"miner\": env.coinbase,\n                    \"transactionsRoot\": result.get(\"txRoot\"),\n                    \"difficulty\": str_or_none(\n                        result.get(\"currentDifficulty\"), \"0\"\n                    ),\n                    \"number\": str(env.number),\n                    \"gasLimit\": str(env.gas_limit),\n                    \"timestamp\": str(env.timestamp),\n                    \"extraData\": block.extra_data\n                    if block.extra_data is not None\n                    and len(block.extra_data) != 0\n                    else \"0x\",\n                    \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                    \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                    \"nonce\": \"0x0000000000000000\",\n                    \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                    \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n                }\n            )\n\n            assert len(header.state_root) == 66\n\n            if block.rlp_modifier is not None:\n                # Modify any parameter specified in the `rlp_modifier` after\n                # transition tool processing.\n                header = header.join(block.rlp_modifier)\n\n            rlp, header.hash = b11r.build(\n                header=header.to_geth_dict(),\n                txs=txs_rlp,\n                ommers=[],\n                withdrawals=to_json_or_none(env.withdrawals),\n            )\n\n            if block.exception is None:\n                # Return environment and allocation of the following block\n                return (\n                    FixtureBlock(\n                        rlp=rlp,\n                        block_header=header,\n                        block_number=header.number,\n                        txs=block.txs if block.txs is not None else [],\n                        ommers=[],\n                        withdrawals=env.withdrawals,\n                    ),\n                    env.apply_new_parent(header),\n                    next_alloc,\n                    header.hash,\n                )\n            else:\n                return (\n                    FixtureBlock(\n                        rlp=rlp,\n                        expected_exception=block.exception,\n                        block_number=header.number,\n                    ),\n                    previous_env,\n                    previous_alloc,\n                    previous_head,\n                )\n        else:\n            return (\n                FixtureBlock(\n                    rlp=block.rlp,\n                    expected_exception=block.exception,\n                ),\n                previous_env,\n                previous_alloc,\n                previous_head,\n            )\n\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block list from the blockchain test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\n        alloc = to_json(self.pre)\n        env = Environment.from_parent_header(genesis)\n        blocks: List[FixtureBlock] = []\n        head = (\n            genesis.hash\n            if genesis.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        )\n        for block in self.blocks:\n            fixture_block, env, alloc, head = self.make_block(\n                b11r=b11r,\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                previous_head=head,\n                chain_id=chain_id,\n                eips=eips,\n            )\n            blocks.append(fixture_block)\n\n        try:\n            verify_post_alloc(self.post, alloc)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n        return (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\n    return \"blockchain_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\n    env = self.genesis_environment.set_fork_requirements(fork)\n\n    genesis = FixtureHeader(\n        parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n        coinbase=\"0x0000000000000000000000000000000000000000\",\n        state_root=t8n.calc_state_root(\n            to_json(self.pre),\n            fork,\n        ),\n        transactions_root=EmptyTrieRoot,\n        receipt_root=EmptyTrieRoot,\n        bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=0,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=\"0x00\",\n        mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        nonce=\"0x0000000000000000\",\n        base_fee=env.base_fee,\n        excess_data_gas=env.excess_data_gas,\n        withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n        if env.withdrawals is not None\n        else None,\n    )\n\n    (genesis_rlp, genesis.hash) = b11r.build(\n        header=genesis.to_geth_dict(),\n        txs=\"\",\n        ommers=[],\n        withdrawals=env.withdrawals,\n    )\n    return genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block","title":"<code>make_block(b11r, t8n, fork, block, previous_env, previous_alloc, previous_head, chain_id=1, eips=None)</code>","text":"<p>Produces a block based on the previous environment and allocation. If the block is an invalid block, the environment and allocation returned are the same as passed as parameters. Raises exception on invalid test behavior.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block--returns","title":"Returns","text":"<pre><code>FixtureBlock: Block to be appended to the fixture.\nEnvironment: Environment for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    environment as the one passed as parameter.\nDict[str, Any]: Allocation for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    allocation as the one passed as parameter.\nstr: Hash of the head of the chain, only updated if the produced\n    block is not invalid.\n</code></pre> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_block(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n    block: Block,\n    previous_env: Environment,\n    previous_alloc: Dict[str, Any],\n    previous_head: str,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n    Produces a block based on the previous environment and allocation.\n    If the block is an invalid block, the environment and allocation\n    returned are the same as passed as parameters.\n    Raises exception on invalid test behavior.\n\n    Returns\n    -------\n        FixtureBlock: Block to be appended to the fixture.\n        Environment: Environment for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            environment as the one passed as parameter.\n        Dict[str, Any]: Allocation for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            allocation as the one passed as parameter.\n        str: Hash of the head of the chain, only updated if the produced\n            block is not invalid.\n\n    \"\"\"\n    if block.rlp and block.exception is not None:\n        raise Exception(\n            \"test correctness: post-state cannot be verified if the \"\n            + \"block's rlp is supplied and the block is not supposed \"\n            + \"to produce an exception\"\n        )\n\n    if block.rlp is None:\n        # This is the most common case, the RLP needs to be constructed\n        # based on the transactions to be included in the block.\n        # Set the environment according to the block to execute.\n        env = block.set_environment(previous_env)\n        env = env.set_fork_requirements(fork)\n\n        (next_alloc, result, txs_rlp) = t8n.evaluate(\n            alloc=previous_alloc,\n            txs=to_json_or_none(block.txs),\n            env=to_json(env),\n            fork=fork,\n            chain_id=chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            eips=eips,\n        )\n        try:\n            rejected_txs = verify_transactions(block.txs, result)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(result)\n            pprint(previous_alloc)\n            pprint(next_alloc)\n            raise e\n\n        if len(rejected_txs) &gt; 0 and block.exception is None:\n            print_traces(t8n.get_traces())\n            raise Exception(\n                \"one or more transactions in `BlockchainTest` are \"\n                + \"intrinsically invalid, but the block was not expected \"\n                + \"to be invalid. Please verify whether the transaction \"\n                + \"was indeed expected to fail and add the proper \"\n                + \"`block.exception`\"\n            )\n\n        header = FixtureHeader.from_dict(\n            result\n            | {\n                \"parentHash\": env.parent_hash(),\n                \"miner\": env.coinbase,\n                \"transactionsRoot\": result.get(\"txRoot\"),\n                \"difficulty\": str_or_none(\n                    result.get(\"currentDifficulty\"), \"0\"\n                ),\n                \"number\": str(env.number),\n                \"gasLimit\": str(env.gas_limit),\n                \"timestamp\": str(env.timestamp),\n                \"extraData\": block.extra_data\n                if block.extra_data is not None\n                and len(block.extra_data) != 0\n                else \"0x\",\n                \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                \"nonce\": \"0x0000000000000000\",\n                \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n            }\n        )\n\n        assert len(header.state_root) == 66\n\n        if block.rlp_modifier is not None:\n            # Modify any parameter specified in the `rlp_modifier` after\n            # transition tool processing.\n            header = header.join(block.rlp_modifier)\n\n        rlp, header.hash = b11r.build(\n            header=header.to_geth_dict(),\n            txs=txs_rlp,\n            ommers=[],\n            withdrawals=to_json_or_none(env.withdrawals),\n        )\n\n        if block.exception is None:\n            # Return environment and allocation of the following block\n            return (\n                FixtureBlock(\n                    rlp=rlp,\n                    block_header=header,\n                    block_number=header.number,\n                    txs=block.txs if block.txs is not None else [],\n                    ommers=[],\n                    withdrawals=env.withdrawals,\n                ),\n                env.apply_new_parent(header),\n                next_alloc,\n                header.hash,\n            )\n        else:\n            return (\n                FixtureBlock(\n                    rlp=rlp,\n                    expected_exception=block.exception,\n                    block_number=header.number,\n                ),\n                previous_env,\n                previous_alloc,\n                previous_head,\n            )\n    else:\n        return (\n            FixtureBlock(\n                rlp=block.rlp,\n                expected_exception=block.exception,\n            ),\n            previous_env,\n            previous_alloc,\n            previous_head,\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block list from the blockchain test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block list from the blockchain test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\n    alloc = to_json(self.pre)\n    env = Environment.from_parent_header(genesis)\n    blocks: List[FixtureBlock] = []\n    head = (\n        genesis.hash\n        if genesis.hash is not None\n        else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    )\n    for block in self.blocks:\n        fixture_block, env, alloc, head = self.make_block(\n            b11r=b11r,\n            t8n=t8n,\n            fork=fork,\n            block=block,\n            previous_env=env,\n            previous_alloc=alloc,\n            previous_head=head,\n            chain_id=chain_id,\n            eips=eips,\n        )\n        blocks.append(fixture_block)\n\n    try:\n        verify_post_alloc(self.post, alloc)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n\n    return (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create2_address","title":"<code>compute_create2_address(address, salt, initcode)</code>","text":"<p>Compute address of the resulting contract created using the <code>CREATE2</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create2_address(\n    address: str | int, salt: int, initcode: bytes\n) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using the `CREATE2`\n    opcode.\n    \"\"\"\n    ff = bytes([0xFF])\n    if type(address) is str:\n        if address.startswith(\"0x\"):\n            address = address[2:]\n        address_bytes = bytes.fromhex(address)\n    elif type(address) is int:\n        address_bytes = address.to_bytes(length=20, byteorder=\"big\")\n    salt_bytes = salt.to_bytes(length=32, byteorder=\"big\")\n    initcode_hash = keccak256(initcode)\n    hash = keccak256(ff + address_bytes + salt_bytes + initcode_hash)\n    return \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.eip_2028_transaction_data_cost","title":"<code>eip_2028_transaction_data_cost(data)</code>","text":"<p>Calculates the cost of a given data as part of a transaction, based on the costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def eip_2028_transaction_data_cost(data: bytes | str) -&gt; int:\n\"\"\"\n    Calculates the cost of a given data as part of a transaction, based on the\n    costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028\n    \"\"\"\n    if type(data) is str:\n        if data.startswith(\"0x\"):\n            data = data[2:]\n        data = bytes.fromhex(data)\n    cost = 0\n    for b in data:\n        if b == 0:\n            cost += 4\n        else:\n            cost += 16\n    return cost\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from_until","title":"<code>test_from_until(fork_from, fork_until, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from_until(\n    fork_from: Fork,\n    fork_until: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\n    return _filler_decorator(\n        forks=forks_from_until(fork_from, fork_until), eips=eips\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from","title":"<code>test_from(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from(\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\n    return _filler_decorator(forks=forks_from(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_address","title":"<code>to_address(input)</code>","text":"<p>Converts an int or str into proper address 20-byte hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_address(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper address 20-byte hex string.\n    \"\"\"\n    if type(input) is str:\n        # Convert to int\n        input = int(input, 0)\n    if type(input) is int:\n        return \"0x\" + input.to_bytes(20, \"big\").hex()\n    raise Exception(\"invalid type to convert to account address\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest","title":"<code>BaseTest</code>","text":"<p>Represents a base Ethereum test which must return a genesis and a blockchain.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>class BaseTest:\n\"\"\"\n    Represents a base Ethereum test which must return a genesis and a\n    blockchain.\n    \"\"\"\n\n    pre: Mapping[str, Account]\n    tag: str = \"\"\n\n    @abstractmethod\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the test definition.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id: int = 1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Generate the blockchain that must be executed sequentially during test.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Must return the name of the parameter used in pytest to select this\n        spec type as filler for the test.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>  <code>abstractmethod</code>","text":"<p>Create a genesis block from the test definition.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the test definition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Generate the blockchain that must be executed sequentially during test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id: int = 1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Generate the blockchain that must be executed sequentially during test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code> <code>abstractmethod</code>","text":"<p>Must return the name of the parameter used in pytest to select this spec type as filler for the test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@classmethod\n@abstractmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Must return the name of the parameter used in pytest to select this\n    spec type as filler for the test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_only","title":"<code>test_only(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it only for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_only(\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it only for the specified\n    fork.\n    \"\"\"\n    return _filler_decorator(forks=fork_only(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash_bytes","title":"<code>to_hash_bytes(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash_bytes(input: int | str) -&gt; bytes:\n\"\"\"\n    Converts an int or str into proper 32-byte hash.\n    \"\"\"\n    if type(input) is str:\n        # Convert to int\n        input = int(input, 0)\n    if type(input) is int:\n        return input.to_bytes(32, \"big\")\n    raise Exception(\"invalid type to convert to hash\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash","title":"<code>to_hash(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper 32-byte hash hex string.\n    \"\"\"\n    return \"0x\" + to_hash_bytes(input).hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure","title":"<code>CodeGasMeasure</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate bytecode that measures gas usage of a bytecode, taking into account and subtracting any extra overhead gas costs required to execute. By default, the result gas calculation is saved to storage key 0.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeGasMeasure(Code):\n\"\"\"\n    Helper class used to generate bytecode that measures gas usage of a\n    bytecode, taking into account and subtracting any extra overhead gas costs\n    required to execute.\n    By default, the result gas calculation is saved to storage key 0.\n    \"\"\"\n\n    code: bytes | str | Code\n\"\"\"\n    Bytecode to be executed to measure the gas usage.\n    \"\"\"\n    overhead_cost: int = 0\n\"\"\"\n    Extra gas cost to be subtracted from extra operations.\n    \"\"\"\n    extra_stack_items: int = 0\n\"\"\"\n    Extra stack items that remain at the end of the execution.\n    To be considered when subtracting the value of the previous GAS operation,\n    and to be popped at the end of the execution.\n    \"\"\"\n    sstore_key: int = 0\n\"\"\"\n    Storage key to save the gas used.\n    \"\"\"\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Assemble the bytecode that measures gas usage.\n        \"\"\"\n        res = bytes()\n        res += bytes(\n            [\n                0x5A,  # GAS\n            ]\n        )\n        res += code_to_bytes(self.code)  # Execute code to measure its gas cost\n        res += bytes(\n            [\n                0x5A,  # GAS\n            ]\n        )\n        # We need to swap and pop for each extra stack item that remained from\n        # the execution of the code\n        res += (\n            bytes(\n                [\n                    0x90,  # SWAP1\n                    0x50,  # POP\n                ]\n            )\n            * self.extra_stack_items\n        )\n        res += bytes(\n            [\n                0x90,  # SWAP1\n                0x03,  # SUB\n                0x60,  # PUSH1\n                self.overhead_cost + 2,  # Overhead cost + GAS opcode price\n                0x90,  # SWAP1\n                0x03,  # SUB\n                0x60,  # PUSH1\n                self.sstore_key,  # -&gt; SSTORE key\n                0x55,  # SSTORE\n                0x00,  # STOP\n            ]\n        )\n        return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.code","title":"<code>code: bytes | str | Code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be executed to measure the gas usage.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.overhead_cost","title":"<code>overhead_cost: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extra gas cost to be subtracted from extra operations.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.extra_stack_items","title":"<code>extra_stack_items: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extra stack items that remain at the end of the execution. To be considered when subtracting the value of the previous GAS operation, and to be popped at the end of the execution.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.sstore_key","title":"<code>sstore_key: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage key to save the gas used.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.assemble","title":"<code>assemble()</code>","text":"<p>Assemble the bytecode that measures gas usage.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assemble the bytecode that measures gas usage.\n    \"\"\"\n    res = bytes()\n    res += bytes(\n        [\n            0x5A,  # GAS\n        ]\n    )\n    res += code_to_bytes(self.code)  # Execute code to measure its gas cost\n    res += bytes(\n        [\n            0x5A,  # GAS\n        ]\n    )\n    # We need to swap and pop for each extra stack item that remained from\n    # the execution of the code\n    res += (\n        bytes(\n            [\n                0x90,  # SWAP1\n                0x50,  # POP\n            ]\n        )\n        * self.extra_stack_items\n    )\n    res += bytes(\n        [\n            0x90,  # SWAP1\n            0x03,  # SUB\n            0x60,  # PUSH1\n            self.overhead_cost + 2,  # Overhead cost + GAS opcode price\n            0x90,  # SWAP1\n            0x03,  # SUB\n            0x60,  # PUSH1\n            self.sstore_key,  # -&gt; SSTORE key\n            0x55,  # SSTORE\n            0x00,  # STOP\n        ]\n    )\n    return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcodes","title":"<code>Opcodes</code>","text":"<p>         Bases: <code>Opcode</code>, <code>Enum</code></p> <p>Enum containing all known opcodes.</p> <p>Contains deprecated and not yet implemented opcodes.</p> <p>This enum is !! NOT !! meant to be iterated over by the tests. Instead, create a list with cherry-picked opcodes from this Enum within the test if iteration is needed.</p> <p>Do !! NOT !! remove or modify existing opcodes from this list.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcodes(Opcode, Enum):\n\"\"\"\n    Enum containing all known opcodes.\n\n    Contains deprecated and not yet implemented opcodes.\n\n    This enum is !! NOT !! meant to be iterated over by the tests. Instead,\n    create a list with cherry-picked opcodes from this Enum within the test\n    if iteration is needed.\n\n    Do !! NOT !! remove or modify existing opcodes from this list.\n    \"\"\"\n\n    STOP = Opcode(0x00)\n    ADD = Opcode(0x01, popped_stack_items=2, pushed_stack_items=1)\n    MUL = Opcode(0x02, popped_stack_items=2, pushed_stack_items=1)\n    SUB = Opcode(0x03, popped_stack_items=2, pushed_stack_items=1)\n    DIV = Opcode(0x04, popped_stack_items=2, pushed_stack_items=1)\n    SDIV = Opcode(0x05, popped_stack_items=2, pushed_stack_items=1)\n    MOD = Opcode(0x06, popped_stack_items=2, pushed_stack_items=1)\n    SMOD = Opcode(0x07, popped_stack_items=2, pushed_stack_items=1)\n    ADDMOD = Opcode(0x08, popped_stack_items=3, pushed_stack_items=1)\n    MULMOD = Opcode(0x09, popped_stack_items=3, pushed_stack_items=1)\n    EXP = Opcode(0x0A, popped_stack_items=2, pushed_stack_items=1)\n    SIGNEXTEND = Opcode(0x0B, popped_stack_items=2, pushed_stack_items=1)\n\n    LT = Opcode(0x10, popped_stack_items=2, pushed_stack_items=1)\n    GT = Opcode(0x11, popped_stack_items=2, pushed_stack_items=1)\n    SLT = Opcode(0x12, popped_stack_items=2, pushed_stack_items=1)\n    SGT = Opcode(0x13, popped_stack_items=2, pushed_stack_items=1)\n    EQ = Opcode(0x14, popped_stack_items=2, pushed_stack_items=1)\n    ISZERO = Opcode(0x15, popped_stack_items=1, pushed_stack_items=1)\n    AND = Opcode(0x16, popped_stack_items=2, pushed_stack_items=1)\n    OR = Opcode(0x17, popped_stack_items=2, pushed_stack_items=1)\n    XOR = Opcode(0x18, popped_stack_items=2, pushed_stack_items=1)\n    NOT = Opcode(0x19, popped_stack_items=1, pushed_stack_items=1)\n    BYTE = Opcode(0x1A, popped_stack_items=2, pushed_stack_items=1)\n    SHL = Opcode(0x1B, popped_stack_items=2, pushed_stack_items=1)\n    SHR = Opcode(0x1C, popped_stack_items=2, pushed_stack_items=1)\n    SAR = Opcode(0x1D, popped_stack_items=2, pushed_stack_items=1)\n\n    SHA3 = Opcode(0x20, popped_stack_items=2, pushed_stack_items=1)\n\n    ADDRESS = Opcode(0x30, pushed_stack_items=1)\n    BALANCE = Opcode(0x31, popped_stack_items=1, pushed_stack_items=1)\n    ORIGIN = Opcode(0x32, pushed_stack_items=1)\n    CALLER = Opcode(0x33, pushed_stack_items=1)\n    CALLVALUE = Opcode(0x34, pushed_stack_items=1)\n    CALLDATALOAD = Opcode(0x35, popped_stack_items=1, pushed_stack_items=1)\n    CALLDATASIZE = Opcode(0x36, pushed_stack_items=1)\n    CALLDATACOPY = Opcode(0x37, popped_stack_items=3)\n    CODESIZE = Opcode(0x38, pushed_stack_items=1)\n    CODECOPY = Opcode(0x39, popped_stack_items=3)\n    GASPRICE = Opcode(0x3A, pushed_stack_items=1)\n    EXTCODESIZE = Opcode(0x3B, popped_stack_items=1, pushed_stack_items=1)\n    EXTCODECOPY = Opcode(0x3C, popped_stack_items=4)\n    RETURNDATASIZE = Opcode(0x3D, pushed_stack_items=1)\n    RETURNDATACOPY = Opcode(0x3E, popped_stack_items=3)\n    EXTCODEHASH = Opcode(0x3F, popped_stack_items=1, pushed_stack_items=1)\n\n    BLOCKHASH = Opcode(0x40, popped_stack_items=1, pushed_stack_items=1)\n    COINBASE = Opcode(0x41, pushed_stack_items=1)\n    TIMESTAMP = Opcode(0x42, pushed_stack_items=1)\n    NUMBER = Opcode(0x43, pushed_stack_items=1)\n    PREVRANDAO = Opcode(0x44, pushed_stack_items=1)\n    GASLIMIT = Opcode(0x45, pushed_stack_items=1)\n    CHAINID = Opcode(0x46, pushed_stack_items=1)\n    SELFBALANCE = Opcode(0x47, pushed_stack_items=1)\n    BASEFEE = Opcode(0x48, pushed_stack_items=1)\n    DATAHASH = Opcode(0x49, popped_stack_items=1, pushed_stack_items=1)\n\n    POP = Opcode(0x50, popped_stack_items=1)\n    MLOAD = Opcode(0x51, popped_stack_items=1, pushed_stack_items=1)\n    MSTORE = Opcode(0x52, popped_stack_items=2)\n    MSTORE8 = Opcode(0x53, popped_stack_items=2)\n    SLOAD = Opcode(0x54, popped_stack_items=1, pushed_stack_items=1)\n    SSTORE = Opcode(0x55, popped_stack_items=2)\n    JUMP = Opcode(0x56, popped_stack_items=1)\n    JUMPI = Opcode(0x57, popped_stack_items=2)\n    PC = Opcode(0x58, pushed_stack_items=1)\n    MSIZE = Opcode(0x59, pushed_stack_items=1)\n    GAS = Opcode(0x5A, pushed_stack_items=1)\n    JUMPDEST = Opcode(0x5B)\n    RJUMP = Opcode(0x5C, data_portion_length=2)\n    RJUMPI = Opcode(0x5D, popped_stack_items=1, data_portion_length=2)\n    CALLF = Opcode(0x5E, data_portion_length=2)\n    RETF = Opcode(0x49)\n\n    PUSH0 = Opcode(0x5F, pushed_stack_items=1)\n    PUSH1 = Opcode(0x60, pushed_stack_items=1, data_portion_length=1)\n    PUSH2 = Opcode(0x61, pushed_stack_items=1, data_portion_length=2)\n    PUSH3 = Opcode(0x62, pushed_stack_items=1, data_portion_length=3)\n    PUSH4 = Opcode(0x63, pushed_stack_items=1, data_portion_length=4)\n    PUSH5 = Opcode(0x64, pushed_stack_items=1, data_portion_length=5)\n    PUSH6 = Opcode(0x65, pushed_stack_items=1, data_portion_length=6)\n    PUSH7 = Opcode(0x66, pushed_stack_items=1, data_portion_length=7)\n    PUSH8 = Opcode(0x67, pushed_stack_items=1, data_portion_length=8)\n    PUSH9 = Opcode(0x68, pushed_stack_items=1, data_portion_length=9)\n    PUSH10 = Opcode(0x69, pushed_stack_items=1, data_portion_length=10)\n    PUSH11 = Opcode(0x6A, pushed_stack_items=1, data_portion_length=11)\n    PUSH12 = Opcode(0x6B, pushed_stack_items=1, data_portion_length=12)\n    PUSH13 = Opcode(0x6C, pushed_stack_items=1, data_portion_length=13)\n    PUSH14 = Opcode(0x6D, pushed_stack_items=1, data_portion_length=14)\n    PUSH15 = Opcode(0x6E, pushed_stack_items=1, data_portion_length=15)\n    PUSH16 = Opcode(0x6F, pushed_stack_items=1, data_portion_length=16)\n    PUSH17 = Opcode(0x70, pushed_stack_items=1, data_portion_length=17)\n    PUSH18 = Opcode(0x71, pushed_stack_items=1, data_portion_length=18)\n    PUSH19 = Opcode(0x72, pushed_stack_items=1, data_portion_length=19)\n    PUSH20 = Opcode(0x73, pushed_stack_items=1, data_portion_length=20)\n    PUSH21 = Opcode(0x74, pushed_stack_items=1, data_portion_length=21)\n    PUSH22 = Opcode(0x75, pushed_stack_items=1, data_portion_length=22)\n    PUSH23 = Opcode(0x76, pushed_stack_items=1, data_portion_length=23)\n    PUSH24 = Opcode(0x77, pushed_stack_items=1, data_portion_length=24)\n    PUSH25 = Opcode(0x78, pushed_stack_items=1, data_portion_length=25)\n    PUSH26 = Opcode(0x79, pushed_stack_items=1, data_portion_length=26)\n    PUSH27 = Opcode(0x7A, pushed_stack_items=1, data_portion_length=27)\n    PUSH28 = Opcode(0x7B, pushed_stack_items=1, data_portion_length=28)\n    PUSH29 = Opcode(0x7C, pushed_stack_items=1, data_portion_length=29)\n    PUSH30 = Opcode(0x7D, pushed_stack_items=1, data_portion_length=30)\n    PUSH31 = Opcode(0x7E, pushed_stack_items=1, data_portion_length=31)\n    PUSH32 = Opcode(0x7F, pushed_stack_items=1, data_portion_length=32)\n\n    DUP1 = Opcode(0x80, pushed_stack_items=1, min_stack_height=1)\n    DUP2 = Opcode(0x81, pushed_stack_items=1, min_stack_height=2)\n    DUP3 = Opcode(0x82, pushed_stack_items=1, min_stack_height=3)\n    DUP4 = Opcode(0x83, pushed_stack_items=1, min_stack_height=4)\n    DUP5 = Opcode(0x84, pushed_stack_items=1, min_stack_height=5)\n    DUP6 = Opcode(0x85, pushed_stack_items=1, min_stack_height=6)\n    DUP7 = Opcode(0x86, pushed_stack_items=1, min_stack_height=7)\n    DUP8 = Opcode(0x87, pushed_stack_items=1, min_stack_height=8)\n    DUP9 = Opcode(0x88, pushed_stack_items=1, min_stack_height=9)\n    DUP10 = Opcode(0x89, pushed_stack_items=1, min_stack_height=10)\n    DUP11 = Opcode(0x8A, pushed_stack_items=1, min_stack_height=11)\n    DUP12 = Opcode(0x8B, pushed_stack_items=1, min_stack_height=12)\n    DUP13 = Opcode(0x8C, pushed_stack_items=1, min_stack_height=13)\n    DUP14 = Opcode(0x8D, pushed_stack_items=1, min_stack_height=14)\n    DUP15 = Opcode(0x8E, pushed_stack_items=1, min_stack_height=15)\n    DUP16 = Opcode(0x8F, pushed_stack_items=1, min_stack_height=16)\n\n    SWAP1 = Opcode(0x90, min_stack_height=2)\n    SWAP2 = Opcode(0x91, min_stack_height=3)\n    SWAP3 = Opcode(0x92, min_stack_height=4)\n    SWAP4 = Opcode(0x93, min_stack_height=5)\n    SWAP5 = Opcode(0x94, min_stack_height=6)\n    SWAP6 = Opcode(0x95, min_stack_height=7)\n    SWAP7 = Opcode(0x96, min_stack_height=8)\n    SWAP8 = Opcode(0x97, min_stack_height=9)\n    SWAP9 = Opcode(0x98, min_stack_height=10)\n    SWAP10 = Opcode(0x99, min_stack_height=11)\n    SWAP11 = Opcode(0x9A, min_stack_height=12)\n    SWAP12 = Opcode(0x9B, min_stack_height=13)\n    SWAP13 = Opcode(0x9C, min_stack_height=14)\n    SWAP14 = Opcode(0x9D, min_stack_height=15)\n    SWAP15 = Opcode(0x9E, min_stack_height=16)\n    SWAP16 = Opcode(0x9F, min_stack_height=17)\n\n    LOG0 = Opcode(0xA0, popped_stack_items=2)\n    LOG1 = Opcode(0xA1, popped_stack_items=3)\n    LOG2 = Opcode(0xA2, popped_stack_items=4)\n    LOG3 = Opcode(0xA3, popped_stack_items=5)\n    LOG4 = Opcode(0xA4, popped_stack_items=6)\n\n    TLOAD = Opcode(0xB3, popped_stack_items=1, pushed_stack_items=1)\n    TSTORE = Opcode(0xB4, popped_stack_items=2)\n\n    CREATE = Opcode(0xF0, popped_stack_items=3, pushed_stack_items=1)\n    CALL = Opcode(0xF1, popped_stack_items=7, pushed_stack_items=1)\n    CALLCODE = Opcode(0xF2, popped_stack_items=7, pushed_stack_items=1)\n    RETURN = Opcode(0xF3, popped_stack_items=2)\n    DELEGATECALL = Opcode(0xF4, popped_stack_items=6, pushed_stack_items=1)\n    CREATE2 = Opcode(0xF5, popped_stack_items=4, pushed_stack_items=1)\n\n    STATICCALL = Opcode(0xFA, popped_stack_items=6, pushed_stack_items=1)\n\n    REVERT = Opcode(0xFD, popped_stack_items=2)\n    INVALID = Opcode(0xFE)\n\n    SELFDESTRUCT = Opcode(0xFF, popped_stack_items=1)\n    SENDALL = Opcode(0xFF, popped_stack_items=1)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>State associated with an address.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Account:\n\"\"\"\n    State associated with an address.\n    \"\"\"\n\n    nonce: int | None = None\n\"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\n    balance: int | None = None\n\"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\n    code: str | bytes | Code | None = None\n\"\"\"\n    Bytecode contained by the account.\n    \"\"\"\n    storage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None\n\"\"\"\n    Storage within a contract.\n    \"\"\"\n\n    NONEXISTENT: ClassVar[object] = object()\n\"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\n\n    class NonceMismatch(Exception):\n\"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\n\n        address: str\n        want: int | None\n        got: int | None\n\n        def __init__(\n            self, address: str, want: int | None, got: int | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected nonce for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    class BalanceMismatch(Exception):\n\"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\n\n        address: str\n        want: int | None\n        got: int | None\n\n        def __init__(\n            self, address: str, want: int | None, got: int | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected balance for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    class CodeMismatch(Exception):\n\"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\n\n        address: str\n        want: str | None\n        got: str | None\n\n        def __init__(\n            self, address: str, want: str | None, got: str | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected code for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\n        if self.storage is not None and type(self.storage) is dict:\n            self.storage = Storage(self.storage)\n\n    def check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n        Checks the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\n        if self.nonce is not None:\n            actual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\n            if self.nonce != actual_nonce:\n                raise Account.NonceMismatch(\n                    address=address,\n                    want=self.nonce,\n                    got=actual_nonce,\n                )\n\n        if self.balance is not None:\n            actual_balance = int_or_none(alloc.get(\"balance\"), 0)\n            if self.balance != actual_balance:\n                raise Account.BalanceMismatch(\n                    address=address,\n                    want=self.balance,\n                    got=actual_balance,\n                )\n\n        if self.code is not None:\n            expected_code = code_to_hex(self.code)\n            actual_code = str_or_none(alloc.get(\"code\"), \"0x\")\n            if expected_code != actual_code:\n                raise Account.CodeMismatch(\n                    address=address,\n                    want=expected_code,\n                    got=actual_code,\n                )\n\n        if self.storage is not None:\n            expected_storage = (\n                self.storage\n                if isinstance(self.storage, Storage)\n                else Storage(self.storage)\n            )\n            actual_storage = (\n                Storage(alloc[\"storage\"])\n                if \"storage\" in alloc\n                else Storage({})\n            )\n            expected_storage.must_be_equal(actual_storage)\n\n    @classmethod\n    def with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n        Create account with provided `code` and nonce of `1`.\n        \"\"\"\n        return Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.nonce","title":"<code>nonce: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.balance","title":"<code>balance: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of Wei (10-18 Eth) the account has.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.code","title":"<code>code: str | bytes | Code | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.storage","title":"<code>storage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NONEXISTENT","title":"<code>NONEXISTENT: object = object()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch","title":"<code>NonceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class NonceMismatch(Exception):\n\"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\n\n    address: str\n    want: int | None\n    got: int | None\n\n    def __init__(\n        self, address: str, want: int | None, got: int | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected nonce for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected nonce for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch","title":"<code>BalanceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class BalanceMismatch(Exception):\n\"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\n\n    address: str\n    want: int | None\n    got: int | None\n\n    def __init__(\n        self, address: str, want: int | None, got: int | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected balance for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected balance for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch","title":"<code>CodeMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class CodeMismatch(Exception):\n\"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\n\n    address: str\n    want: str | None\n    got: str | None\n\n    def __init__(\n        self, address: str, want: str | None, got: str | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected code for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected code for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Automatically init account members</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\n    if self.storage is not None and type(self.storage) is dict:\n        self.storage = Storage(self.storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.check_alloc","title":"<code>check_alloc(address, alloc)</code>","text":"<p>Checks the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n    Checks the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\n    if self.nonce is not None:\n        actual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\n        if self.nonce != actual_nonce:\n            raise Account.NonceMismatch(\n                address=address,\n                want=self.nonce,\n                got=actual_nonce,\n            )\n\n    if self.balance is not None:\n        actual_balance = int_or_none(alloc.get(\"balance\"), 0)\n        if self.balance != actual_balance:\n            raise Account.BalanceMismatch(\n                address=address,\n                want=self.balance,\n                got=actual_balance,\n            )\n\n    if self.code is not None:\n        expected_code = code_to_hex(self.code)\n        actual_code = str_or_none(alloc.get(\"code\"), \"0x\")\n        if expected_code != actual_code:\n            raise Account.CodeMismatch(\n                address=address,\n                want=expected_code,\n                got=actual_code,\n            )\n\n    if self.storage is not None:\n        expected_storage = (\n            self.storage\n            if isinstance(self.storage, Storage)\n            else Storage(self.storage)\n        )\n        actual_storage = (\n            Storage(alloc[\"storage\"])\n            if \"storage\" in alloc\n            else Storage({})\n        )\n        expected_storage.must_be_equal(actual_storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n    Create account with provided `code` and nonce of `1`.\n    \"\"\"\n    return Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Withdrawal","title":"<code>Withdrawal</code>  <code>dataclass</code>","text":"<p>Structure to represent a single withdrawal of a validator's balance from the beacon chain.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Withdrawal:\n\"\"\"\n    Structure to represent a single withdrawal of a validator's balance from\n    the beacon chain.\n    \"\"\"\n\n    index: int\n    validator: int\n    address: str\n    amount: int\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Environment","title":"<code>Environment</code>  <code>dataclass</code>","text":"<p>Structure used to keep track of the context in which a block must be executed.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Environment:\n\"\"\"\n    Structure used to keep track of the context in which a block\n    must be executed.\n    \"\"\"\n\n    coinbase: str = \"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\"\n    gas_limit: int = 100000000000000000\n    number: int = 1\n    timestamp: int = 1000\n    difficulty: Optional[int] = None\n    prev_randao: Optional[int] = None\n    block_hashes: Dict[int, str] = field(default_factory=dict)\n    base_fee: Optional[int] = None\n    parent_difficulty: Optional[int] = None\n    parent_timestamp: Optional[int] = None\n    parent_base_fee: Optional[int] = None\n    parent_gas_used: Optional[int] = None\n    parent_gas_limit: Optional[int] = None\n    parent_ommers_hash: Optional[str] = None\n    withdrawals: Optional[List[Withdrawal]] = None\n    excess_data_gas: Optional[int] = None\n    parent_excess_data_gas: Optional[int] = None\n\n    @staticmethod\n    def from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Instantiates a new environment with the provided header as parent.\n        \"\"\"\n        return Environment(\n            parent_difficulty=parent.difficulty,\n            parent_timestamp=parent.timestamp,\n            parent_base_fee=parent.base_fee,\n            parent_excess_data_gas=parent.excess_data_gas,\n            parent_gas_used=parent.gas_used,\n            parent_gas_limit=parent.gas_limit,\n            parent_ommers_hash=parent.ommers_hash,\n            block_hashes={\n                parent.number: parent.hash\n                if parent.hash is not None\n                else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n            },\n        )\n\n    def parent_hash(self) -&gt; str:\n\"\"\"\n        Obtjains the latest hash according to the highest block number in\n        `block_hashes`.\n        \"\"\"\n        if len(self.block_hashes) == 0:\n            return \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        last_index = max(self.block_hashes.keys())\n        return self.block_hashes[last_index]\n\n    def apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Applies a header as parent to a copy of this environment.\n        \"\"\"\n        env = copy(self)\n        env.parent_difficulty = new_parent.difficulty\n        env.parent_timestamp = new_parent.timestamp\n        env.parent_base_fee = new_parent.base_fee\n        env.parent_excess_data_gas = new_parent.excess_data_gas\n        env.parent_gas_used = new_parent.gas_used\n        env.parent_gas_limit = new_parent.gas_limit\n        env.parent_ommers_hash = new_parent.ommers_hash\n        env.block_hashes[new_parent.number] = (\n            new_parent.hash\n            if new_parent.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        )\n        return env\n\n    def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n        Fills the required fields in an environment depending on the fork.\n        \"\"\"\n        res = copy(self)\n\n        if (\n            fork.header_prev_randao_required(self.number, self.timestamp)\n            and res.prev_randao is None\n        ):\n            res.prev_randao = 0\n\n        if (\n            fork.header_withdrawals_required(self.number, self.timestamp)\n            and res.withdrawals is None\n        ):\n            res.withdrawals = []\n\n        if (\n            fork.header_base_fee_required(self.number, self.timestamp)\n            and res.base_fee is None\n            and res.parent_base_fee is None\n        ):\n            res.base_fee = DEFAULT_BASE_FEE\n\n        if fork.header_zero_difficulty_required(self.number, self.timestamp):\n            res.difficulty = 0\n\n        if (\n            fork.header_excess_data_gas_required(self.number, self.timestamp)\n            and res.excess_data_gas is None\n        ):\n            res.excess_data_gas = 0\n\n        return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.from_parent_header","title":"<code>from_parent_header(parent)</code>  <code>staticmethod</code>","text":"<p>Instantiates a new environment with the provided header as parent.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@staticmethod\ndef from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Instantiates a new environment with the provided header as parent.\n    \"\"\"\n    return Environment(\n        parent_difficulty=parent.difficulty,\n        parent_timestamp=parent.timestamp,\n        parent_base_fee=parent.base_fee,\n        parent_excess_data_gas=parent.excess_data_gas,\n        parent_gas_used=parent.gas_used,\n        parent_gas_limit=parent.gas_limit,\n        parent_ommers_hash=parent.ommers_hash,\n        block_hashes={\n            parent.number: parent.hash\n            if parent.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        },\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.parent_hash","title":"<code>parent_hash()</code>","text":"<p>Obtjains the latest hash according to the highest block number in <code>block_hashes</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def parent_hash(self) -&gt; str:\n\"\"\"\n    Obtjains the latest hash according to the highest block number in\n    `block_hashes`.\n    \"\"\"\n    if len(self.block_hashes) == 0:\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    last_index = max(self.block_hashes.keys())\n    return self.block_hashes[last_index]\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.apply_new_parent","title":"<code>apply_new_parent(new_parent)</code>","text":"<p>Applies a header as parent to a copy of this environment.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Applies a header as parent to a copy of this environment.\n    \"\"\"\n    env = copy(self)\n    env.parent_difficulty = new_parent.difficulty\n    env.parent_timestamp = new_parent.timestamp\n    env.parent_base_fee = new_parent.base_fee\n    env.parent_excess_data_gas = new_parent.excess_data_gas\n    env.parent_gas_used = new_parent.gas_used\n    env.parent_gas_limit = new_parent.gas_limit\n    env.parent_ommers_hash = new_parent.ommers_hash\n    env.block_hashes[new_parent.number] = (\n        new_parent.hash\n        if new_parent.hash is not None\n        else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    )\n    return env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.set_fork_requirements","title":"<code>set_fork_requirements(fork)</code>","text":"<p>Fills the required fields in an environment depending on the fork.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n    Fills the required fields in an environment depending on the fork.\n    \"\"\"\n    res = copy(self)\n\n    if (\n        fork.header_prev_randao_required(self.number, self.timestamp)\n        and res.prev_randao is None\n    ):\n        res.prev_randao = 0\n\n    if (\n        fork.header_withdrawals_required(self.number, self.timestamp)\n        and res.withdrawals is None\n    ):\n        res.withdrawals = []\n\n    if (\n        fork.header_base_fee_required(self.number, self.timestamp)\n        and res.base_fee is None\n        and res.parent_base_fee is None\n    ):\n        res.base_fee = DEFAULT_BASE_FEE\n\n    if fork.header_zero_difficulty_required(self.number, self.timestamp):\n        res.difficulty = 0\n\n    if (\n        fork.header_excess_data_gas_required(self.number, self.timestamp)\n        and res.excess_data_gas is None\n    ):\n        res.excess_data_gas = 0\n\n    return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.AccessList","title":"<code>AccessList</code>  <code>dataclass</code>","text":"<p>Access List for transactions.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass AccessList:\n\"\"\"\n    Access List for transactions.\n    \"\"\"\n\n    address: str\n    storage_keys: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Transaction","title":"<code>Transaction</code>  <code>dataclass</code>","text":"<p>Generic object that can represent all Ethereum transaction types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Transaction:\n\"\"\"\n    Generic object that can represent all Ethereum transaction types.\n    \"\"\"\n\n    ty: Optional[int] = None\n\"\"\"\n    Transaction type value.\n    \"\"\"\n    chain_id: int = 1\n    nonce: int = 0\n    to: Optional[str] = AddrAA\n    value: int = 0\n    data: bytes | str | Code = bytes()\n    gas_limit: int = 21000\n    access_list: Optional[List[AccessList]] = None\n\n    gas_price: Optional[int] = None\n    max_fee_per_gas: Optional[int] = None\n    max_priority_fee_per_gas: Optional[int] = None\n\n    max_fee_per_data_gas: Optional[int] = None\n    blob_versioned_hashes: Optional[Sequence[str | bytes]] = None\n\n    blob_kzgs: Optional[Sequence[bytes]] = None\n    blobs: Optional[Sequence[Sequence[int]]] = None\n    kzg_aggregated_proof: Optional[str | bytes] = None\n\n    signature: Optional[Tuple[str, str, str]] = None\n    secret_key: Optional[str] = None\n    protected: bool = True\n    error: Optional[str] = None\n\n    class InvalidFeePayment(Exception):\n\"\"\"\n        Transaction described more than one fee payment type.\n        \"\"\"\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                \"only one type of fee payment field can be used in a single tx\"\n            )\n\n    class InvalidSignaturePrivateKey(Exception):\n\"\"\"\n        Transaction describes both the signature and private key of\n        source account.\n        \"\"\"\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return \"can't define both 'signature' and 'private_key'\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"\n        Ensures the transaction has no conflicting properties.\n        \"\"\"\n        if (\n            self.gas_price is not None\n            and self.max_fee_per_gas is not None\n            and self.max_priority_fee_per_gas is not None\n        ):\n            raise Transaction.InvalidFeePayment()\n\n        if (\n            self.gas_price is None\n            and self.max_fee_per_gas is None\n            and self.max_priority_fee_per_gas is None\n        ):\n            self.gas_price = 10\n\n        if self.signature is not None and self.secret_key is not None:\n            raise Transaction.InvalidSignaturePrivateKey()\n\n        if self.signature is None and self.secret_key is None:\n            self.secret_key = TestPrivateKey\n\n        if self.ty is None:\n            # Try to deduce transaction type from included fields\n            if self.max_fee_per_data_gas is not None:\n                self.ty = 5\n            elif self.max_fee_per_gas is not None:\n                self.ty = 2\n            elif self.access_list is not None:\n                self.ty = 1\n            else:\n                self.ty = 0\n\n    def with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with an added error.\n        \"\"\"\n        tx = copy(self)\n        tx.error = error\n        return tx\n\n    def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with a modified nonce.\n        \"\"\"\n        tx = copy(self)\n        tx.nonce = nonce\n        return tx\n\n    def with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n        Create a deepcopy of the transaction with modified fields.\n        \"\"\"\n        tx = deepcopy(self)\n        for key, value in kwargs.items():\n            if hasattr(tx, key):\n                setattr(tx, key, value)\n            else:\n                raise ValueError(f\"Invalid field '{key}' for Transaction\")\n        return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.ty","title":"<code>ty: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment","title":"<code>InvalidFeePayment</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction described more than one fee payment type.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidFeePayment(Exception):\n\"\"\"\n    Transaction described more than one fee payment type.\n    \"\"\"\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            \"only one type of fee payment field can be used in a single tx\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        \"only one type of fee payment field can be used in a single tx\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey","title":"<code>InvalidSignaturePrivateKey</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction describes both the signature and private key of source account.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidSignaturePrivateKey(Exception):\n\"\"\"\n    Transaction describes both the signature and private key of\n    source account.\n    \"\"\"\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures the transaction has no conflicting properties.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"\n    Ensures the transaction has no conflicting properties.\n    \"\"\"\n    if (\n        self.gas_price is not None\n        and self.max_fee_per_gas is not None\n        and self.max_priority_fee_per_gas is not None\n    ):\n        raise Transaction.InvalidFeePayment()\n\n    if (\n        self.gas_price is None\n        and self.max_fee_per_gas is None\n        and self.max_priority_fee_per_gas is None\n    ):\n        self.gas_price = 10\n\n    if self.signature is not None and self.secret_key is not None:\n        raise Transaction.InvalidSignaturePrivateKey()\n\n    if self.signature is None and self.secret_key is None:\n        self.secret_key = TestPrivateKey\n\n    if self.ty is None:\n        # Try to deduce transaction type from included fields\n        if self.max_fee_per_data_gas is not None:\n            self.ty = 5\n        elif self.max_fee_per_gas is not None:\n            self.ty = 2\n        elif self.access_list is not None:\n            self.ty = 1\n        else:\n            self.ty = 0\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_error","title":"<code>with_error(error)</code>","text":"<p>Create a copy of the transaction with an added error.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with an added error.\n    \"\"\"\n    tx = copy(self)\n    tx.error = error\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_nonce","title":"<code>with_nonce(nonce)</code>","text":"<p>Create a copy of the transaction with a modified nonce.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with a modified nonce.\n    \"\"\"\n    tx = copy(self)\n    tx.nonce = nonce\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_fields","title":"<code>with_fields(**kwargs)</code>","text":"<p>Create a deepcopy of the transaction with modified fields.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n    Create a deepcopy of the transaction with modified fields.\n    \"\"\"\n    tx = deepcopy(self)\n    for key, value in kwargs.items():\n        if hasattr(tx, key):\n            setattr(tx, key, value)\n        else:\n            raise ValueError(f\"Invalid field '{key}' for Transaction\")\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header","title":"<code>Header</code>  <code>dataclass</code>","text":"<p>Header type used to describe block header properties in test specs.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Header:\n\"\"\"\n    Header type used to describe block header properties in test specs.\n    \"\"\"\n\n    parent_hash: Optional[str] = None\n    ommers_hash: Optional[str] = None\n    coinbase: Optional[str] = None\n    state_root: Optional[str] = None\n    transactions_root: Optional[str] = None\n    receipt_root: Optional[str] = None\n    bloom: Optional[str] = None\n    difficulty: Optional[int] = None\n    number: Optional[int] = None\n    gas_limit: Optional[int] = None\n    gas_used: Optional[int] = None\n    timestamp: Optional[int] = None\n    extra_data: Optional[str] = None\n    mix_digest: Optional[str] = None\n    nonce: Optional[str] = None\n    base_fee: Optional[int | REMOVABLE] = None\n    withdrawals_root: Optional[str | REMOVABLE] = None\n    excess_data_gas: Optional[int | REMOVABLE] = None\n    hash: Optional[str] = None\n\n    REMOVE_FIELD: ClassVar[REMOVABLE] = REMOVABLE()\n\"\"\"\n    Sentinel object used to specify that a header field should be removed.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Header.REMOVE_FIELD","title":"<code>REMOVE_FIELD: REMOVABLE = REMOVABLE()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify that a header field should be removed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Header</code></p> <p>Block type used to describe block properties in test specs</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Block(Header):\n\"\"\"\n    Block type used to describe block properties in test specs\n    \"\"\"\n\n    rlp: Optional[str] = None\n\"\"\"\n    If set, blockchain test will skip generating the block using\n    `evm_block_builder`, and will pass this value directly to the Fixture.\n\n    Only meant to be used to simulate blocks with bad formats, and therefore\n    requires the block to produce an exception.\n    \"\"\"\n    rlp_modifier: Optional[Header] = None\n\"\"\"\n    An RLP modifying header which values would be used to override the ones\n    returned by the  `evm_transition_tool`.\n    \"\"\"\n    exception: Optional[str] = None\n\"\"\"\n    If set, the block is expected to be rejected by the client.\n    \"\"\"\n    txs: Optional[List[Transaction]] = None\n\"\"\"\n    List of transactions included in the block.\n    \"\"\"\n    ommers: Optional[List[Header]] = None\n\"\"\"\n    List of ommer headers included in the block.\n    \"\"\"\n    withdrawals: Optional[List[Withdrawal]] = None\n\"\"\"\n    List of withdrawals to perform for this block.\n    \"\"\"\n\n    def set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n        Creates a copy of the environment with the characteristics of this\n        specific block.\n        \"\"\"\n        new_env = copy(env)\n\n\"\"\"\n        Values that need to be set in the environment and are `None` for\n        this block need to be set to their defaults.\n        \"\"\"\n        environment_default = Environment()\n        new_env.difficulty = self.difficulty\n        new_env.coinbase = (\n            self.coinbase\n            if self.coinbase is not None\n            else environment_default.coinbase\n        )\n        new_env.gas_limit = (\n            self.gas_limit\n            if self.gas_limit is not None\n            else environment_default.gas_limit\n        )\n        if not isinstance(self.base_fee, REMOVABLE):\n            new_env.base_fee = self.base_fee\n        new_env.withdrawals = self.withdrawals\n        if not isinstance(self.excess_data_gas, REMOVABLE):\n            new_env.excess_data_gas = self.excess_data_gas\n\n\"\"\"\n        These values are required, but they depend on the previous environment,\n        so they can be calculated here.\n        \"\"\"\n        if self.number is not None:\n            new_env.number = self.number\n        else:\n            # calculate the next block number for the environment\n            if len(new_env.block_hashes) == 0:\n                new_env.number = 0\n            else:\n                new_env.number = max(new_env.block_hashes.keys()) + 1\n\n        if self.timestamp is not None:\n            new_env.timestamp = self.timestamp\n        else:\n            assert new_env.parent_timestamp is not None\n            new_env.timestamp = new_env.parent_timestamp + 12\n\n        return new_env\n\n    def copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n        Creates a copy of the block and adds the specified RLP.\n        \"\"\"\n        new_block = deepcopy(self)\n        new_block.rlp = rlp\n        return new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp","title":"<code>rlp: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, blockchain test will skip generating the block using <code>evm_block_builder</code>, and will pass this value directly to the Fixture.</p> <p>Only meant to be used to simulate blocks with bad formats, and therefore requires the block to produce an exception.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp_modifier","title":"<code>rlp_modifier: Optional[Header] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An RLP modifying header which values would be used to override the ones returned by the  <code>evm_transition_tool</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.exception","title":"<code>exception: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, the block is expected to be rejected by the client.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.txs","title":"<code>txs: Optional[List[Transaction]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of transactions included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.ommers","title":"<code>ommers: Optional[List[Header]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of ommer headers included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.withdrawals","title":"<code>withdrawals: Optional[List[Withdrawal]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of withdrawals to perform for this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.set_environment","title":"<code>set_environment(env)</code>","text":"<p>Creates a copy of the environment with the characteristics of this specific block.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n    Creates a copy of the environment with the characteristics of this\n    specific block.\n    \"\"\"\n    new_env = copy(env)\n\n\"\"\"\n    Values that need to be set in the environment and are `None` for\n    this block need to be set to their defaults.\n    \"\"\"\n    environment_default = Environment()\n    new_env.difficulty = self.difficulty\n    new_env.coinbase = (\n        self.coinbase\n        if self.coinbase is not None\n        else environment_default.coinbase\n    )\n    new_env.gas_limit = (\n        self.gas_limit\n        if self.gas_limit is not None\n        else environment_default.gas_limit\n    )\n    if not isinstance(self.base_fee, REMOVABLE):\n        new_env.base_fee = self.base_fee\n    new_env.withdrawals = self.withdrawals\n    if not isinstance(self.excess_data_gas, REMOVABLE):\n        new_env.excess_data_gas = self.excess_data_gas\n\n\"\"\"\n    These values are required, but they depend on the previous environment,\n    so they can be calculated here.\n    \"\"\"\n    if self.number is not None:\n        new_env.number = self.number\n    else:\n        # calculate the next block number for the environment\n        if len(new_env.block_hashes) == 0:\n            new_env.number = 0\n        else:\n            new_env.number = max(new_env.block_hashes.keys()) + 1\n\n    if self.timestamp is not None:\n        new_env.timestamp = self.timestamp\n    else:\n        assert new_env.parent_timestamp is not None\n        new_env.timestamp = new_env.parent_timestamp + 12\n\n    return new_env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.copy_with_rlp","title":"<code>copy_with_rlp(rlp)</code>","text":"<p>Creates a copy of the block and adds the specified RLP.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n    Creates a copy of the block and adds the specified RLP.\n    \"\"\"\n    new_block = deepcopy(self)\n    new_block.rlp = rlp\n    return new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Fixture","title":"<code>Fixture</code>  <code>dataclass</code>","text":"<p>Cross-client compatible Ethereum test fixture.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Fixture:\n\"\"\"\n    Cross-client compatible Ethereum test fixture.\n    \"\"\"\n\n    blocks: List[FixtureBlock]\n    genesis: FixtureHeader\n    genesis_rlp: str\n    head: str\n    fork: str\n    pre_state: Mapping[str, Account]\n    post_state: Optional[Mapping[str, Account]]\n    seal_engine: str\n    info: Dict[str, str] = field(default_factory=dict)\n    name: str = \"\"\n    index: int = 0\n\n    _json: Dict[str, Any] | None = None\n\n    def __post_init__(self):\n\"\"\"\n        Post init hook to convert to JSON after instantiation.\n        \"\"\"\n        self._json = to_json(self)\n\n    def fill_info(\n        self,\n        t8n: TransitionTool,\n        b11r: BlockBuilder,\n        ref_spec: ReferenceSpec | None,\n    ):\n\"\"\"\n        Fill the info field for this fixture\n        \"\"\"\n        self.info[\"filling-transition-tool\"] = t8n.version()\n        self.info[\"filling-block-build-tool\"] = b11r.version()\n        if ref_spec is not None:\n            ref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init hook to convert to JSON after instantiation.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self):\n\"\"\"\n    Post init hook to convert to JSON after instantiation.\n    \"\"\"\n    self._json = to_json(self)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.fill_info","title":"<code>fill_info(t8n, b11r, ref_spec)</code>","text":"<p>Fill the info field for this fixture</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def fill_info(\n    self,\n    t8n: TransitionTool,\n    b11r: BlockBuilder,\n    ref_spec: ReferenceSpec | None,\n):\n\"\"\"\n    Fill the info field for this fixture\n    \"\"\"\n    self.info[\"filling-transition-tool\"] = t8n.version()\n    self.info[\"filling-block-build-tool\"] = b11r.version()\n    if ref_spec is not None:\n        ref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.JSONEncoder","title":"<code>JSONEncoder</code>","text":"<p>         Bases: <code>json.JSONEncoder</code></p> <p>Custom JSON encoder for <code>ethereum_test</code> types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class JSONEncoder(json.JSONEncoder):\n\"\"\"\n    Custom JSON encoder for `ethereum_test` types.\n    \"\"\"\n\n    def default(self, obj):\n\"\"\"\n        Enocdes types defined in this module using basic python facilities.\n        \"\"\"\n        if isinstance(obj, Storage):\n            return obj.to_dict()\n        elif isinstance(obj, Account):\n            account = {\n                \"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n                \"balance\": hex_or_none(\n                    obj.balance, hex(ACCOUNT_DEFAULTS.balance)\n                ),\n                \"code\": code_or_none(obj.code, \"0x\"),\n                \"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n            }\n            return even_padding(account, excluded=[\"storage\"])\n        elif isinstance(obj, AccessList):\n            access_list = {\"address\": obj.address}\n            if obj.storage_keys is not None:\n                access_list[\"storageKeys\"] = obj.storage_keys\n            return access_list\n        elif isinstance(obj, Transaction):\n            tx = {\n                \"type\": hex(obj.ty),\n                \"chainId\": hex(obj.chain_id),\n                \"nonce\": hex(obj.nonce),\n                \"gasPrice\": hex_or_none(obj.gas_price),\n                \"maxPriorityFeePerGas\": hex_or_none(\n                    obj.max_priority_fee_per_gas\n                ),\n                \"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n                \"gas\": hex(obj.gas_limit),\n                \"value\": hex(obj.value),\n                \"input\": code_to_hex(obj.data),\n                \"to\": obj.to,\n                \"accessList\": obj.access_list,\n                \"protected\": obj.protected,\n                \"secretKey\": obj.secret_key,\n                \"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n            }\n\n            if obj.blob_versioned_hashes is not None:\n                hashes: List[str] = []\n                for h in obj.blob_versioned_hashes:\n                    if type(h) is str:\n                        hashes.append(h)\n                    elif type(h) is bytes:\n                        if len(h) != 32:\n                            raise TypeError(\n                                \"improper byte size for blob_versioned_hashes\"\n                            )\n                        hashes.append(\"0x\" + h.hex())\n                    else:\n                        raise TypeError(\n                            \"improper type for blob_versioned_hashes\"\n                        )\n                tx[\"blobVersionedHashes\"] = hashes\n\n            if obj.secret_key is None:\n                assert obj.signature is not None\n                assert len(obj.signature) == 3\n                tx[\"v\"] = obj.signature[0]\n                tx[\"r\"] = obj.signature[1]\n                tx[\"s\"] = obj.signature[2]\n            else:\n                tx[\"v\"] = \"\"\n                tx[\"r\"] = \"\"\n                tx[\"s\"] = \"\"\n            return {k: v for (k, v) in tx.items() if v is not None}\n        elif isinstance(obj, Withdrawal):\n            withdrawal = {\n                \"index\": hex(obj.index),\n                \"validatorIndex\": hex(obj.validator),\n                \"address\": obj.address,\n                \"amount\": hex(obj.amount),\n            }\n            return withdrawal\n        elif isinstance(obj, Environment):\n            env = {\n                \"currentCoinbase\": obj.coinbase,\n                \"currentGasLimit\": str_or_none(obj.gas_limit),\n                \"currentNumber\": str_or_none(obj.number),\n                \"currentTimestamp\": str_or_none(obj.timestamp),\n                \"currentRandom\": str_or_none(obj.prev_randao),\n                \"currentDifficulty\": str_or_none(obj.difficulty),\n                \"parentDifficulty\": str_or_none(obj.parent_difficulty),\n                \"parentBaseFee\": str_or_none(obj.parent_base_fee),\n                \"parentGasUsed\": str_or_none(obj.parent_gas_used),\n                \"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n                \"parentTimstamp\": str_or_none(obj.parent_timestamp),\n                \"blockHashes\": {\n                    str(k): v for (k, v) in obj.block_hashes.items()\n                },\n                \"ommers\": [],\n                \"withdrawals\": to_json_or_none(obj.withdrawals),\n                \"parentUncleHash\": obj.parent_ommers_hash,\n                \"currentBaseFee\": str_or_none(obj.base_fee),\n                \"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n                \"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n            }\n\n            return {k: v for (k, v) in env.items() if v is not None}\n        elif isinstance(obj, FixtureHeader):\n            header = {\n                \"parentHash\": obj.parent_hash,\n                \"uncleHash\": obj.ommers_hash,\n                \"coinbase\": obj.coinbase,\n                \"stateRoot\": obj.state_root,\n                \"transactionsTrie\": obj.transactions_root,\n                \"receiptTrie\": obj.receipt_root,\n                \"bloom\": obj.bloom,\n                \"difficulty\": hex(obj.difficulty),\n                \"number\": hex(obj.number),\n                \"gasLimit\": hex(obj.gas_limit),\n                \"gasUsed\": hex(obj.gas_used),\n                \"timestamp\": hex(obj.timestamp),\n                \"extraData\": obj.extra_data\n                if len(obj.extra_data) != 0\n                else \"0x\",  # noqa: E501\n                \"mixHash\": obj.mix_digest,\n                \"nonce\": obj.nonce,\n            }\n            if obj.base_fee is not None:\n                header[\"baseFeePerGas\"] = hex(obj.base_fee)\n            if obj.hash is not None:\n                header[\"hash\"] = obj.hash\n            if obj.withdrawals_root is not None:\n                header[\"withdrawalsRoot\"] = obj.withdrawals_root\n            if obj.excess_data_gas is not None:\n                header[\"excessDataGas\"] = hex(obj.excess_data_gas)\n            return even_padding(\n                header,\n                excluded=[\n                    \"parentHash\",\n                    \"uncleHash\",\n                    \"stateRoot\",\n                    \"coinbase\",\n                    \"transactionsTrie\",\n                    \"receiptTrie\",\n                    \"bloom\",\n                    \"nonce\",\n                    \"mixHash\",\n                    \"hash\",\n                    \"withdrawalsRoot\",\n                    \"extraData\",\n                ],\n            )\n        elif isinstance(obj, FixtureTransaction):\n            json_tx = to_json(obj.tx)\n            if json_tx[\"v\"] == \"\":\n                del json_tx[\"v\"]\n                del json_tx[\"r\"]\n                del json_tx[\"s\"]\n            if \"input\" in json_tx:\n                json_tx[\"data\"] = json_tx[\"input\"]\n                del json_tx[\"input\"]\n            if \"gas\" in json_tx:\n                json_tx[\"gasLimit\"] = json_tx[\"gas\"]\n                del json_tx[\"gas\"]\n            if \"protected\" in json_tx:\n                del json_tx[\"protected\"]\n            if \"to\" not in json_tx:\n                json_tx[\"to\"] = \"\"\n            return even_padding(\n                json_tx,\n                excluded=[\"to\", \"accessList\"],\n            )\n        elif isinstance(obj, FixtureBlock):\n            b = {\"rlp\": obj.rlp}\n            if obj.block_header is not None:\n                b[\"blockHeader\"] = json.loads(\n                    json.dumps(obj.block_header, cls=JSONEncoder)\n                )\n            if obj.expected_exception is not None:\n                b[\"expectException\"] = obj.expected_exception\n            if obj.block_number is not None:\n                b[\"blocknumber\"] = str(obj.block_number)\n            if obj.txs is not None:\n                b[\"transactions\"] = [\n                    FixtureTransaction(tx=tx) for tx in obj.txs\n                ]\n            if obj.ommers is not None:\n                b[\"uncleHeaders\"] = obj.ommers\n            if obj.withdrawals is not None:\n                b[\"withdrawals\"] = [\n                    even_padding(to_json(wd), excluded=[\"address\"])\n                    for wd in obj.withdrawals\n                ]\n            return b\n        elif isinstance(obj, Fixture):\n            if obj._json is not None:\n                obj._json[\"_info\"] = obj.info\n                return obj._json\n\n            f = {\n                \"_info\": obj.info,\n                \"blocks\": [\n                    json.loads(json.dumps(b, cls=JSONEncoder))\n                    for b in obj.blocks\n                ],\n                \"genesisBlockHeader\": self.default(obj.genesis),\n                \"genesisRLP\": obj.genesis_rlp,\n                \"lastblockhash\": obj.head,\n                \"network\": obj.fork,\n                \"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n                \"postState\": json.loads(\n                    json.dumps(obj.post_state, cls=JSONEncoder)\n                ),\n                \"sealEngine\": obj.seal_engine,\n            }\n            if f[\"postState\"] is None:\n                del f[\"postState\"]\n            return f\n        else:\n            return super().default(obj)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.JSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Enocdes types defined in this module using basic python facilities.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def default(self, obj):\n\"\"\"\n    Enocdes types defined in this module using basic python facilities.\n    \"\"\"\n    if isinstance(obj, Storage):\n        return obj.to_dict()\n    elif isinstance(obj, Account):\n        account = {\n            \"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n            \"balance\": hex_or_none(\n                obj.balance, hex(ACCOUNT_DEFAULTS.balance)\n            ),\n            \"code\": code_or_none(obj.code, \"0x\"),\n            \"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n        }\n        return even_padding(account, excluded=[\"storage\"])\n    elif isinstance(obj, AccessList):\n        access_list = {\"address\": obj.address}\n        if obj.storage_keys is not None:\n            access_list[\"storageKeys\"] = obj.storage_keys\n        return access_list\n    elif isinstance(obj, Transaction):\n        tx = {\n            \"type\": hex(obj.ty),\n            \"chainId\": hex(obj.chain_id),\n            \"nonce\": hex(obj.nonce),\n            \"gasPrice\": hex_or_none(obj.gas_price),\n            \"maxPriorityFeePerGas\": hex_or_none(\n                obj.max_priority_fee_per_gas\n            ),\n            \"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n            \"gas\": hex(obj.gas_limit),\n            \"value\": hex(obj.value),\n            \"input\": code_to_hex(obj.data),\n            \"to\": obj.to,\n            \"accessList\": obj.access_list,\n            \"protected\": obj.protected,\n            \"secretKey\": obj.secret_key,\n            \"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n        }\n\n        if obj.blob_versioned_hashes is not None:\n            hashes: List[str] = []\n            for h in obj.blob_versioned_hashes:\n                if type(h) is str:\n                    hashes.append(h)\n                elif type(h) is bytes:\n                    if len(h) != 32:\n                        raise TypeError(\n                            \"improper byte size for blob_versioned_hashes\"\n                        )\n                    hashes.append(\"0x\" + h.hex())\n                else:\n                    raise TypeError(\n                        \"improper type for blob_versioned_hashes\"\n                    )\n            tx[\"blobVersionedHashes\"] = hashes\n\n        if obj.secret_key is None:\n            assert obj.signature is not None\n            assert len(obj.signature) == 3\n            tx[\"v\"] = obj.signature[0]\n            tx[\"r\"] = obj.signature[1]\n            tx[\"s\"] = obj.signature[2]\n        else:\n            tx[\"v\"] = \"\"\n            tx[\"r\"] = \"\"\n            tx[\"s\"] = \"\"\n        return {k: v for (k, v) in tx.items() if v is not None}\n    elif isinstance(obj, Withdrawal):\n        withdrawal = {\n            \"index\": hex(obj.index),\n            \"validatorIndex\": hex(obj.validator),\n            \"address\": obj.address,\n            \"amount\": hex(obj.amount),\n        }\n        return withdrawal\n    elif isinstance(obj, Environment):\n        env = {\n            \"currentCoinbase\": obj.coinbase,\n            \"currentGasLimit\": str_or_none(obj.gas_limit),\n            \"currentNumber\": str_or_none(obj.number),\n            \"currentTimestamp\": str_or_none(obj.timestamp),\n            \"currentRandom\": str_or_none(obj.prev_randao),\n            \"currentDifficulty\": str_or_none(obj.difficulty),\n            \"parentDifficulty\": str_or_none(obj.parent_difficulty),\n            \"parentBaseFee\": str_or_none(obj.parent_base_fee),\n            \"parentGasUsed\": str_or_none(obj.parent_gas_used),\n            \"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n            \"parentTimstamp\": str_or_none(obj.parent_timestamp),\n            \"blockHashes\": {\n                str(k): v for (k, v) in obj.block_hashes.items()\n            },\n            \"ommers\": [],\n            \"withdrawals\": to_json_or_none(obj.withdrawals),\n            \"parentUncleHash\": obj.parent_ommers_hash,\n            \"currentBaseFee\": str_or_none(obj.base_fee),\n            \"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n            \"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n        }\n\n        return {k: v for (k, v) in env.items() if v is not None}\n    elif isinstance(obj, FixtureHeader):\n        header = {\n            \"parentHash\": obj.parent_hash,\n            \"uncleHash\": obj.ommers_hash,\n            \"coinbase\": obj.coinbase,\n            \"stateRoot\": obj.state_root,\n            \"transactionsTrie\": obj.transactions_root,\n            \"receiptTrie\": obj.receipt_root,\n            \"bloom\": obj.bloom,\n            \"difficulty\": hex(obj.difficulty),\n            \"number\": hex(obj.number),\n            \"gasLimit\": hex(obj.gas_limit),\n            \"gasUsed\": hex(obj.gas_used),\n            \"timestamp\": hex(obj.timestamp),\n            \"extraData\": obj.extra_data\n            if len(obj.extra_data) != 0\n            else \"0x\",  # noqa: E501\n            \"mixHash\": obj.mix_digest,\n            \"nonce\": obj.nonce,\n        }\n        if obj.base_fee is not None:\n            header[\"baseFeePerGas\"] = hex(obj.base_fee)\n        if obj.hash is not None:\n            header[\"hash\"] = obj.hash\n        if obj.withdrawals_root is not None:\n            header[\"withdrawalsRoot\"] = obj.withdrawals_root\n        if obj.excess_data_gas is not None:\n            header[\"excessDataGas\"] = hex(obj.excess_data_gas)\n        return even_padding(\n            header,\n            excluded=[\n                \"parentHash\",\n                \"uncleHash\",\n                \"stateRoot\",\n                \"coinbase\",\n                \"transactionsTrie\",\n                \"receiptTrie\",\n                \"bloom\",\n                \"nonce\",\n                \"mixHash\",\n                \"hash\",\n                \"withdrawalsRoot\",\n                \"extraData\",\n            ],\n        )\n    elif isinstance(obj, FixtureTransaction):\n        json_tx = to_json(obj.tx)\n        if json_tx[\"v\"] == \"\":\n            del json_tx[\"v\"]\n            del json_tx[\"r\"]\n            del json_tx[\"s\"]\n        if \"input\" in json_tx:\n            json_tx[\"data\"] = json_tx[\"input\"]\n            del json_tx[\"input\"]\n        if \"gas\" in json_tx:\n            json_tx[\"gasLimit\"] = json_tx[\"gas\"]\n            del json_tx[\"gas\"]\n        if \"protected\" in json_tx:\n            del json_tx[\"protected\"]\n        if \"to\" not in json_tx:\n            json_tx[\"to\"] = \"\"\n        return even_padding(\n            json_tx,\n            excluded=[\"to\", \"accessList\"],\n        )\n    elif isinstance(obj, FixtureBlock):\n        b = {\"rlp\": obj.rlp}\n        if obj.block_header is not None:\n            b[\"blockHeader\"] = json.loads(\n                json.dumps(obj.block_header, cls=JSONEncoder)\n            )\n        if obj.expected_exception is not None:\n            b[\"expectException\"] = obj.expected_exception\n        if obj.block_number is not None:\n            b[\"blocknumber\"] = str(obj.block_number)\n        if obj.txs is not None:\n            b[\"transactions\"] = [\n                FixtureTransaction(tx=tx) for tx in obj.txs\n            ]\n        if obj.ommers is not None:\n            b[\"uncleHeaders\"] = obj.ommers\n        if obj.withdrawals is not None:\n            b[\"withdrawals\"] = [\n                even_padding(to_json(wd), excluded=[\"address\"])\n                for wd in obj.withdrawals\n            ]\n        return b\n    elif isinstance(obj, Fixture):\n        if obj._json is not None:\n            obj._json[\"_info\"] = obj.info\n            return obj._json\n\n        f = {\n            \"_info\": obj.info,\n            \"blocks\": [\n                json.loads(json.dumps(b, cls=JSONEncoder))\n                for b in obj.blocks\n            ],\n            \"genesisBlockHeader\": self.default(obj.genesis),\n            \"genesisRLP\": obj.genesis_rlp,\n            \"lastblockhash\": obj.head,\n            \"network\": obj.fork,\n            \"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n            \"postState\": json.loads(\n                json.dumps(obj.post_state, cls=JSONEncoder)\n            ),\n            \"sealEngine\": obj.seal_engine,\n        }\n        if f[\"postState\"] is None:\n            del f[\"postState\"]\n        return f\n    else:\n        return super().default(obj)\n</code></pre>"},{"location":"library/evm_block_builder/","title":"EVM Block Builder Package","text":"<p>Python wrapper for the <code>evm b11r</code> tool.</p>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder","title":"<code>BlockBuilder</code>","text":"<p>Generic Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class BlockBuilder:\n\"\"\"\n    Generic Block builder frontend.\n    \"\"\"\n\n    @abstractmethod\n    def build(\n        self,\n        header: Any,\n        txs: Any,\n        ommers: Any,\n        withdrawals: Optional[Any] = None,\n        clique: Optional[Any] = None,\n        ethash: bool = False,\n        ethash_mode: str = \"normal\",\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Build a block with specified parameters and return RLP and hash\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to build the block\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>  <code>abstractmethod</code>","text":"<p>Build a block with specified parameters and return RLP and hash</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    header: Any,\n    txs: Any,\n    ommers: Any,\n    withdrawals: Optional[Any] = None,\n    clique: Optional[Any] = None,\n    ethash: bool = False,\n    ethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Build a block with specified parameters and return RLP and hash\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to build the block</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to build the block\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder","title":"<code>EvmBlockBuilder</code>","text":"<p>         Bases: <code>BlockBuilder</code></p> <p>Go-ethereum <code>evm</code> Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class EvmBlockBuilder(BlockBuilder):\n\"\"\"\n    Go-ethereum `evm` Block builder frontend.\n    \"\"\"\n\n    binary: Path\n    cached_version: Optional[str] = None\n\n    def __init__(self, binary: Optional[Path] = None):\n        if binary is None:\n            which_path = which(\"evm\")\n            if which_path is not None:\n                binary = Path(which_path)\n        if binary is None or not binary.exists():\n            raise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n            )\n        self.binary = binary\n\n    def build(\n        self,\n        header: Any,\n        txs: Any,\n        ommers: Any,\n        withdrawals: Optional[Any] = None,\n        clique: Optional[Any] = None,\n        ethash: bool = False,\n        ethash_mode: str = \"normal\",\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Executes `evm b11r` with the specified arguments.\n        \"\"\"\n        args = [\n            str(self.binary),\n            \"b11r\",\n            \"--input.header=stdin\",\n            \"--input.txs=stdin\",\n            \"--input.ommers=stdin\",\n            \"--seal.clique=stdin\",\n            \"--output.block=stdout\",\n            \"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n        ]\n\n        if ethash:\n            args.append(\"--seal.ethash\")\n            args.append(\"--seal.ethash.mode=\" + ethash_mode)\n\n        stdin = {\n            \"header\": header,\n            \"txs\": txs,\n            \"uncles\": ommers,\n            \"clique\": clique,\n        }\n        if withdrawals is not None:\n            stdin[\"withdrawals\"] = withdrawals\n\n        result = subprocess.run(\n            args,\n            input=str.encode(json.dumps(stdin)),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\"failed to build\")\n\n        output = json.loads(result.stdout)\n\n        if \"rlp\" not in output or \"hash\" not in output:\n            Exception(\"malformed result\")\n\n        return (output[\"rlp\"], output[\"hash\"])\n\n    def version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\n        if self.cached_version is None:\n            result = subprocess.run(\n                [str(self.binary), \"-v\"],\n                stdout=subprocess.PIPE,\n            )\n\n            if result.returncode != 0:\n                raise Exception(\n                    \"failed to evaluate: \" + result.stderr.decode()\n                )\n\n            self.cached_version = result.stdout.decode().strip()\n\n        return self.cached_version\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>","text":"<p>Executes <code>evm b11r</code> with the specified arguments.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def build(\n    self,\n    header: Any,\n    txs: Any,\n    ommers: Any,\n    withdrawals: Optional[Any] = None,\n    clique: Optional[Any] = None,\n    ethash: bool = False,\n    ethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Executes `evm b11r` with the specified arguments.\n    \"\"\"\n    args = [\n        str(self.binary),\n        \"b11r\",\n        \"--input.header=stdin\",\n        \"--input.txs=stdin\",\n        \"--input.ommers=stdin\",\n        \"--seal.clique=stdin\",\n        \"--output.block=stdout\",\n        \"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n    ]\n\n    if ethash:\n        args.append(\"--seal.ethash\")\n        args.append(\"--seal.ethash.mode=\" + ethash_mode)\n\n    stdin = {\n        \"header\": header,\n        \"txs\": txs,\n        \"uncles\": ommers,\n        \"clique\": clique,\n    }\n    if withdrawals is not None:\n        stdin[\"withdrawals\"] = withdrawals\n\n    result = subprocess.run(\n        args,\n        input=str.encode(json.dumps(stdin)),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    if result.returncode != 0:\n        raise Exception(\"failed to build\")\n\n    output = json.loads(result.stdout)\n\n    if \"rlp\" not in output or \"hash\" not in output:\n        Exception(\"malformed result\")\n\n    return (output[\"rlp\"], output[\"hash\"])\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\n    if self.cached_version is None:\n        result = subprocess.run(\n            [str(self.binary), \"-v\"],\n            stdout=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\n                \"failed to evaluate: \" + result.stderr.decode()\n            )\n\n        self.cached_version = result.stdout.decode().strip()\n\n    return self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/","title":"EVM Transition Tool Package","text":"<p>Python wrapper for the <code>evm t8n</code> tool.</p>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool","title":"<code>TransitionTool</code>","text":"<p>Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class TransitionTool:\n\"\"\"\n    Transition tool frontend.\n    \"\"\"\n\n    traces: List[List[List[Dict]]] | None = None\n\n    @abstractmethod\n    def evaluate(\n        self,\n        alloc: Any,\n        txs: Any,\n        env: Any,\n        fork: Fork,\n        chain_id: int = 1,\n        reward: int = 0,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Simulate a state transition with specified parameters\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to state transition\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\n        pass\n\n    def reset_traces(self):\n\"\"\"\n        Resets the internal trace storage for a new test to begin\n        \"\"\"\n        self.traces = None\n\n    def append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n        Appends a list of traces of a state transition to the current list\n        \"\"\"\n        if self.traces is None:\n            self.traces = []\n        self.traces.append(new_traces)\n\n    def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n        Returns the accumulated traces\n        \"\"\"\n        return self.traces\n\n    def calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\n        env: Dict[str, Any] = {\n            \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n            \"currentDifficulty\": \"0x0\",\n            \"currentGasLimit\": \"0x0\",\n            \"currentNumber\": \"0\",\n            \"currentTimestamp\": \"0\",\n        }\n\n        if fork.header_base_fee_required(0, 0):\n            env[\"currentBaseFee\"] = \"7\"\n\n        if fork.header_prev_randao_required(0, 0):\n            env[\"currentRandom\"] = \"0\"\n\n        if fork.header_withdrawals_required(0, 0):\n            env[\"withdrawals\"] = []\n\n        (_, result, _) = self.evaluate(alloc, [], env, fork)\n        state_root = result.get(\"stateRoot\")\n        if state_root is None or not isinstance(state_root, str):\n            raise Exception(\"Unable to calculate state root\")\n        return state_root\n\n    def calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\n        if type(withdrawals) is list and len(withdrawals) == 0:\n            # Optimize returning the empty root immediately\n            return \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\n\n        env: Dict[str, Any] = {\n            \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n            \"currentDifficulty\": \"0x0\",\n            \"currentGasLimit\": \"0x0\",\n            \"currentNumber\": \"0\",\n            \"currentTimestamp\": \"0\",\n            \"withdrawals\": withdrawals,\n        }\n\n        if fork.header_base_fee_required(0, 0):\n            env[\"currentBaseFee\"] = \"7\"\n\n        if fork.header_prev_randao_required(0, 0):\n            env[\"currentRandom\"] = \"0\"\n\n        if fork.header_excess_data_gas_required(0, 0):\n            env[\"currentExcessDataGas\"] = \"0\"\n\n        (_, result, _) = self.evaluate({}, [], env, fork)\n        withdrawals_root = result.get(\"withdrawalsRoot\")\n        if withdrawals_root is None:\n            raise Exception(\n                \"Unable to calculate withdrawals root: \"\n                + \"no value returned from transition tool\"\n            )\n        if type(withdrawals_root) is not str:\n            raise Exception(\n                \"Unable to calculate withdrawals root: \"\n                + \"incorrect type returned from transition tool: \"\n                + f\"{withdrawals_root}\"\n            )\n        return withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Simulate a state transition with specified parameters</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef evaluate(\n    self,\n    alloc: Any,\n    txs: Any,\n    env: Any,\n    fork: Fork,\n    chain_id: int = 1,\n    reward: int = 0,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Simulate a state transition with specified parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to state transition</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to state transition\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>  <code>abstractmethod</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.reset_traces","title":"<code>reset_traces()</code>","text":"<p>Resets the internal trace storage for a new test to begin</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def reset_traces(self):\n\"\"\"\n    Resets the internal trace storage for a new test to begin\n    \"\"\"\n    self.traces = None\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.append_traces","title":"<code>append_traces(new_traces)</code>","text":"<p>Appends a list of traces of a state transition to the current list</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n    Appends a list of traces of a state transition to the current list\n    \"\"\"\n    if self.traces is None:\n        self.traces = []\n    self.traces.append(new_traces)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.get_traces","title":"<code>get_traces()</code>","text":"<p>Returns the accumulated traces</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n    Returns the accumulated traces\n    \"\"\"\n    return self.traces\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_state_root","title":"<code>calc_state_root(alloc, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\n    env: Dict[str, Any] = {\n        \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n        \"currentDifficulty\": \"0x0\",\n        \"currentGasLimit\": \"0x0\",\n        \"currentNumber\": \"0\",\n        \"currentTimestamp\": \"0\",\n    }\n\n    if fork.header_base_fee_required(0, 0):\n        env[\"currentBaseFee\"] = \"7\"\n\n    if fork.header_prev_randao_required(0, 0):\n        env[\"currentRandom\"] = \"0\"\n\n    if fork.header_withdrawals_required(0, 0):\n        env[\"withdrawals\"] = []\n\n    (_, result, _) = self.evaluate(alloc, [], env, fork)\n    state_root = result.get(\"stateRoot\")\n    if state_root is None or not isinstance(state_root, str):\n        raise Exception(\"Unable to calculate state root\")\n    return state_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_withdrawals_root","title":"<code>calc_withdrawals_root(withdrawals, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\n    if type(withdrawals) is list and len(withdrawals) == 0:\n        # Optimize returning the empty root immediately\n        return \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\n\n    env: Dict[str, Any] = {\n        \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n        \"currentDifficulty\": \"0x0\",\n        \"currentGasLimit\": \"0x0\",\n        \"currentNumber\": \"0\",\n        \"currentTimestamp\": \"0\",\n        \"withdrawals\": withdrawals,\n    }\n\n    if fork.header_base_fee_required(0, 0):\n        env[\"currentBaseFee\"] = \"7\"\n\n    if fork.header_prev_randao_required(0, 0):\n        env[\"currentRandom\"] = \"0\"\n\n    if fork.header_excess_data_gas_required(0, 0):\n        env[\"currentExcessDataGas\"] = \"0\"\n\n    (_, result, _) = self.evaluate({}, [], env, fork)\n    withdrawals_root = result.get(\"withdrawalsRoot\")\n    if withdrawals_root is None:\n        raise Exception(\n            \"Unable to calculate withdrawals root: \"\n            + \"no value returned from transition tool\"\n        )\n    if type(withdrawals_root) is not str:\n        raise Exception(\n            \"Unable to calculate withdrawals root: \"\n            + \"incorrect type returned from transition tool: \"\n            + f\"{withdrawals_root}\"\n        )\n    return withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool","title":"<code>EvmTransitionTool</code>","text":"<p>         Bases: <code>TransitionTool</code></p> <p>Go-ethereum <code>evm</code> Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class EvmTransitionTool(TransitionTool):\n\"\"\"\n    Go-ethereum `evm` Transition tool frontend.\n    \"\"\"\n\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n\n    def __init__(\n        self,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        if binary is None:\n            which_path = which(\"evm\")\n            if which_path is not None:\n                binary = Path(which_path)\n        if binary is None or not binary.exists():\n            raise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n            )\n        self.binary = binary\n        self.trace = trace\n\n    def evaluate(\n        self,\n        alloc: Any,\n        txs: Any,\n        env: Any,\n        fork: Fork,\n        chain_id: int = 1,\n        reward: int = 0,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Executes `evm t8n` with the specified arguments.\n        \"\"\"\n        fork_name = fork.name()\n        if eips is not None:\n            fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n        temp_dir = tempfile.TemporaryDirectory()\n\n        args = [\n            str(self.binary),\n            \"t8n\",\n            \"--input.alloc=stdin\",\n            \"--input.txs=stdin\",\n            \"--input.env=stdin\",\n            \"--output.result=stdout\",\n            \"--output.alloc=stdout\",\n            \"--output.body=txs.rlp\",\n            f\"--output.basedir={temp_dir.name}\",\n            f\"--state.fork={fork_name}\",\n            f\"--state.chainid={chain_id}\",\n            f\"--state.reward={reward}\",\n        ]\n\n        if self.trace:\n            args.append(\"--trace\")\n\n        stdin = {\n            \"alloc\": alloc,\n            \"txs\": txs,\n            \"env\": env,\n        }\n\n        encoded_input = str.encode(json.dumps(stdin))\n        result = subprocess.run(\n            args,\n            input=encoded_input,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n        output = json.loads(result.stdout)\n\n        if \"alloc\" not in output or \"result\" not in output:\n            raise Exception(\"malformed result\")\n\n        with open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\n            txs_rlp = txs_rlp_file.read().strip('\"')\n\n        if self.trace:\n            receipts: List[Any] = output[\"result\"][\"receipts\"]\n            traces: List[List[Dict]] = []\n            for i, r in enumerate(receipts):\n                h = r[\"transactionHash\"]\n                trace_file_name = f\"trace-{i}-{h}.jsonl\"\n                with open(\n                    os.path.join(temp_dir.name, trace_file_name), \"r\"\n                ) as trace_file:\n                    tx_traces: List[Dict] = []\n                    for trace_line in trace_file.readlines():\n                        tx_traces.append(json.loads(trace_line))\n                    traces.append(tx_traces)\n            self.append_traces(traces)\n\n        temp_dir.cleanup()\n\n        return (output[\"alloc\"], output[\"result\"], txs_rlp)\n\n    def version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\n        if self.cached_version is None:\n            result = subprocess.run(\n                [str(self.binary), \"-v\"],\n                stdout=subprocess.PIPE,\n            )\n\n            if result.returncode != 0:\n                raise Exception(\n                    \"failed to evaluate: \" + result.stderr.decode()\n                )\n\n            self.cached_version = result.stdout.decode().strip()\n\n        return self.cached_version\n\n    def is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>","text":"<p>Executes <code>evm t8n</code> with the specified arguments.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def evaluate(\n    self,\n    alloc: Any,\n    txs: Any,\n    env: Any,\n    fork: Fork,\n    chain_id: int = 1,\n    reward: int = 0,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Executes `evm t8n` with the specified arguments.\n    \"\"\"\n    fork_name = fork.name()\n    if eips is not None:\n        fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n    temp_dir = tempfile.TemporaryDirectory()\n\n    args = [\n        str(self.binary),\n        \"t8n\",\n        \"--input.alloc=stdin\",\n        \"--input.txs=stdin\",\n        \"--input.env=stdin\",\n        \"--output.result=stdout\",\n        \"--output.alloc=stdout\",\n        \"--output.body=txs.rlp\",\n        f\"--output.basedir={temp_dir.name}\",\n        f\"--state.fork={fork_name}\",\n        f\"--state.chainid={chain_id}\",\n        f\"--state.reward={reward}\",\n    ]\n\n    if self.trace:\n        args.append(\"--trace\")\n\n    stdin = {\n        \"alloc\": alloc,\n        \"txs\": txs,\n        \"env\": env,\n    }\n\n    encoded_input = str.encode(json.dumps(stdin))\n    result = subprocess.run(\n        args,\n        input=encoded_input,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    if result.returncode != 0:\n        raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n    output = json.loads(result.stdout)\n\n    if \"alloc\" not in output or \"result\" not in output:\n        raise Exception(\"malformed result\")\n\n    with open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\n        txs_rlp = txs_rlp_file.read().strip('\"')\n\n    if self.trace:\n        receipts: List[Any] = output[\"result\"][\"receipts\"]\n        traces: List[List[Dict]] = []\n        for i, r in enumerate(receipts):\n            h = r[\"transactionHash\"]\n            trace_file_name = f\"trace-{i}-{h}.jsonl\"\n            with open(\n                os.path.join(temp_dir.name, trace_file_name), \"r\"\n            ) as trace_file:\n                tx_traces: List[Dict] = []\n                for trace_line in trace_file.readlines():\n                    tx_traces.append(json.loads(trace_line))\n                traces.append(tx_traces)\n        self.append_traces(traces)\n\n    temp_dir.cleanup()\n\n    return (output[\"alloc\"], output[\"result\"], txs_rlp)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\n    if self.cached_version is None:\n        result = subprocess.run(\n            [str(self.binary), \"-v\"],\n            stdout=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\n                \"failed to evaluate: \" + result.stderr.decode()\n            )\n\n        self.cached_version = result.stdout.decode().strip()\n\n    return self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.is_fork_supported","title":"<code>is_fork_supported(_)</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/pytest_plugins/","title":"Pytest Plugins","text":""},{"location":"library/pytest_plugins/#pytest-framework-and-customizations","title":"Pytest Framework and Customizations","text":"<p>Package containing pytest plugins related to test filling.</p>"},{"location":"test_case_descriptions/eip4844/","title":"\ud83e\uddea Execution Specification Test Cases","text":"<p>Note: This is still a WIP but the tests can still be used by any client team. The priority levels (\ud83d\udd34, \ud83d\udfe0, \ud83d\udfe1, \ud83d\udfe2) represent very high, high, medium, low  priorities respectively.</p>"},{"location":"test_case_descriptions/eip4844/#datahash-opcode","title":"\ud83d\udcd6 Datahash Opcode","text":"<p>Test Module - <code>eip4844/datahash_opcode.py</code></p> <p>Verifies that the <code>DATAHASH</code> opcode, works as intended for a variety of contexts, retrieves the blob versioned hash correctly for a given index, returns the correct zeroed <code>bytes32</code> value for out-of-range indices, and consumes the correct amount of gas.</p> <p>1) \ud83d\udd34 test_datahash_opcode_contexts():</p> <p>Tests that the <code>DATAHASH</code> opcode functions correctly when called in different contexts including: - <code>DATAHASH</code> opcode on the top level of the call stack. - <code>DATAHASH</code> opcode on the max value. - <code>DATAHASH</code> opcode on <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, and <code>CALLCODE</code>. - <code>DATAHASH</code> opcode on Initcode. - <code>DATAHASH</code> opcode on <code>CREATE</code> and <code>CREATE2</code>. - <code>DATAHASH</code> opcode on transaction types 0, 1 and 2.</p> <p>2) \ud83d\udd34 test_datahash_blob_versioned_hash():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the correct versioned hash for various valid indexes. This test covers various scenarios with random <code>blob_versioned_hash</code> values within the valid range <code>[0, 2**256-1]</code>.</p> <p>3) \ud83d\udd34 test_datahash_invalid_blob_index():</p> <p>Tests that the <code>DATAHASH</code> opcode returns a zeroed <code>bytes32</code> value for invalid indexes. This test includes cases where the index is negative (<code>index &lt; 0</code>) or exceeds the maximum number of <code>blob_versioned_hash</code> values stored (<code>index &gt;= len(tx.message.blob_versioned_hashes)</code>). It confirms that the returned value is a zeroed <code>bytes32</code> value for these cases.</p> <p>4) \ud83d\udfe0 test_datahash_gas_cost():</p> <p>Asserts the gas consumption of the <code>DATAHASH</code> opcode is correct by ensuring it matches <code>HASH_OPCODE_GAS = 3</code>. It includes both valid and invalid random index sizes from the range <code>[0, 2**256-1]</code>, for tx types 2 and 3.</p> <p>5) \ud83d\udfe1 test_datahash_multiple_txs_in_block():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the appropriate values when there is more than one blob tx type within a block (for tx types 2 and 3). Scenarios involve tx type 3 followed by tx type 2 running the same code within a block. In this case <code>DATAHASH</code> returns 0, but for the opposite scenario <code>DATAHASH</code> returns the correct <code>blob_versioned_hash</code>.</p>"},{"location":"test_case_descriptions/eip4844/#excess-data-gas","title":"\ud83d\udcbd\u26fd\ud83d\udcb8 Excess Data Gas","text":"<p>Test Module - <code>eip4844/excess_data_gas.py</code></p> <p>Predominantly verifies that <code>excess_data_gas</code> &amp; <code>data_gasprice</code> are calculated correctly ensuring both valid and invalid transactions are processed accordingly. Extra verification is added specifically for invalid blob transactions when the <code>max_fee_per_data_gas</code>, number of blobs or transaction type are errorneous. </p> <p>1) \ud83d\udd34 test_excess_data_gas_calculation():</p> <p>Tests that the <code>excess_data_gas</code> is calculated correctly within a single block for various contexts, where the <code>parent.excess_data_gas</code> and the proposed block <code>excess_data_gas</code> have a variety of values. The excess data gas is calculated using the following formula:</p> <pre><code>def calc_excess_data_gas(parent: Header, new_blobs: int) -&gt; int:\n    consumed_data_gas = new_blobs * DATA_GAS_PER_BLOB\n    if parent.excess_data_gas + consumed_data_gas &lt; TARGET_DATA_GAS_PER_BLOCK:\n        return 0\n    else:\n        return parent.excess_data_gas + consumed_data_gas - TARGET_DATA_GAS_PER_BLOCK\n</code></pre> <p>For blocks to be valid in these contexts they must meet the following conditions of the EIP:   - Each block can only have a maximum of <code>MAX_BLOBS_PER_BLOCK</code>.   - A type 5 blob transaction must have at least one blob - <code>len(versioned_hashes) &gt; 0</code>.   - The user is open to paying the current data gasprice for the transaction -<code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code>   - The account used for the blob transaction must have enough balance - <code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> <p>2) \ud83d\udd34 test_invalid_excess_data_gas_in_header():</p> <p>Asserts that blocks with invalid <code>excess_data_gas</code> values in the header are ignored, ensuring the blob transaction is rejected and no state changes occur. The invalidity of <code>excess_data_gas</code> within a new block header is tested across the following scenarios:</p> <ul> <li> <p><code>excess_data_gas</code> decreases or increases by <code>TARGET_DATA_GAS_PER_BLOCK + 1</code> in a single block. Note that the EIP only allows <code>excess_data_gas</code> to decrease &amp; increase by a maximum of <code>TARGET_DATA_GAS_PER_BLOCK</code>.</p> </li> <li> <p><code>excess_data_gas</code> is unchanged when the number of blobs in the proposed block doesn't equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are different from the target, <code>excess_data_gas</code> must change. </p> </li> <li> <p><code>excess_data_gas</code> is changed when the number of blobs in the proposed block does equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are equal to the target,<code>excess_data_gas</code> must remain the same value - <code>parent_excess_data_gas</code>.</p> </li> <li> <p><code>excess_data_gas</code> is less than the <code>TARGET_DATA_GAS_PER_BLOCK</code> when the parent has 0 blobs (<code>parent.excess_data_gas</code> = 0), and the calculated excess is non-zero. This is invalid as the first condition in the excess data gas calculation must be met, and hence return zero for this case. </p> </li> <li> <p><code>excess_data_gas</code> is a value greater than <code>2**256-1</code>. It must be a value that fits within 256-bits.</p> </li> </ul> <p>3) \ud83d\udd34 test_fork_transition_excess_data_gas_in_header():</p> <p>Tests that the <code>excess_data_gas</code> calculation is correct when transitioning from the Shanghai fork to the Cancun fork, where appended blocks are valid and state changes occur. Each block has a single transaction with <code>MAX_BLOBS_PER_BLOCK</code> blobs. The first block during the transition period has a parent of zero <code>excess_data_gas</code> in the header. Each block afterwards calculates <code>excess_data_gas</code> using the following <code>calc_excess_data_gas</code> function such that it continuously increases.</p> <p>4) \ud83d\udd34 test_invalid_blob_txs():</p> <p>Asserts that blocks with invalid blob transactions are rejected and no state changes occur. This is tested across the following scenarios:</p> <ul> <li><code>max_fee_per_data_gas</code> is less than the required <code>data_gasprice</code> for a set number of excess blobs. This is invaild as a valid block must obey the following condition:</li> <li> <p><code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> is greater than the required <code>data_gasprice</code> for a set number of excess blobs but the account doesn't have the required balance to cover the total cost of the transaction. A valid block must prove true for the following condition: </p> </li> <li> <p><code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> has an invalid value of zero. This value is invalid as it is less than <code>MIN_DATA_GASPRICE = 1</code>.</p> </li> <li> <p><code>len(blobs)</code> is greater than <code>MAX_BLOBS_PER_BLOCK =  MAX_DATA_GAS_PER_BLOCK // DATA_GAS_PER_BLOB</code> in a single transaction within one block. There cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(wrapper.tx.message)</code> is greater that <code>MAX_BLOBS_PER_BLOCK</code> but with <code>len(blobs) = 1</code> for each transaction. As before there cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(blobs)</code> is zero within a transaction. Valid blob txs (type 3) must have at least one blob within it, obeying the following condition:</p> </li> <li> <p><code>len(tx.message.blob_versioned_hashes) &gt; 0</code></p> </li> <li> <p>Blob transaction type 3 is used in a pre-Cancun fork. This transcation type can only be used in a post-Cancun fork.</p> </li> </ul>"},{"location":"tutorials/blockchain/","title":"Blockchain Tests","text":"<p>This tutorial teaches you to create a blockchain execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will process given blocks and arrive at a defined post-state.</p>"},{"location":"tutorials/blockchain/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a blockchain test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> <li>Understand how to write an execution spec state transition test.</li> </ul>"},{"location":"tutorials/blockchain/#example-tests","title":"Example Tests","text":"<p>In this tutorial we will go over [test_block_number] in <code>block_example.py</code>(https://github.com/ethereum/execution-spec-tests/tree/main/fillers/example/block_example.py#L19).</p> <p>It is assumed you have already gone through the state transition test tutorial. Only new concepts will be discussed.</p>"},{"location":"tutorials/blockchain/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is defined that is called by each transaction in the test. It stores a pointer to storage at <code>storage[0]</code>. When it is called storage cell <code>0</code> gets the current block number, and the pointer is incremented to the next value.</p> <pre><code>contract_addr: Account(\n    balance=1000000000000000000000,\n    code=Yul(\n\"\"\"\n        {\n            let next_slot := sload(0)\n            sstore(next_slot, number())\n            sstore(0, add(next_slot, 1))\n        }\n        \"\"\"\n    ),\n    storage={\n        0x00: 0x01,\n    },\n),\n</code></pre>"},{"location":"tutorials/blockchain/#transaction-generator","title":"Transaction Generator","text":"<p>The transactions used in this test are nearly identical. Their only different is the <code>nonce</code> value which needs to be incremented. </p> <pre><code>def tx_generator():\n    nonce = 0  # Initial value\n    while True:\n        tx = Transaction(\n            ty=0x0,\n            chain_id=0x0,\n            nonce=nonce,\n            to=contractAddr,\n            gas_limit=500000,\n            gas_price=10,\n        )\n        nonce = nonce + 1\n        yield tx\n\ntx_generator = tx_generator()\n</code></pre> <p>This looks like an infinite loop but it isn't because this is a generator function. When generator encounters the <code>yield</code> keyword it returns the value and stops execution, keeping a copy of all the local variables, until it is called again. Hence infinite loops inside a generator are not a problem as long as they include <code>yield</code>. This code section is responsible for creating the <code>Transaction</code> object and incrementing the <code>nonce</code>.</p> <p>Every time the function <code>tx_generator()</code> is called, it returns a new generator with a <code>nonce</code> of zero. To increment the <code>nonce</code> we need to use the same generator. We assign this generator to <code>tx_generator</code>.</p>"},{"location":"tutorials/blockchain/#blocks","title":"Blocks","text":"<p>Each integer in the <code>tx_per_block</code> array is the number of transactions in a block. The genesis block is block 0 (no transactions). It follows that we have 2 transactions in block 1, 0 in block two, 4 in block 3, ..., and 50 in block 9.</p> <pre><code>tx_per_block = [2, 0, 4, 8, 0, 0, 20, 1, 50]\n</code></pre> <p>The code section that creates the blocks is a bit complex in this test. For some simpler definitions of Block creation you can browse tests within <code>withdrawals.py</code>.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list(map(lambda x: next(tx_generator), range(len)))\n    ),\n    tx_per_block,\n)\n</code></pre> <p>We use <code>lambda</code> notation to specify short functions. In this case, the function doesn't actually care about its input, it just returns the next transaction from the generator.</p> <pre><code>lambda x: next(tx_generator)\n</code></pre> <p>Python uses <code>range(n)</code> to create a list of numbers from <code>0</code> to <code>n-1</code>. Among other things, it's a simple way to create a list of <code>n</code> values.</p> <pre><code>range(len)\n</code></pre> <p>The <code>map</code> function runs the function (the first parameter) on every element of the list (the second parameter). Putting together what we know, it means that it runs <code>next(tx_generator)</code> <code>len</code> times, giving us <code>len</code> transactions. We then use <code>list</code> to turn the transactions into a list that we can provide as the <code>txs</code> parameter to the <code>Block</code> constructor.</p> <pre><code>list(map(lambda x: next(tx_generator), range(len)))\n</code></pre> <p>The outer <code>lambda</code> function takes an integer, <code>len</code>, and creates a <code>Block</code> object with <code>len</code> transactions. This function is then run on every value of <code>tx_per_block</code> to generate the blocks.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list of len transactions\n    ),\n    tx_per_block,\n)\n</code></pre> <p>For example, if we had <code>tx_per_block = [0,2,4]</code>, we'd get this result:</p> <pre><code>blocks = [\n    Blocks(txs=[]),\n    Blocks(txs=[next(tx_generator), next(tx_generator)]),\n    Blocks(txs=[next(tx_generator), next(tx_generator), next(tx_generator), next(tx_generator)])        \n]\n</code></pre>"},{"location":"tutorials/blockchain/#post-state","title":"Post State","text":"<p>Recall that storage slot 0 retains the value of the next slot that the block number is written into. It starts at one and is incremented after each transaction. Hence it's the total number of transactions plus 1.</p> <pre><code>storage = {0: sum(tx_per_block) + 1}\n</code></pre> <p>For every block and transaction within the block, we write the block number and increment the next slot number in storage slot 0. As Python lists are 0 indexed, we must increment the block number by 1.</p> <pre><code>next_slot = 1\nfor blocknum in range(len(tx_per_block)):\n    for _ in range(tx_per_block[blocknum]):\n        storage[next_slot] = blocknum + 1\n        next_slot = next_slot + 1\n</code></pre> <p>Now that the expeced storage values are calculated, the post state can be defined and yielded within the <code>BlockchainTest</code>, synonymous to the state test example.</p> <pre><code>post = {contract_addr: Account(storage=storage)}\n\nyield BlockchainTest(\n    genesis_environment=env,\n    pre=pre,\n    blocks=blocks,\n    post=post,\n)\n</code></pre> <p>Note that because of the <code>yield</code> we could have multiple tests under the same name.</p>"},{"location":"tutorials/blockchain/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to write blockchain tests.</p>"},{"location":"tutorials/state_transition/","title":"State Transition Tests","text":"<p>This tutorial teaches you to create a state transition execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will reach a specified post-state after executing a set of specific transactions.</p>"},{"location":"tutorials/state_transition/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a static state transition test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> </ul>"},{"location":"tutorials/state_transition/#example-tests","title":"Example Tests","text":"<p>The most effective method of learning how to write tests is to study a couple of straightforward examples. In this tutorial we will go over the Yul state test.</p>"},{"location":"tutorials/state_transition/#yul-test","title":"Yul Test","text":"<p>You can find the source code for the Yul test here. It is the spec test equivalent of this static test. </p> <p>Lets examine each section.</p> <pre><code>\"\"\"\nTest Yul Source Code Examples\n\"\"\"\n</code></pre> <p>In Python, multi-line strings are denoted using <code>\"\"\"</code>. As a convention, a file's purpose is often described in the opening string of the file.</p> <pre><code>from ethereum_test_forks import Berlin, Fork, forks_from\nfrom ethereum_test_tools import (\n    Account,\n    Environment,\n    StateTestFiller,\n    TestAddress,\n    Transaction,\n    Yul,\n)\n</code></pre> <p>In this snippet the required constants, types and helper functions are imported from <code>ethereum_test_tools</code> and <code>ethereum_test_forks</code>. We will go over these as we come across them.</p> <pre><code>@pytest.mark.parametrize(\"fork\", forks_from(Berlin))\n</code></pre> <p>In Python this kind of definition is called a decorator. It modifies the action of the function after it. In this case, the decorator is a pytest fixture that parametrizes the test for the Berlin fork and the forks after it.</p> <pre><code>def test_yul(state_test: StateTestFiller, fork: Fork):\n\"\"\"\n    Test YUL compiled bytecode.\n    \"\"\"\n</code></pre> <p>This is the format of a Python function. It starts with <code>def &lt;function name&gt;(&lt;parameters&gt;):</code>, and then has indented code for the function. The function definition ends when there is a line that is no longer indented. As with files, by convention functions start with a string that explains what the function does.</p> <p>Info</p> <p>To execute this test for all the specified forks, we can specify pytest's <code>-k</code> flag that filters test cases by keyword expression: <pre><code>pytest -k test_yul\n</code></pre> To execute it for a specific fork, the fork name can be combined in a Python evaluatable expression using <code>and</code> in the string: <pre><code>pytest -k \"test_yul and Shanghai\"\n</code></pre></p> <p>The <code>state_test</code> function argument</p> <p>This test defines a state test and, as such, must include the <code>state_test</code> in its function arguments. This is a callable object (actually a wrapper class to the <code>StateTest</code>); we will see how it is called later.</p> <pre><code>    env = Environment()\n</code></pre> <p>This line specifies that <code>env</code> is an <code>Environment</code> object, and that we just use the default parameters. If necessary we can modify the environment to have different block gas limits, block numbers, etc. In most tests the defaults are good enough.</p> <p>For more information, see the static test documentation.</p>"},{"location":"tutorials/state_transition/#pre-state","title":"Pre State","text":"<pre><code>    pre = {\n</code></pre> <p>Here we define the pre-state section, the one that tells us what is on the \"blockchain\" before the test. It is a dictionary, which is the Python term for an associative array.</p> <pre><code>        \"0x1000000000000000000000000000000000000000\": Account(\n</code></pre> <p>The keys of the dictionary are addresses (as strings), and the values are <code>Account</code> objects. You can read more about address fields in the static test documentation. </p> <pre><code>            balance=0x0BA1A9CE0BA1A9CE,\n</code></pre> <p>This field is the balance: the amount of Wei that the account has. It usually doesn't matter what its value is in the case of state test contracts.</p> <pre><code>            code=Yul(\n</code></pre> <p>Here we define the Yul code for the contract. It is defined as a multi-line string and starts and ends with curly braces (<code>{ &lt;yul&gt; }</code>).</p> <p>When running the test filler <code>tf</code> the solidity compiler <code>solc</code> will automatically translate the Yul to EVM opcode at runtime. </p> <p>Note</p> <p>Currently Yul and direct EVM opcode are supported in execution spec tests. LLL and Solidity may be supported in the future.</p> <pre><code>                \"\"\"\n                {\n                    function f(a, b) -&gt; c {\n                        c := add(a, b)\n                    }\n                    sstore(0, f(1, 2))\n                    return(0, 32)\n                }\n                \"\"\"\n            ),\n        ),\n</code></pre> <p>Within this example test Yul code we have a function definition, and inside it we are using the Yul <code>add</code> instruction. When compiled with <code>solc</code> it translates the instruction directly to the<code>ADD</code> opcode. For further Yul instructions see here. Notice that function is utilised with the Yul <code>sstore</code> instruction, which stores the result of <code>add(1, 2)</code> to the storage address <code>0x00</code>.</p> <p>Generally for execution spec tests the <code>sstore</code> instruction acts as a high-level assertion method to check pre to post-state changes. The test filler achieves this by verifying that the correct value is held within post-state storage, hence we can validate that the Yul code has run successfully.</p> <pre><code>        TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n    }\n</code></pre> <p><code>TestAddress</code> is an address for which the test filler has the private key. This means that the test runner can issue a transaction as that contract. Of course, this address also needs a balance to be able to issue transactions.</p>"},{"location":"tutorials/state_transition/#transactions","title":"Transactions","text":"<pre><code>    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=\"0x1000000000000000000000000000000000000000\",\n        gas_limit=500000,\n        gas_price=10,\n        protected=False,\n    )\n</code></pre> <p>With the pre-state specified, we can add a description for the <code>Transaction</code>. For more information, see the static test documentation</p>"},{"location":"tutorials/state_transition/#post-state","title":"Post State","text":"<pre><code>    post = {\n        \"0x1000000000000000000000000000000000000000\": Account(\n            storage={\n                0x00: 0x03,\n            },\n        ),\n    }\n</code></pre> <p>This is the post-state which is equivalent to <code>expect</code> in static tests, but without the indexes. It is similar to the pre-state, except that we do not need to specify everything, only those accounts and fields we wish to test.</p> <p>In this case, we look at the storage of the contract we called and add to it what we expect to see. In this example storage cell <code>0x00</code> should be <code>0x03</code> as in the pre-state we essentially stored the result of the Yul instruction <code>add(1, 2)</code>.</p>"},{"location":"tutorials/state_transition/#state-test","title":"State Test","text":"<pre><code>    state_test(env=env, pre=pre, post=post, txs=[tx])\n</code></pre> <p>This line calls the wrapper to the <code>StateTest</code> object that provides all the objects required (for example, the fork parameter) in order to fill the test, generate the test fixtures and write them to file (by default, <code>../out/example/yul_example/test_yul.json</code>).</p>"},{"location":"tutorials/state_transition/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to state transition tests within a single block.</p>"},{"location":"tutorials/state_transition_bad_opcode/","title":"State transition bad opcode","text":""},{"location":"tutorials/state_transition_bad_opcode/#bad-opcode-test","title":"Bad Opcode Test","text":"<p>The source code for this test is here. We will only go over the parts that are new.</p> <p>We use Python string templates, so we need to import that library.</p> <pre><code>from string import Template\n</code></pre> <p>In this test we need a couple of addresses, so we create them here. Python lets us specify <code>&lt;string&gt;*&lt;number&gt;</code> when we need a string repeated multiple times, which makes for more readable code than <code>0x00...000C0DE</code>.</p> <pre><code>    code_addr = \"0x\" + \"0\"*(40-4) + \"C0DE\"\n    goat_addr = \"0x\" + \"0\"*(40-4) + \"60A7\"\n</code></pre> <p>We create <code>env</code> and <code>tx</code> first because they are constant. This function will <code>yield</code> multiple tests, but always with the same <code>env</code> and <code>tx</code> values.</p> <pre><code>    env = Environment()\n\n    tx = Transaction(\n           .\n           .\n           .\n        )\n</code></pre> <p>Here we create two post states. We will use whichever one is appropriate to the test we create.</p> <pre><code>    post_valid = {\n       code_addr: Account(\n         storage={0x00: 1},\n       ),\n    }\n\n    post_invalid = {\n       code_addr: Account(\n         storage={0x00: 0},\n       ),\n    }\n</code></pre> <p>Here we define a function (<code>opc_valid</code>) inside another function. Python supports this, and it has two advantages:</p> <ul> <li>Avoid namespace pollution by restricting the function to where it is needed.</li> <li>Functions defined inside other functions can use the parameters and local variables of those functions.   In this case, we need to use <code>fork</code>.</li> </ul> <pre><code>    # Check if an Opcode is valid\n    def opc_valid(opc):\n\"\"\"\n        Return whether opc will be evaluated as valid by the test or not.\n        Note that some opcodes are evaluated as invalid because the way they act\n        \"\"\"\n</code></pre> <p>This is the syntax for Python comments, <code># &lt;rest of the line&gt;</code>. </p> <pre><code>        # PUSH0 is only valid Shanghai and later\n</code></pre> <p>Opcode 0x5F (<code>PUSH0</code>) is only valid starting with the Shangai fork. We don't know what will be the fork names after Shanghai, so it is easiest to specify that prior to Shanghai it is invalid. We don't need to worry about forks prior to London because the decorator for this test says it is only valid from London.</p> <pre><code>        if fork in {\"london\", \"merge\"} and opc==0x5F:\n</code></pre> <p>Python has a set data structure. We use this structure when the order of the values are irrelevant, and we just want to be able to check if something is a member or not.</p> <p>Note that <code>if</code> statements are also followed by a colon (<code>:</code>) and the code inside them indented. That is the general Python syntax.</p> <pre><code>            return False\n</code></pre> <p>Boolean values in Python are either <code>True</code> or <code>False</code>.</p> <p>This test works by running an opcode and then does a <code>SSTORE</code>. Opcodes that terminate execution, such as <code>STOP</code> and <code>RETURN</code> also cause the <code>SSTORE</code> not to happen, so they must be treated as invalid. The same is true for <code>JUMP</code>.</p> <pre><code>        # Valid opcodes, but they are terminal, and so cause\n        # the SSTORE not to happen\n        if opc in {0x00, 0xF3, 0xFD, 0xFF}:\n            return False\n\n\n        # Jumps. If you jump to a random location, you skip the SSTORE\n        if opc in {0x56}:\n            return False\n</code></pre> <p>Next we return <code>True</code> for supported opcodes.</p> <pre><code>        # Opcodes that aren't part of a range\n        # 0x20 - SHA3\n        # 0xFA - STATICCALL\n        if opc in {0x20, 0xFA}:\n            return True\n</code></pre> <p>In Python, as in math, you can use <code>a &lt; b &lt; c</code> for <code>a &lt; b and b &lt; c</code>.</p> <pre><code>        # Arithmetic opcodes\n        if 0x01 &lt;= opc &lt;= 0x0b:\n            return True\n\n        .\n        .\n        .\n</code></pre> <p>The last part the function returns <code>False</code>. If we got here, then this is not a valid opcode.</p> <pre><code>        return False\n        # End of opc_valid\n</code></pre> <p>As this is the end of the function, the next code line is unindented (compared to the function definition code).</p> <p>This is a <code>for</code> loop. For loops iterate over a sequnce, and the <code>range</code> function, in this case, gives us the range 0..255. As with functions and <code>if</code> statements, the <code>for</code> loop has a colon and includes the indented code.</p> <pre><code>    # For every possible opcode\n    for opc in range(256):\n</code></pre> <p>We have two post states.  One, <code>post_valid</code>, has the value of <code>1</code> in storage location <code>0</code>. The other, <code>post_invalid</code> has the value of <code>0</code> in storage location <code>0</code>. But <code>SELFDESTRUCT</code> destroys the contract so there is no longer an account at that address.  Neither is valid, so we just skip that test case.</p> <pre><code>        # We can't check SELFDESTRUCT using this technique\n        if opc in {0xFF}:\n           continue\n</code></pre> <p>We need the opcode in hexadecimal.  The function <code>hex</code> gives us the hexadecimal number in hex. However, it also gives us a <code>0x</code> prefix, which we don't want, so we use a slice to remove the first two characters.</p> <pre><code>        opc_hex = hex(opc)[2:]\n</code></pre> <p>We need <code>opc_hex</code> to be two characters. If the length is only one, prepend a zero.</p> <pre><code>        if len(opc_hex) == 1:\n          opc_hex = \"0\" + opc_hex\n</code></pre> <p>This is a <code>Template</code> string. This means we'll be able to substitute template variables (<code>${&lt;var name&gt;}</code>) with values to produce the actual code.</p> <pre><code>        yul_code = Template(\"\"\"\n        {\n</code></pre> <p>We start with a call <code>0x00...0060A7</code> (a.k.a. <code>goat_addr</code>) so we'll have some return data. Otherwise, <code>RETURNDATACOPY</code> will fail and appear like it is not an opcode.</p> <pre><code>           pop(call(gas(), 0x60A7, 0, 0, 0, 0, 0))\n\n           // fails on opcodes with &gt;20 inputs\n           // (currently dup16, at 17 inputs, is the\n           // one that goes deepest)\n           //\n           // Follow with 32 NOPs (0x5B) to handle PUSH, which has an immediate\n           // operand\n</code></pre> <p>Opcodes can have two types of operands:</p> <ul> <li>Immediate operands, which are part of the bytecode.   For example, <code>6001</code> is <code>PUSH1</code> with the value <code>0x01</code>.</li> <li>Implied operands (a.k.a. stack operands), which come from the stack.</li> </ul> <p>This <code>verbatim</code> code provides both operand types. The code, <code>${opcode}${nop32}</code> is the opcode we are testing, followed by 32 copies of 0x5B. When <code>0x5B</code> is not used as an operand, it is <code>JUMPDEST</code> and does nothing.</p> <pre><code>           verbatim_20i_0o(hex\"${opcode}${nop32}\",\n</code></pre> <p>The opcode string is followed by the input parameters (in this case, twenty of them). These can be Yul expressions, but for the sake of simplicity here we just use constant values.</p> <pre><code>              0x00, 0x00, 0x00, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF)\n</code></pre> <p>If the opcode terminates the smart contract execution (as invalid opcodes do), we don't get here. If we do get here, write to storage cell <code>0x00</code> to record that fact.</p> <p>Note the syntax <code>let &lt;var&gt; := &lt;value&gt;</code>. This is how you specify variables in Yul.</p> <pre><code>           // We only get here is the opcode is legit (and it doesn't terminate\n           // execution like STOP and RETURN)\n           let zero := 0\n           let one := 1\n           sstore(zero, one)\n        }\n</code></pre> <p>Replace <code>${opcode}</code> with the one byte hex code, and <code>${nop32}</code> with 32 copies of <code>5b</code> (for NOP).</p> <pre><code>        \"\"\").substitute(opcode=opc_hex, nop32=\"5B\"*32)\n        pre = {\n           TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n           codeAddr: Account(\n        balance=0,\n        nonce=1,\n        code=Yul(yul_code)\n           ),\n</code></pre> <p>This is the account for <code>0x00..0060A7</code>.  It just returns data (all zeros).</p> <pre><code>           goat_addr: Account(\n                balance=0,\n                nonce=1,\n                code=Yul(\"{ return(0, 0x100) }\"),\n           )\n        }\n</code></pre> <p>Every time the <code>for</code> loop gets here, it <code>yields</code> a separate test.  Over the entire for loop, it yields 255 different tests.</p> <pre><code>    yield StateTest(\n        env=env, \n        pre=pre, \n        txs=[tx],\n        post=(post_valid if opc_valid(opc) else post_invalid),\n    )\n</code></pre> <p>The Python format for the ternary operation is a bit different from C-like languages. In C like languages the syntax is <code>&lt;condition&gt; ? &lt;yes value&gt; : &lt;no value&gt;</code>. In Python it is <code>&lt;yes value&gt; if &lt;condition&gt; else &lt;no value&gt;</code>.</p>"},{"location":"writing_tests/","title":"Writing Tests","text":"<p>The best way to get started is to use one of the existing test modules for inspiration. A good simple example is fillers.example.acl_example.test_access_list.</p> <p>Please check that your code adheres to the repo's Coding Standards and read the other pages in this section for more background and an explanation of how state transition and blockchain tests work.</p>"},{"location":"writing_tests/adding_a_new_test/","title":"Adding a New Test","text":"<p>All test cases are located in the <code>fillers</code> directory, which is composed of many subdirectories, each one represents a different test category. The sub-directories may contain sub-categories, if necessary.</p> <pre><code>\ud83d\udcc1 execution-test-specs/\n\u251c\u2500\u2574\ud83d\udcc1 fillers/                   # test cases\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 eips/\n\u2502   |    \u251c\u2500\u2500 \ud83d\udcc1 eip4844/\n|   |    |    \u251c\u2500\u2500 \ud83d\udcc4 datahash_opcode.py\n|   |    |    \u2514\u2500\u2500 \ud83d\udcc4 excess_data_gas.py\n|   |    \u251c\u2500\u2500 \ud83d\udcc4 eip3855.py\n|   |    \u2514\u2500\u2500 \ud83d\udcc4 eip3860.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 example/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 security/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 vm/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 withdrawals/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 ...\n</code></pre> <p>Each category/sub-directory may have multiple Python test modules (<code>*.py</code>) which in turn may contain many test functions. The test functions themselves are always parametrized by fork, although when new tests are added for a feature under development, they will only be valid for the fork under active development.</p> <p>Look for a relevant test category and add new tests to this category, if appropriate.</p> <p>A new test can be added by either:</p> <ul> <li>Adding a new <code>test_</code> python function to an existing file in any of the   existing category subdirectories within <code>fillers</code>.</li> <li>Creating a new source file in an existing category, and populating it with   the new test function(s).</li> <li>Creating an entirely new category by adding a subdirectory in   <code>fillers</code> with the appropriate source files and test functions.</li> </ul>"},{"location":"writing_tests/code_standards/","title":"Code Standards","text":"<p>The Python code in the tests subdirectory <code>./fillers</code> must fulfill the following checks:</p> <ol> <li><code>fname8 fillers</code> - spell check passes using the <code>./whitelist.txt</code> dictionary file.</li> <li><code>isort fillers --check --diff</code> - Python imports ordered and arranged according to <code>isort</code>'s standards.</li> <li><code>black fillers --check --diff</code> - Python source must be black-formatted.</li> <li><code>flake8 fillers</code> - Python lint checked.</li> <li><code>mypy fillers</code> - Objects that provide typehints pass type-checking via <code>mypy</code>.</li> <li><code>pytest</code> - All tests fillers must execute correctly.</li> <li><code>mkdocs build --strict</code> - Documentation generated without warnings.</li> </ol> <p>While this seems like a long list, a correctly configured editor (see VS Code Setup) essentially assures:</p> <ol> <li>Points 2 and 3 are automatically covered.</li> <li>Points 1, 4 &amp; 5 are mostly covered. Additionally, if you skip type hints, they won't be checked; we can help you add these in the PR.</li> </ol> <p>These checks must pass in order for the execution-spec-tests Github Actions to pass upon pushing to remote. </p> <p>Running the checks with tox</p> <p>All these checks can be executed locally in a single command, <code>tox</code>, see Verifying Changes. </p> <p>If you need help, get in touch!</p>"},{"location":"writing_tests/reference_specification/","title":"Referencing an EIP Spec Version","text":"<p>An Ethereum Improvement Proposal (from ethereum/EIPs) and its SHA digest can be directly referenced within a python test module in order to check whether the test implementation could be out-dated. If the SHA of the file in the remote repo changes, the test framework will issue a warning in its summary section.</p> <p>Test cases located underneath <code>./fillers/eips/</code> must define a reference spec version.</p> <p></p> <p>The SHA value is the output from git's <code>hash-object</code> command, for example: <pre><code>git clone git@github.com:ethereum/EIPs\ngit hash-object EIPS/EIPS/eip-3651.md\n# output: d94c694c6f12291bb6626669c3e8587eef3adff1\n</code></pre> and can be retrieved from the remote repo via the Github API on the command-line as following: <pre><code>sudo apt install jq\ncurl -s -H \"Accept: application/vnd.github.v3+json\" \\\nhttps://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-3651.md |\\\njq -r '.sha'\n# output: d94c694c6f12291bb6626669c3e8587eef3adff1\n</code></pre></p>"},{"location":"writing_tests/reference_specification/#how-to-add-a-spec-version-check","title":"How to Add a Spec Version Check","text":"<p>This check accomplished by adding the following two global variables anywhere in the Python source file:</p> Variable Name Explanation <code>REFERENCE_SPEC_GIT_PATH</code> The relative path of the EIP markdown file in the ethereum/EIPs repository, e.g. \"<code>EIPS/eip-1234.md</code>\" <code>REFERENCE_SPEC_VERSION</code> The SHA hash of the latest version of the file retrieved from the Github API:<code>https://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-&lt;EIP Number&gt;.md</code>"},{"location":"writing_tests/reference_specification/#example","title":"Example","text":"<p>Here is an example from ./fillers/eips/eip3651.py:</p> <p><pre><code>REFERENCE_SPEC_GIT_PATH = \"EIPS/eip-3651.md\"\nREFERENCE_SPEC_VERSION = \"d94c694c6f12291bb6626669c3e8587eef3adff1\"\n</code></pre> The SHA digest was retrieved from here.</p>"},{"location":"writing_tests/types_of_tests/","title":"Types of tests","text":"<p>There are currently two types of tests that can be produced by a test spec:</p> <ol> <li>State Tests</li> <li>Blockchain Tests</li> </ol>"},{"location":"writing_tests/types_of_tests/#state-tests","title":"State Tests","text":"<p>State tests span a single block and, ideally, a single transaction. For example:</p> <ul> <li>Test a single opcode behavior.</li> <li>Verify opcode gas costs.</li> <li>Test interactions between multiple smart contracts.</li> <li>Test creation of smart contracts.</li> </ul>"},{"location":"writing_tests/types_of_tests/#blockchain-tests","title":"Blockchain Tests","text":"<p>Blockchain tests span multiple blocks which may or may not contain transactions and mainly focus on the block to block effects to the Ethereum state. For example:</p> <ul> <li>Verify system-level operations such as coinbase balance updates or withdrawals.</li> <li>Verify fork transitions.</li> <li>Verify blocks with invalid transactions/properties are rejected.</li> </ul>"},{"location":"writing_tests/types_of_tests/#fork-transition-tests","title":"Fork Transition Tests","text":"<p>There is a special type of blockchain test that is used to test a fork transition. It's execution is not parametrized for all possible forks; it targets exactly the blocks at the point of transition from one evm implementation to the next. This type of test must be parametrized using a special fork, for example, <code>ShanghaiToCancunAtTime15k</code>.</p>"},{"location":"writing_tests/verifying_changes/","title":"Verifying Changes","text":"<p>The <code>tox</code> tool can be used to lint, type check, test and verify that documentation is correctly generated. The <code>tox</code> tool can be executed locally to check that local changes won't cause Github Actions Checks to fail.</p> <p>There are two tox environments available, one for the fillers/test cases (<code>fillers</code>) and one for the framework (<code>py3</code>).</p> <p>Tox Virtual Environment</p> <p>The checks performed by <code>tox</code> are sandboxed in their own virtual environments (which are created automatically in the <code>.tox/</code> subdirectory). These can be used to debug errors encountered during <code>tox</code> execution.</p> <p>Whilst we create a virtual environment in the code snippets below, they are only to install the tox tool itself.</p>"},{"location":"writing_tests/verifying_changes/#filler-verification-fillers","title":"Filler Verification: <code>fillers</code>","text":"<p>Prerequisite: <pre><code>python -m venv ./venv/\nsource ./venv/bin/activate\npip install tox\n</code></pre> Verify: <pre><code>tox -e fillers\n</code></pre></p>"},{"location":"writing_tests/verifying_changes/#framework-verification-py3","title":"Framework Verification: <code>py3</code>","text":"<p>Prerequisite: <pre><code>python -m venv ./venv/\nsource ./venv/bin/activate\npip install tox\n</code></pre> Verify: <pre><code>tox -e py3\n</code></pre></p>"},{"location":"writing_tests/writing_a_new_test/","title":"Writing a New Test","text":""},{"location":"writing_tests/writing_a_new_test/#test-functions","title":"Test Functions","text":"<p>Every test spec is a python function that defines a single <code>StateTest</code>/<code>BlockchainTest</code> object.</p> <p>Every test function must:</p> <ol> <li>Use one of <code>state_test</code> or <code>blockchain_test</code> in its function arguments.</li> <li>Call the <code>state_test</code> respectively <code>blockchain_test</code> object within the test function body.</li> <li>Be parametrized by the forks for which it is to be tested.</li> </ol> <p>If the test module is located underneath the <code>./fillers/eips/</code> directory, the test module must additionally:</p> <ol> <li>Add a reference version of the EIP spec under test, see Referencing an EIP Spec Version.</li> </ol>"},{"location":"writing_tests/writing_a_new_test/#the-state_test-and-blockchain_test-test-function-arguments","title":"The <code>state_test</code> and <code>blockchain_test</code> test function arguments.","text":"<p>The test function's signature must contain exactly one of either a <code>state_test</code> or <code>blockchain_test</code> argument.</p> <p>For example, for state tests: <pre><code>def test_access_list(state_test: StateTestFiller):\n</code></pre> and for blockchain tests: <pre><code>def test_contract_creating_tx(\n    blockchain_test: BlockchainTestFiller, fork: Fork, initcode: Initcode\n):\n</code></pre></p> <p>The <code>state_test</code> and <code>blockchain_test</code> objects are actually wrapper classes to the <code>StateTest</code>, respectively <code>BlockchainTest</code> objects, that once called actually instantiate a new instance of these objects and fill the test case using the <code>evm</code> tool according to the pre and post states and the transactions defined within the test.</p>"},{"location":"writing_tests/writing_a_new_test/#parametrization-by-fork","title":"Parametrization By Fork","text":"<p>The test function must be parametrized by the forks for which it is to be tested. This is achieved by applying the <code>pytest.mark.parametrize</code> decorator on either the test function, test class or test module level:</p> FunctionClassModule <pre><code>import pytest\n\nfrom ethereum_test_forks import forks_from_until, Berlin, London\n\n@pytest.mark.parametrize(\"fork\", forks_from_until(Berlin, London))\ndef test_access_list(state_test: StateTestFiller, fork: Fork):\n</code></pre> <pre><code>import pytest\n\nfrom ethereum_test_forks import ShanghaiToCancunAtTime15k\n\n@pytest.mark.parametrize(\"fork\", ShanghaiToCancunAtTime15k)\nclass TestMultipleWithdrawalsSameAddress:\n</code></pre> <pre><code>import pytest\n\nfrom ethereum_test_forks import forks_from_until, Shanghai\n\npytestmark = pytest.mark.parametrize(\"fork\", forks_from(Shanghai))\n</code></pre> <p>The <code>ethereum_test_forks</code> package defines the available forks and provides the following helpers that return all forks within the specified range:</p> <ul> <li>forks_from</li> <li>forks_from_until</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#statetest-object","title":"<code>StateTest</code> Object","text":"<p>The <code>StateTest</code> object represents a single test vector, and contains the following attributes:</p> <ul> <li><code>env</code>: Environment object which describes the global state of the blockchain     before the test starts.</li> <li><code>pre</code>: Pre-State containing the information of all Ethereum accounts that exist     before any transaction is executed.</li> <li><code>post</code>: Post-State containing the information of all Ethereum accounts that are     created or modified after all transactions are executed.</li> <li><code>txs</code>: All transactions to be executed during test execution.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#blockchaintest-object","title":"<code>BlockchainTest</code> Object","text":"<p>The <code>BlockchainTest</code> object represents a single test vector that evaluates the Ethereum VM by attempting to append multiple blocks to the chain:</p> <ul> <li><code>pre</code>: Pre-State containing the information of all Ethereum accounts that exist     before any block is executed.</li> <li><code>post</code>: Post-State containing the information of all Ethereum accounts that are     created or modified after all blocks are executed.</li> <li><code>blocks</code>: All blocks to be appended to the blockchain during the test.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#prepost-state-of-the-test","title":"Pre/Post State of the Test","text":"<p>The <code>pre</code> and <code>post</code> states are elemental to setup and then verify the outcome of the state test.</p> <p>Both <code>pre</code> and <code>post</code> are mappings of account addresses to <code>account</code> structures (see more info).</p> <p>A single test vector can contain as many accounts in the <code>pre</code> and <code>post</code> states as required, and they can be also filled dynamically.</p> <p><code>storage</code> of an account is a key/value dictionary, and its values are integers within range of <code>[0, 2**256 - 1]</code>.</p> <p><code>txs</code> are the steps which transform the pre-state into the post-state and must perform specific actions within the accounts (smart contracts) that result in verifiable changes to the balance, nonce, and/or storage in each of them.</p> <p><code>post</code> is compared against the outcome of the client after the execution of each transaction, and any differences are considered a failure</p> <p>When designing a test, all the changes must be ideally saved into the contract's storage to be able to verify them in the post-state.</p>"},{"location":"writing_tests/writing_a_new_test/#test-transactions","title":"Test Transactions","text":"<p>Transactions can be crafted by sending them with specific <code>data</code> or to a specific account, which contains the code to be executed</p> <p>Transactions can also create more accounts, by setting the <code>to</code> field to an  empty string.</p> <p>Transactions can be designed to fail, and a verification must be made that the transaction fails with the specific error that matches what is expected by the test.</p>"},{"location":"writing_tests/writing_a_new_test/#writing-code-for-the-accounts-in-the-test","title":"Writing code for the accounts in the test","text":"<p>Account bytecode can be embedded in the test accounts by adding it to the <code>code</code> field of the <code>account</code> object, or the <code>data</code> field of the <code>tx</code> object if the bytecode is meant to be treated as init code or call data.</p> <p>The code can be in either of the following formats:</p> <ul> <li><code>bytes</code> object, representing the raw opcodes in binary format.</li> <li><code>str</code>, representing an hexadecimal format of the opcodes.</li> <li><code>Code</code> compilable object.</li> </ul> <p>Currently supported built-in compilable objects are:</p> <ul> <li><code>Yul</code> object containing Yul source code.</li> </ul> <p><code>Code</code> objects can be concatenated together by using the <code>+</code> operator.</p>"},{"location":"writing_tests/writing_a_new_test/#verifying-the-accounts-post-states","title":"Verifying the Accounts' Post States","text":"<p>The state of the accounts after all blocks/transactions have been executed is the way of verifying that the execution client actually behaves like the test expects.</p> <p>During their filling process, all tests automatically verify that the accounts specified in their <code>post</code> property actually match what was returned by the transition tool.</p> <p>Within the <code>post</code> dictionary object, an account address can be:</p> <ul> <li><code>None</code>: The account will not be checked for absence or existence in the   result returned by the transition tool.</li> <li><code>Account</code> object: The test expects that this account exists and also has   properties equal to the properties specified by the <code>Account</code> object.</li> <li><code>Account.NONEXISTENT</code>: The test expects that this account does not exist in   the result returned by the transition tool, and if the account exists,   it results in error.   E.g. when the transaction creating a contract is expected to fail and the   test wants to verify that the address where the contract was supposed to be   created is indeed empty.</li> </ul>"},{"location":"writing_tests/writing_a_new_test/#the-account-object","title":"The <code>Account</code> object","text":"<p>The <code>Account</code> object is used to specify the properties of an account to be verified in the post state.</p> <p>The python representation can be found in src/ethereum_test_tools/common/types.py.</p> <p>It can verify the following properties of an account:</p> <ul> <li> <p><code>nonce</code>: the scalar value equal to a) the number of transactions sent by   an Externally Owned Account, b) the amount of contracts created by a contract.</p> </li> <li> <p><code>balance</code>: the amount of Wei (10-18 Eth) the account has.</p> </li> <li> <p><code>code</code>: Bytecode contained by the account. To verify that an account contains   no code, this property needs to be set to \"0x\" or \"\".</p> </li> </ul> <p>It is not recommended to verify Yul compiled code in the output account,   because the bytecode can change from version to version.</p> <ul> <li><code>storage</code>: Storage within the account represented as a <code>dict</code> object.   All storage keys that are expected to be set must be specified, and if a   key is skipped, it is implied that its expected value is zero.   Setting this property to <code>{}</code> (empty <code>dict</code>), means that all the keys in the   account must be unset (equal to zero).</li> </ul> <p>All account's properties are optional, and they can be skipped or set to <code>None</code>, which means that no check will be performed on that specific account property.</p>"},{"location":"writing_tests/writing_a_new_test/#verifying-correctness-of-the-new-test","title":"Verifying correctness of the new test","text":"<p>A well written test performs a single verification output at a time.</p> <p>A verification output can be a single storage slot, the balance of an account, or a newly created contract.</p> <p>It is not recommended to use balance changes to verify test correctness, as it can be easily affected by gas cost changes in future EIPs.</p> <p>The best way to verify a transaction/block execution outcome is to check its storage.</p> <p>A test can be written as a negative verification. E.g. a contract is not created, or a transaction fails to execute or runs out of gas.</p> <p>These verifications must be carefully crafted because it is possible to end up having a false positive result, which means that the test passed but the intended verification was never made.</p> <p>To avoid these scenarios, it is important to have a separate verification to check that test is effective. E.g. when a transaction is supposed to fail, it is necessary to check that the failure error is actually the one expected by the test.</p>"},{"location":"writing_tests/writing_a_new_test/#failing-or-invalid-transactions","title":"Failing or invalid transactions","text":"<p>Transactions included in a StateTest are expected to be intrinsically valid, i.e. the account sending the transaction must have enough funds to cover the gas costs, the max fee of the transaction must be equal or higher than the base fee of the block, etc.</p> <p>An intrinsically valid transaction can still revert during its execution.</p> <p>Blocks in a BlockchainTest can contain intrinsically invalid transactions but in this case the block is expected to be completely rejected, along with all transactions in it, including other valid transactions.</p>"}]}