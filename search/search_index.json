{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Execution Spec Tests","text":"<p>A new set of tests for ethereum execution clients to test against. The git repo is updated regularly with new tests.</p>  Test Case Descriptions  <ul> <li> EIP-4844 </li> </ul>  Getting Started  <ul> <li> Quick Start </li> <li> Package Overview </li> <li> Writing Tests </li> <li> Adding a Reference Spec </li> </ul>  Tutorials  <ul> <li> State Tests </li> <li> Blockchain Tests </li> </ul>  Library Reference  <ul> <li><code>ethereum_test_forks</code></li> <li><code>ethereum_test_tools</code></li> <li>'evm_block_builder`</li> <li>'evm_transition_tool`</li> <li>'pytest_plugins`</li> </ul>"},{"location":"fillers/withdrawals/","title":"Withdrawals","text":"<p>Test Withdrawal system-level operation</p>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress","title":"<code>TestMultipleWithdrawalsSameAddress</code>","text":"<p>Test that multiple withdrawals can be sent to the same address in:</p> <ol> <li> <p>A single block.</p> </li> <li> <p>Multiple blocks.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\"test_case\", [\"single_block\", \"multiple_blocks\"])\nclass TestMultipleWithdrawalsSameAddress:\n\"\"\"\n    Test that multiple withdrawals can be sent to the same address in:\n\n    1. A single block.\n\n    2. Multiple blocks.\n    \"\"\"\n\n    ADDRESSES = [\n        to_address(0x0),  # Zero address\n        to_address(0x1),  # Pre-compiles\n        to_address(0x2),\n        to_address(0x3),\n        to_address(0x4),\n        to_address(0x5),\n        to_address(0x6),\n        to_address(0x7),\n        to_address(0x8),\n        to_address(0x9),\n        to_address(2**160 - 1),\n    ]\n\n    @pytest.fixture\n    def blocks(self, test_case: str):  # noqa: D102\n        if test_case == \"single_block\":\n            # Many repeating withdrawals of the same accounts in the same\n            # block.\n            return [\n                Block(\n                    withdrawals=[\n                        Withdrawal(\n                            index=i,\n                            validator=0,\n                            address=self.ADDRESSES[i % len(self.ADDRESSES)],\n                            amount=1,\n                        )\n                        for i in range(len(self.ADDRESSES) * 16)\n                    ],\n                ),\n            ]\n        if test_case == \"multiple_blocks\":\n            # Similar test but now use multiple blocks each with multiple\n            # withdrawals to the same withdrawal address.\n            return [\n                Block(\n                    withdrawals=[\n                        Withdrawal(\n                            index=i * 16 + j,\n                            validator=i,\n                            address=self.ADDRESSES[i],\n                            amount=1,\n                        )\n                        for j in range(16)\n                    ],\n                )\n                for i in range(len(self.ADDRESSES))\n            ]\n        raise Exception(\"Invalid test case.\")\n\n    def test_multiple_withdrawals_same_address(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        fork: Fork,\n        test_case: str,\n        blocks: List[Block],\n    ):\n\"\"\"\n        Test Withdrawals can be done to the same address multiple times in\n        the same block.\n        \"\"\"\n        pre = {\n            TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        }\n        for addr in self.ADDRESSES:\n            pre[addr] = Account(\n                code=SET_STORAGE,\n            )\n\n        # Expected post is the same for both test cases.\n        post = {}\n        for addr in self.ADDRESSES:\n            post[addr] = Account(\n                balance=16 * ONE_GWEI,\n                storage={},\n            )\n\n        blockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress.test_multiple_withdrawals_same_address","title":"<code>test_multiple_withdrawals_same_address(blockchain_test, fork, test_case, blocks)</code>","text":"<p>Test Withdrawals can be done to the same address multiple times in the same block.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_multiple_withdrawals_same_address(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    test_case: str,\n    blocks: List[Block],\n):\n\"\"\"\n    Test Withdrawals can be done to the same address multiple times in\n    the same block.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n    for addr in self.ADDRESSES:\n        pre[addr] = Account(\n            code=SET_STORAGE,\n        )\n\n    # Expected post is the same for both test cases.\n    post = {}\n    for addr in self.ADDRESSES:\n        post[addr] = Account(\n            balance=16 * ONE_GWEI,\n            storage={},\n        )\n\n    blockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx","title":"<code>TestUseValueInTx</code>","text":"<p>Test that the value from a withdrawal can be used in a transaction:</p> <ol> <li> <p>tx_in_withdrawals_block:   Test that the withdrawal value can not be used by a transaction in   the same block as the withdrawal.</p> </li> <li> <p>tx_after_withdrawals_block:   Test that the withdrawal value can be used by a transaction in the   subsequent block.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"test_case\",\n    [\"tx_in_withdrawals_block\", \"tx_after_withdrawals_block\"],\n    ids=lambda x: x,\n)\nclass TestUseValueInTx:\n\"\"\"\n    Test that the value from a withdrawal can be used in a transaction:\n\n    1. tx_in_withdrawals_block:\n      Test that the withdrawal value can not be used by a transaction in\n      the same block as the withdrawal.\n\n    2. tx_after_withdrawals_block:\n      Test that the withdrawal value can be used by a transaction in the\n      subsequent block.\n    \"\"\"\n\n    @pytest.fixture\n    def tx(self):  # noqa: D102\n        # Transaction sent from the `TestAddress`, which has 0 balance at start\n        return Transaction(\n            nonce=0,\n            gas_price=ONE_GWEI,\n            gas_limit=21000,\n            to=to_address(0x100),\n            data=\"0x\",\n        )\n\n    @pytest.fixture\n    def withdrawal(self, tx: Transaction):  # noqa: D102\n        return Withdrawal(\n            index=0,\n            validator=0,\n            address=TestAddress,\n            amount=tx.gas_limit + 1,\n        )\n\n    @pytest.fixture\n    def blocks(  # noqa: D102\n        self, tx: Transaction, withdrawal: Withdrawal, test_case\n    ):\n        if test_case == \"tx_in_withdrawals_block\":\n            return [\n                Block(\n                    txs=[\n                        tx.with_error(\n                            \"intrinsic gas too low: have 0, want 21000\"\n                        )\n                    ],\n                    withdrawals=[\n                        withdrawal,\n                    ],\n                    exception=\"Transaction without funds\",\n                )\n            ]\n        if test_case == \"tx_after_withdrawals_block\":\n            return [\n                Block(\n                    txs=[],\n                    withdrawals=[\n                        withdrawal,\n                    ],\n                ),\n                Block(\n                    txs=[tx],\n                    withdrawals=[],\n                ),\n            ]\n        raise Exception(\"Invalid test case.\")\n\n    @pytest.fixture\n    def post(self, test_case: str) -&gt; Dict:  # noqa: D102\n        if test_case == \"tx_in_withdrawals_block\":\n            return {}\n        if test_case == \"tx_after_withdrawals_block\":\n            return {TestAddress: Account(balance=ONE_GWEI)}\n        raise Exception(\"Invalid test case.\")\n\n    def test_use_value_in_tx(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        post: dict,\n        blocks: List[Block],\n    ):\n\"\"\"\n        Test sending withdrawal value in a transaction.\n        \"\"\"\n        pre = {TestAddress: Account(balance=0)}\n        blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx.test_use_value_in_tx","title":"<code>test_use_value_in_tx(blockchain_test, post, blocks)</code>","text":"<p>Test sending withdrawal value in a transaction.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_tx(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    post: dict,\n    blocks: List[Block],\n):\n\"\"\"\n    Test sending withdrawal value in a transaction.\n    \"\"\"\n    pre = {TestAddress: Account(balance=0)}\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount","title":"<code>TestZeroAmount</code>","text":"<p>Test withdrawals with zero amount for the following cases, all withdrawals are included in one block:</p> <ol> <li> <p>Two withdrawals of zero amount to two different addresses; one to an    untouched account, one to an account with a balance.</p> </li> <li> <p>As 1., but with an additional withdrawal with positive value.</p> </li> <li> <p>As 2., but with an additional withdrawal containing the maximum value    possible.</p> </li> <li> <p>As 3., but with order of withdrawals in the block reversed.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"test_case\",\n    [case for case in ZeroAmountTestCases],\n    ids=[case.value for case in ZeroAmountTestCases],\n)\nclass TestZeroAmount:\n\"\"\"\n    Test withdrawals with zero amount for the following cases, all withdrawals\n    are included in one block:\n\n    1. Two withdrawals of zero amount to two different addresses; one to an\n       untouched account, one to an account with a balance.\n\n    2. As 1., but with an additional withdrawal with positive value.\n\n    3. As 2., but with an additional withdrawal containing the maximum value\n       possible.\n\n    4. As 3., but with order of withdrawals in the block reversed.\n\n    \"\"\"\n\n    @pytest.fixture(scope=\"function\")\n    def test_case_parameters(self, test_case):  # noqa: D102\n        withdrawals = [\n            # No value, untouched account\n            Withdrawal(\n                index=0,\n                validator=0,\n                address=to_address(0x100),\n                amount=0,\n            ),\n            # No value, touched account\n            Withdrawal(\n                index=0,\n                validator=0,\n                address=to_address(0x200),\n                amount=0,\n            ),\n            # Withdrawal with value\n            Withdrawal(\n                index=1,\n                validator=0,\n                address=to_address(0x300),\n                amount=1,\n            ),\n            # Withdrawal with maximum amount\n            Withdrawal(\n                index=2,\n                validator=0,\n                address=to_address(0x400),\n                amount=2**64 - 1,\n            ),\n        ]\n        post = {\n            to_address(0x100): Account.NONEXISTENT,\n            to_address(0x200): Account(code=\"0x00\", balance=0),\n            to_address(0x300): Account(balance=ONE_GWEI),\n            to_address(0x400): Account(balance=(2**64 - 1) * ONE_GWEI),\n        }\n        if test_case == ZeroAmountTestCases.TWO_ZERO:\n            return {\n                \"withdrawals\": withdrawals[0:2],\n                \"post\": {\n                    account: post[account]\n                    for account in post\n                    if account in [to_address(0x100), to_address(0x200)]\n                },\n            }\n        if test_case == ZeroAmountTestCases.THREE_ONE_WITH_VALUE:\n            return {\n                \"withdrawals\": withdrawals[0:3],\n                \"post\": {\n                    account: post[account]\n                    for account in post\n                    if account\n                    in [\n                        to_address(0x100),\n                        to_address(0x200),\n                        to_address(0x300),\n                    ]\n                },\n            }\n        if test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX:\n            return {\"withdrawals\": withdrawals, \"post\": post}\n        if test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX_REVERSED:\n            withdrawals.reverse()\n            set_withdrawal_index(withdrawals)\n            return {\"withdrawals\": withdrawals, \"post\": post}\n        raise Exception(\"Unknown test case.\")\n\n    def test_zero_amount(\n        self,\n        blockchain_test: BlockchainTestFiller,\n        fork: Fork,\n        test_case: ZeroAmountTestCases,\n        test_case_parameters: Dict,\n    ):\n\"\"\"\n        Test Withdrawals where one of the withdrawal has a zero amount.\n        \"\"\"\n        pre = {\n            TestAddress: Account(balance=1000000000000000000000, nonce=0),\n            to_address(0x200): Account(\n                code=\"0x00\",\n                balance=0,\n            ),\n        }\n\n        blockchain_test(\n            pre=pre,\n            post=test_case_parameters[\"post\"],\n            blocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\n            tag=test_case.value,\n        )\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount.test_zero_amount","title":"<code>test_zero_amount(blockchain_test, fork, test_case, test_case_parameters)</code>","text":"<p>Test Withdrawals where one of the withdrawal has a zero amount.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_zero_amount(\n    self,\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    test_case: ZeroAmountTestCases,\n    test_case_parameters: Dict,\n):\n\"\"\"\n    Test Withdrawals where one of the withdrawal has a zero amount.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x200): Account(\n            code=\"0x00\",\n            balance=0,\n        ),\n    }\n\n    blockchain_test(\n        pre=pre,\n        post=test_case_parameters[\"post\"],\n        blocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\n        tag=test_case.value,\n    )\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.set_withdrawal_index","title":"<code>set_withdrawal_index(withdrawals, start_index=0)</code>","text":"<p>Automatically set the index of each withdrawal in a list in sequential order.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def set_withdrawal_index(\n    withdrawals: List[Withdrawal], start_index: int = 0\n) -&gt; None:\n\"\"\"\n    Automatically set the index of each withdrawal in a list in sequential\n    order.\n    \"\"\"\n    for i, w in enumerate(withdrawals):\n        w.index = start_index + i\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_balance_within_block","title":"<code>test_balance_within_block(blockchain_test, fork)</code>","text":"<p>Test Withdrawal balance increase within the same block, inside contract call.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_balance_within_block(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test Withdrawal balance increase within the same block,\n    inside contract call.\n    \"\"\"\n    SAVE_BALANCE_ON_BLOCK_NUMBER = Op.SSTORE(\n        Op.NUMBER,\n        Op.BALANCE(Op.CALLDATALOAD(0)),\n    )\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=SAVE_BALANCE_ON_BLOCK_NUMBER,\n        ),\n        to_address(0x200): Account(\n            balance=ONE_GWEI,\n        ),\n    }\n    blocks = [\n        Block(\n            txs=[\n                Transaction(\n                    nonce=0,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                    data=to_hash(0x200),\n                )\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x200),\n                    amount=1,\n                )\n            ],\n        ),\n        Block(\n            txs=[\n                Transaction(\n                    nonce=1,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                    data=to_hash(0x200),\n                )\n            ]\n        ),\n    ]\n\n    post = {\n        to_address(0x100): Account(\n            storage={\n                1: ONE_GWEI,\n                2: 2 * ONE_GWEI,\n            }\n        )\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_large_amount","title":"<code>test_large_amount(blockchain_test, fork)</code>","text":"<p>Test Withdrawals that have a large gwei amount, so that (gwei * 1e9) could overflow uint64 but not uint256.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_large_amount(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals that have a large gwei amount, so that (gwei * 1e9)\n    could overflow uint64 but not uint256.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n\n    withdrawals: List[Withdrawal] = []\n    amounts: List[int] = [\n        (2**35),\n        (2**64) - 1,\n        (2**63) + 1,\n        (2**63),\n        (2**63) - 1,\n    ]\n\n    post = {}\n\n    for i, amount in enumerate(amounts):\n        addr = to_address(0x100 * (i + 1))\n        withdrawals.append(\n            Withdrawal(\n                index=i,\n                validator=i,\n                address=addr,\n                amount=amount,\n            )\n        )\n        post[addr] = Account(balance=(amount * ONE_GWEI))\n\n    blocks = [\n        Block(\n            withdrawals=withdrawals,\n        )\n    ]\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_many_withdrawals","title":"<code>test_many_withdrawals(blockchain_test, fork)</code>","text":"<p>Test Withdrawals with a count of N withdrawals in a single block where N is a high number not expected to be seen in mainnet.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_many_withdrawals(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals with a count of N withdrawals in a single block where\n    N is a high number not expected to be seen in mainnet.\n    \"\"\"\n    N = 400\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n    withdrawals = []\n    post = {}\n    for i in range(N):\n        addr = to_address(0x100 * i)\n        amount = i * 1\n        pre[addr] = Account(\n            code=SET_STORAGE,\n        )\n        withdrawals.append(\n            Withdrawal(\n                index=i,\n                validator=i,\n                address=addr,\n                amount=amount,\n            )\n        )\n        post[addr] = Account(\n            code=SET_STORAGE,\n            balance=amount * ONE_GWEI,\n            storage={},\n        )\n\n    blocks = [\n        Block(\n            withdrawals=withdrawals,\n        ),\n    ]\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_newly_created_contract","title":"<code>test_newly_created_contract(blockchain_test, fork, include_value_in_tx, request)</code>","text":"<p>Test Withdrawing to a newly created contract.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n    \"include_value_in_tx\",\n    [False, True],\n    ids=[\"without_tx_value\", \"with_tx_value\"],\n)\ndef test_newly_created_contract(\n    blockchain_test: BlockchainTestFiller,\n    fork: Fork,\n    include_value_in_tx: bool,\n    request,\n):\n\"\"\"\n    Test Withdrawing to a newly created contract.\n    \"\"\"\n    created_contract = compute_create_address(TestAddress, 0)\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n    }\n\n    initcode = Yul(\n\"\"\"\n        {\n            return(0, 1)\n        }\n        \"\"\"\n    )\n\n    tx = Transaction(\n        # Transaction sent from the `TestAddress`, that creates a\n        # new contract.\n        nonce=0,\n        gas_price=10,\n        gas_limit=1000000,\n        to=None,\n        data=initcode,\n    )\n\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=created_contract,\n        amount=1,\n    )\n\n    block = Block(\n        txs=[tx],\n        withdrawals=[withdrawal],\n    )\n\n    post = {\n        created_contract: Account(\n            code=\"0x00\",\n            balance=ONE_GWEI,\n        ),\n    }\n    if include_value_in_tx:\n        tx.value = ONE_GWEI\n        post[created_contract].balance = 2 * ONE_GWEI\n\n    tag = request.node.callspec.id.split(\"-\")[0]  # remove fork; brittle\n    blockchain_test(pre=pre, post=post, blocks=[block], tag=tag)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_no_evm_execution","title":"<code>test_no_evm_execution(blockchain_test, fork)</code>","text":"<p>Test Withdrawals don't trigger EVM execution.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_no_evm_execution(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals don't trigger EVM execution.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x200): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x300): Account(\n            code=SET_STORAGE,\n        ),\n        to_address(0x400): Account(\n            code=SET_STORAGE,\n        ),\n    }\n    blocks = [\n        Block(\n            txs=[\n                Transaction(\n                    nonce=0,\n                    gas_limit=100000,\n                    to=to_address(0x300),\n                ),\n                Transaction(\n                    nonce=1,\n                    gas_limit=100000,\n                    to=to_address(0x400),\n                ),\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x100),\n                    amount=1,\n                ),\n                Withdrawal(\n                    index=1,\n                    validator=1,\n                    address=to_address(0x200),\n                    amount=1,\n                ),\n            ],\n        ),\n        Block(\n            txs=[\n                Transaction(\n                    nonce=2,\n                    gas_limit=100000,\n                    to=to_address(0x100),\n                ),\n                Transaction(\n                    nonce=3,\n                    gas_limit=100000,\n                    to=to_address(0x200),\n                ),\n            ],\n            withdrawals=[\n                Withdrawal(\n                    index=0,\n                    validator=0,\n                    address=to_address(0x300),\n                    amount=1,\n                ),\n                Withdrawal(\n                    index=1,\n                    validator=1,\n                    address=to_address(0x400),\n                    amount=1,\n                ),\n            ],\n        ),\n    ]\n\n    post = {\n        to_address(0x100): Account(storage={2: 1}),\n        to_address(0x200): Account(storage={2: 1}),\n        to_address(0x300): Account(storage={1: 1}),\n        to_address(0x400): Account(storage={1: 1}),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_self_destructing_account","title":"<code>test_self_destructing_account(blockchain_test, fork)</code>","text":"<p>Test withdrawals can be done to self-destructed accounts. Account <code>0x100</code> self-destructs and sends all its balance to <code>0x200</code>. Then, a withdrawal is received at <code>0x100</code> with 99 wei.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_self_destructing_account(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test withdrawals can be done to self-destructed accounts.\n    Account `0x100` self-destructs and sends all its balance to `0x200`.\n    Then, a withdrawal is received at `0x100` with 99 wei.\n    \"\"\"\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(\n            code=Op.SELFDESTRUCT(Op.CALLDATALOAD(0)),\n            balance=(100 * ONE_GWEI),\n        ),\n        to_address(0x200): Account(\n            balance=0,\n        ),\n    }\n\n    tx_1 = Transaction(\n        # Transaction sent from the `TestAddress`, that calls a\n        # self-destructing contract.\n        nonce=0,\n        gas_price=10,\n        gas_limit=100000,\n        to=to_address(0x100),\n        data=to_hash(0x200),\n    )\n\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=to_address(0x100),\n        amount=(99),\n    )\n\n    block = Block(\n        txs=[tx_1],\n        withdrawals=[withdrawal],\n    )\n\n    post = {\n        to_address(0x100): Account(\n            code=None,\n            balance=(99 * ONE_GWEI),\n        ),\n        to_address(0x200): Account(\n            code=None,\n            balance=(100 * ONE_GWEI),\n        ),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=[block])\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_use_value_in_contract","title":"<code>test_use_value_in_contract(blockchain_test, fork)</code>","text":"<p>Test sending value from contract that has not received a withdrawal</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_contract(\n    blockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test sending value from contract that has not received a withdrawal\n    \"\"\"\n    SEND_ONE_GWEI = Op.SSTORE(\n        Op.NUMBER,\n        Op.CALL(Op.GAS, 0x200, 1000000000, 0, 0, 0, 0),\n    )\n\n    pre = {\n        TestAddress: Account(balance=1000000000000000000000, nonce=0),\n        to_address(0x100): Account(balance=0, code=SEND_ONE_GWEI),\n        to_address(0x200): Account(balance=0),\n    }\n    tx = Transaction(\n        # Transaction sent from the `TestAddress`, which has 0 balance at start\n        nonce=0,\n        value=0,\n        gas_price=10,\n        gas_limit=100000,\n        to=to_address(0x100),\n        data=\"0x\",\n    )\n    withdrawal = Withdrawal(\n        index=0,\n        validator=0,\n        address=to_address(0x100),\n        amount=1,\n    )\n\n    blocks = [\n        Block(\n            txs=[tx.with_nonce(0)],\n            withdrawals=[withdrawal],\n        ),\n        Block(\n            txs=[tx.with_nonce(1)],  # Same tx again, just increase nonce\n        ),\n    ]\n    post = {\n        to_address(0x100): Account(\n            storage={\n                0x1: 0x0,  # Call fails on the first attempt\n                0x2: 0x1,  # Succeeds on the second attempt\n            }\n        ),\n        to_address(0x200): Account(\n            balance=ONE_GWEI,\n        ),\n    }\n\n    blockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"getting_started/package_overview/","title":"Package Overview","text":""},{"location":"getting_started/package_overview/#ethereum_test_tools","title":"<code>ethereum_test_tools</code>","text":"<p>The <code>ethereum_test_tools</code> package provides primitives and helpers to allow developers to easily test the consensus logic of Ethereum clients. </p>"},{"location":"getting_started/package_overview/#ethereum_test_filling_tool","title":"<code>ethereum_test_filling_tool</code>","text":"<p>The <code>ethereum_test_filling_tool</code> package is a CLI application that recursively searches a given directory for Python modules that export test filler functions generated using <code>ethereum_test_tools</code>. It then processes the fillers using the transition tool and the block builder tool, and writes the resulting fixture to file.</p>"},{"location":"getting_started/package_overview/#evm_block_builder","title":"<code>evm_block_builder</code>","text":"<p>This is a wrapper around the block builder (b11r) tool.</p>"},{"location":"getting_started/package_overview/#evm_transition_tool","title":"<code>evm_transition_tool</code>","text":"<p>This is a wrapper around the transaction (t8n) tool.</p>"},{"location":"getting_started/package_overview/#fillers","title":"<code>fillers</code>","text":"<p>Contains all the Ethereum consensus tests available in this repository.</p>"},{"location":"getting_started/quick_start/","title":"Quick Start","text":""},{"location":"getting_started/quick_start/#prerequisites","title":"Prerequisites","text":"<p>The following are required to either generate or develop tests:</p> <ol> <li>Python &gt;= <code>3.10.0</code> &lt; <code>3.11</code>.</li> <li>For dists. with the <code>apt</code> package manager ensure you have python <code>-dev</code> &amp; <code>-venv</code> packages installed.</li> <li> <p><code>go-ethereum</code> <code>geth</code>'s <code>evm</code> utility must be accessible in the <code>PATH</code>, typically at the latest version. To get it:</p> <ol> <li>Install the Go programming language on your computer.</li> <li>Clone the Geth repository.</li> <li>Run <code>make all</code>.</li> <li>Copy <code>build/bin/evm</code> to a directory on the path.</li> </ol> <p>Note: To update to a different Geth branch (for example one that supports a specific EIP) all you need to do is to change the <code>evm</code> in the path.</p> </li> <li> <p><code>solc</code> &gt;= <code>v0.8.17</code>; <code>solc</code> must be in accessible in the <code>PATH</code>.</p> </li> </ol>"},{"location":"getting_started/quick_start/#installation","title":"Installation","text":"<p>To generate tests from the test \"fillers\", it's necessary to install the Python packages provided by <code>execution-spec-tests</code> (it's recommended to use a virtual environment for the installation):</p> <pre><code>git clone https://github.com/ethereum/execution-spec-tests\ncd execution-spec-tests\npython3.10 -m venv ./venv/\nsource ./venv/bin/activate\npip install -e .\n</code></pre> <p>After the installation, run this sanity check to ensure tests are generated. If everything is OK, you will see the beginning of the JSON format filled test.</p> <pre><code>tf --test-case yul\nhead fixtures/example/yul_example/yul.json\n</code></pre>"},{"location":"getting_started/quick_start/#generating-the-execution-spec-tests-for-use-with-clients","title":"Generating the Execution Spec Tests For Use With Clients","text":"<p>To generate all the tests defined in the <code>./fillers</code> sub-directory, run the <code>tf</code> command:</p> <pre><code>tf --filler-path=\"fillers\" --output=\"fixtures\" \n</code></pre> <p>This is equivalent to running <code>tf</code> with no arguments. The paths<code>fillers/</code> and <code>fixtures/</code> are both defaults for the respective command.</p> <p>Note</p> <p>The test <code>post</code> conditions are tested against the output of the <code>geth</code> <code>evm</code> utility during test generation.</p> <p>To generate all the tests in the <code>./fillers/vm</code> sub-directory (category), for example, run:</p> <pre><code>tf --test-categories vm\n</code></pre> <p>This extends to sub-directories. As an example, to generate all specific tests within the <code>./fillers/vm/vm_arith/vm_add</code> sub-directory, run:</p> <pre><code>tf --output=\"fixtures\" --test-categories vm.vm_arith.vm_add\n</code></pre> <p>To generate all the tests in the <code>./fillers/*/dup.py</code> modules, for example, run:</p> <pre><code>tf --test-module dup\n</code></pre> <p>To generate specific tests, such as <code>./fillers/*/*.py::test_dup</code>, for example, run (remove the <code>test_</code> prefix from the test case's function name):</p> <pre><code>tf --test-case dup\n</code></pre> <p>To overwrite the existing set of fixtures, make sure you run the test filler with the <code>--force-refill</code> flag:</p> <pre><code>tf --force-refill\n</code></pre> <p>For upcoming forks that are not already upgraded within the Ethereum network, use the <code>--latest-fork</code> flag. For example, currently (03/05/23) the next fork being developed is <code>Cancun</code>:</p> <pre><code>tf --latest-fork Cancun\n</code></pre>"},{"location":"getting_started/quick_start/#testing-the-execution-spec-tests-framework","title":"Testing the Execution Spec Tests Framework","text":"<p>The Python packages provided by the execution spec tests framework have their own test suite that can be ran via <code>tox</code>:</p> <pre><code>python -m venv ./venv/\nsource ./venv/bin/activate\npip install tox\ntox -e py3\n</code></pre>"},{"location":"getting_started/reference_specification/","title":"Referencing Specification Documents","text":""},{"location":"getting_started/reference_specification/#referencing-an-eip-in-a-test-file","title":"Referencing an EIP in a test file","text":"<p>An Ethereum Improvement Proposal can be directly referenced within a python test file.</p> <p>This is accomplished by adding two key variables anywhere in the file:</p> <ul> <li>REFERENCE_SPEC_GIT_PATH: Path within the https://github.com/ethereum/EIPs/ repository to the EIP markdown file.     E.g. <code>\"EIPS/eip-1234.md\"</code></li> <li>REFERENCE_SPEC_VERSION: <code>SHA</code> digest of the current version of the file</li> </ul> <p>The <code>SHA</code> digest can be obtained using the github api by using the following endpoint:</p> <pre><code>https://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-&lt;EIP Number&gt;.md\n</code></pre> <p>By adding this reference in the python test file, the <code>tf</code> command will automatically detect and warn when there have been changes to the referenced EIP markdown file.</p>"},{"location":"getting_started/writing_tests/","title":"Writing Tests","text":""},{"location":"getting_started/writing_tests/#purpose-of-test-specs-in-this-repository","title":"Purpose of test specs in this repository","text":"<p>The goal of the test specs included in this repository is to generate test vectors that can be consumed by any Execution client, and to verify that all of the clients agree on the same output after executing each test.</p> <p>Consensus is the most important aspect of any blockchain network, therefore, anything that modifies the state of the blockchain must be tested by at least one test in this repository.</p> <p>The tests focus on the EVM execution, therefore before being able to properly write a test, it is important to understand what the Ethereum Virtual Machine is and how it works.</p>"},{"location":"getting_started/writing_tests/#types-of-tests","title":"Types of tests","text":"<p>At the moment there are only two types of tests that can be produced by each test spec:</p> <ul> <li>State Tests</li> <li>Blockchain Tests</li> </ul> <p>The State tests span a single block and, ideally, a single transaction.</p> <p>Examples of State tests:</p> <ul> <li>Test a single opcode behavior</li> <li>Verify opcode gas costs</li> <li>Test interactions between multiple smart contracts</li> <li>Test creation of smart contracts</li> </ul> <p>The Blockchain tests span multiple blocks which may or may not contain transactions and mainly focus on the block to block effects to the Ethereum state.</p> <ul> <li>Verify system-level operations such as coinbase balance updates or withdrawals</li> <li>Verify fork transitions</li> <li>Verify blocks with invalid transactions/properties are rejected</li> </ul>"},{"location":"getting_started/writing_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>All currently implemented tests can be found in the <code>fillers</code> directory, which is composed of many subdirectories, and each one represents a different test category.</p> <p>Source files included in each category contain one or multiple test specs represented as python functions, and each can in turn produce one or many test vectors.</p> <p>A new test can be added by either:</p> <ul> <li>Adding a new <code>test_</code> python function to an existing file in any of the   existing category subdirectories within <code>fillers</code>.</li> <li>Creating a new source file in an existing category, and populating it with   the new test function(s).</li> <li>Creating an entirely new category by adding a subdirectory in   <code>fillers</code> with the appropriate source files and test functions.<ul> <li>Tests within multiple sub-directories must have a <code>__init__.py</code> file   within each directory above it (and it own), to ensure the test is found by the test filler <code>tf</code>.</li> </ul> </li> </ul>"},{"location":"getting_started/writing_tests/#test-spec-generator-functions","title":"Test Spec Generator Functions","text":"<p>Every test spec is a python generator function which can perform a single or multiple <code>yield</code> operations during its runtime to each time yield a single <code>StateTest</code>/<code>BlockchainTest</code> object.</p> <p>The test vector's generator function must be decorated by only one of the following decorators: - <code>test_from</code> - <code>test_from_until</code> - <code>test_only</code></p> <p>These decorators specify the forks on which the test vector is supposed to run.</p> <p>They also automatically append necessary information for the <code>ethereum_test_filling_tool</code> to process when the generator is being executed to fill the tests.</p> <p>The test vector function must take only one <code>str</code> parameter: the fork name.</p>"},{"location":"getting_started/writing_tests/#statetest-object","title":"<code>StateTest</code> Object","text":"<p>The <code>StateTest</code> object represents a single test vector, and contains the following attributes:</p> <ul> <li>env: Environment object which describes the global state of the blockchain     before the test starts.</li> <li>pre: Pre-State containing the information of all Ethereum accounts that exist     before any transaction is executed.</li> <li>post: Post-State containing the information of all Ethereum accounts that are     created or modified after all transactions are executed.</li> <li>txs: All transactions to be executed during the test vector runtime.</li> </ul>"},{"location":"getting_started/writing_tests/#blockchaintest-object","title":"<code>BlockchainTest</code> Object","text":"<p>The <code>BlockchainTest</code> object represents a single test vector that evaluates the Ethereum VM by attempting to append multiple blocks to the chain:</p> <ul> <li>pre: Pre-State containing the information of all Ethereum accounts that exist     before any block is executed.</li> <li>post: Post-State containing the information of all Ethereum accounts that are     created or modified after all blocks are executed.</li> <li>blocks: All blocks to be appended to the blockchain during the test.</li> </ul>"},{"location":"getting_started/writing_tests/#prepost-state-of-the-test","title":"Pre/Post State of the Test","text":"<p>The <code>pre</code> and <code>post</code> states are elemental to setup and then verify the outcome of the state test.</p> <p>Both <code>pre</code> and <code>post</code> are mappings of account addresses to <code>account</code> structures (see more info).</p> <p>A single test vector can contain as many accounts in the <code>pre</code> and <code>post</code> states as required, and they can be also filled dynamically.</p> <p><code>storage</code> of an account is a key/value dictionary, and its values are integers within range of <code>[0, 2**256 - 1]</code>.</p> <p><code>txs</code> are the steps which transform the pre-state into the post-state and must perform specific actions within the accounts (smart contracts) that result in verifiable changes to the balance, nonce, and/or storage in each of them.</p> <p><code>post</code> is compared against the outcome of the client after the execution of each transaction, and any differences are considered a failure</p> <p>When designing a test, all the changes must be ideally saved into the contract's storage to be able to verify them in the post-state.</p>"},{"location":"getting_started/writing_tests/#test-transactions","title":"Test Transactions","text":"<p>Transactions can be crafted by sending them with specific <code>data</code> or to a specific account, which contains the code to be executed</p> <p>Transactions can also create more accounts, by setting the <code>to</code> field to an  empty string.</p> <p>Transactions can be designed to fail, and a verification must be made that the transaction fails with the specific error that matches what is expected by the test.</p>"},{"location":"getting_started/writing_tests/#writing-code-for-the-accounts-in-the-test","title":"Writing code for the accounts in the test","text":"<p>Account bytecode can be embedded in the test accounts by adding it to the <code>code</code> field of the <code>account</code> object, or the <code>data</code> field of the <code>tx</code> object if the bytecode is meant to be treated as init code or call data.</p> <p>The code can be in either of the following formats: - <code>bytes</code> object, representing the raw opcodes in binary format - <code>str</code>, representing an hexadecimal format of the opcodes - <code>Code</code> compilable object</p> <p>Currently supported built-in compilable objects are:</p> <ul> <li><code>Yul</code> object containing Yul source code</li> </ul> <p><code>Code</code> objects can be concatenated together by using the <code>+</code> operator.</p>"},{"location":"getting_started/writing_tests/#verifying-the-accounts-post-state","title":"Verifying the Accounts' Post State","text":"<p>The state of the accounts after all blocks/transactions have been executed is the way of verifying that the execution client actually behaves like the test expects.</p> <p>During their filling process, all tests automatically verify that the accounts specified in their <code>post</code> property actually match what was returned by the transition tool.</p> <p>Within the <code>post</code> dictionary object, an account address can be: - <code>None</code>: The account will not be checked for absence or existence in the   result returned by the transition tool. - <code>Account</code> object: The test expects that this account exist and also has   properties equal to the properties specified by the <code>Account</code> object. - <code>Account.NONEXISTENT</code>: The test expects that this account does not exist in   the result returned by the transition tool, and if the account exists,   it results in error.   E.g. when the transaction creating a contract is expected to fail and the   test wants to verify that the address where the contract was supposed to be   created is indeed empty.</p>"},{"location":"getting_started/writing_tests/#the-account-object","title":"The <code>Account</code> object","text":"<p>The <code>Account</code> object is used to specify the properties of an account to be verified in the post state.</p> <p>The python representation can be found in src/ethereum_test_tools/common/types.py.</p> <p>It can verify the following properties of an account: - <code>nonce</code>: the scalar value equal to a) the number of transactions sent by   an Externally Owned Account, b) the amount of contracts created by a contract.</p> <ul> <li> <p><code>balance</code>: the amount of Wei (10-18 Eth) the account has.</p> </li> <li> <p><code>code</code>: Bytecode contained by the account. To verify that an account contains   no code, this property needs to be set to \"0x\" or \"\".</p> </li> </ul> <p>It is not recommended to verify Yul compiled code in the output account,   because the bytecode can change from version to version.</p> <ul> <li><code>storage</code>: Storage within the account represented as a <code>dict</code> object.   All storage keys that are expected to be set must be specified, and if a   key is skipped, it is implied that its expected value is zero.   Setting this property to <code>{}</code> (empty <code>dict</code>), means that all the keys in the   account must be unset (equal to zero).</li> </ul> <p>All account's properties are optional, and they can be skipped or set to <code>None</code>, which means that no check will be performed on that specific account property.</p>"},{"location":"getting_started/writing_tests/#verifying-correctness-of-the-new-test","title":"Verifying correctness of the new test","text":"<p>A well written test performs a single verification output at a time.</p> <p>A verification output can be a single storage slot, the balance of an account, or a newly created contract.</p> <p>It is not recommended to use balance changes to verify test correctness, as it can be easily affected by gas cost changes in future EIPs.</p> <p>The best way to verify a transaction/block execution outcome is to check its storage.</p> <p>A test can be written as a negative verification. E.g. a contract is not created, or a transaction fails to execute or runs out of gas.</p> <p>These verifications must be carefully crafted because it is possible to end up having a false positive result, which means that the test passed but the intended verification was never made.</p> <p>To avoid these scenarios, it is important to have a separate verification to check that test is effective. E.g. when a transaction is supposed to fail, it is necessary to check that the failure error is actually the one expected by the test.</p>"},{"location":"getting_started/writing_tests/#failing-or-invalid-transactions","title":"Failing or invalid transactions","text":"<p>Transactions included in a StateTest are expected to be intrinsically valid, i.e. the account sending the transaction must have enough funds to cover the gas costs, the max fee of the transaction must be equal or higher than the base fee of the block, etc.</p> <p>An intrinsically valid transaction can still revert during its execution.</p> <p>Blocks in a BlockchainTest can contain intrinsically invalid transactions but in this case the block is expected to be completely rejected, along with all transactions in it, including other valid transactions.</p>"},{"location":"library/ethereum_test_forks/","title":"EVM Test Forks package","text":"<p>Ethereum test fork definitions.</p>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ArrowGlacier","title":"<code>ArrowGlacier</code>","text":"<p>         Bases: <code>London</code></p> <p>Arrow Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ArrowGlacier(London):\n\"\"\"\n    Arrow Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin","title":"<code>Berlin</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Berlin fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Berlin(Istanbul):\n\"\"\"\n    Berlin fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.BerlinToLondonAt5","title":"<code>BerlinToLondonAt5</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>Berlin to London transition at Block 5 fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=London)\nclass BerlinToLondonAt5(Berlin):\n\"\"\"\n    Berlin to London transition at Block 5 fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\n        return block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.BerlinToLondonAt5.header_base_fee_required","title":"<code>header_base_fee_required(block_number, _)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\n    return block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium","title":"<code>Byzantium</code>","text":"<p>         Bases: <code>Homestead</code></p> <p>Byzantium fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Byzantium(Homestead):\n\"\"\"\n    Byzantium fork\n    \"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Byzantium, the block reward is reduced to\n        3_000_000_000_000_000_000 wei\n        \"\"\"\n        return 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Byzantium.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Byzantium, the block reward is reduced to 3_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Byzantium, the block reward is reduced to\n    3_000_000_000_000_000_000 wei\n    \"\"\"\n    return 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun","title":"<code>Cancun</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Cancun fork</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>class Cancun(Shanghai):\n\"\"\"\n    Cancun fork\n    \"\"\"\n\n    @classmethod\n    def header_excess_data_gas_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Excess data gas is required starting from Cancun.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.upcoming.Cancun.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Excess data gas is required starting from Cancun.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople","title":"<code>Constantinople</code>","text":"<p>         Bases: <code>Byzantium</code></p> <p>Constantinople fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Constantinople(Byzantium):\n\"\"\"\n    Constantinople fork\n    \"\"\"\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Constantinople, the block reward is reduced to\n        2_000_000_000_000_000_000 wei\n        \"\"\"\n        return 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Constantinople.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Constantinople, the block reward is reduced to 2_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Constantinople, the block reward is reduced to\n    2_000_000_000_000_000_000 wei\n    \"\"\"\n    return 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ConstantinopleFix","title":"<code>ConstantinopleFix</code>","text":"<p>         Bases: <code>Constantinople</code></p> <p>Constantinople Fix fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ConstantinopleFix(Constantinople):\n\"\"\"\n    Constantinople Fix fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier","title":"<code>Frontier</code>","text":"<p>         Bases: <code>BaseFork</code></p> <p>Frontier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Frontier(BaseFork):\n\"\"\"\n    Frontier fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain base fee\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_prev_randao_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain Prev Randao value\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_zero_difficulty_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not have difficulty zero\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_withdrawals_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain withdrawals\n        \"\"\"\n        return False\n\n    @classmethod\n    def header_excess_data_gas_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain excess data gas\n        \"\"\"\n        return False\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Genesis the expected reward amount in wei is\n        5_000_000_000_000_000_000\n        \"\"\"\n        return 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Genesis the expected reward amount in wei is 5_000_000_000_000_000_000</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Genesis the expected reward amount in wei is\n    5_000_000_000_000_000_000\n    \"\"\"\n    return 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain base fee</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain base fee\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain excess data gas</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain excess data gas\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain Prev Randao value</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain Prev Randao value\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain withdrawals</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain withdrawals\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not have difficulty zero</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not have difficulty zero\n    \"\"\"\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.GrayGlacier","title":"<code>GrayGlacier</code>","text":"<p>         Bases: <code>ArrowGlacier</code></p> <p>Gray Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class GrayGlacier(ArrowGlacier):\n\"\"\"\n    Gray Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead","title":"<code>Homestead</code>","text":"<p>         Bases: <code>Frontier</code></p> <p>Homestead fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Homestead(Frontier):\n\"\"\"\n    Homestead fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.InvalidForkError","title":"<code>InvalidForkError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Invalid fork error raised when the fork specified by command-line option --latest-fork is not found.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>class InvalidForkError(Exception):\n\"\"\"\n    Invalid fork error raised when the fork specified by command-line option\n    --latest-fork is not found.\n    \"\"\"\n\n    def __init__(self, message):\n        super().__init__(message)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul","title":"<code>Istanbul</code>","text":"<p>         Bases: <code>ConstantinopleFix</code></p> <p>Istanbul fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Istanbul(ConstantinopleFix):\n\"\"\"\n    Istanbul fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London","title":"<code>London</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>London fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class London(Berlin):\n\"\"\"\n    London fork\n    \"\"\"\n\n    @classmethod\n    def header_base_fee_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.London.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Merge","title":"<code>Merge</code>","text":"<p>         Bases: <code>London</code></p> <p>Merge fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Merge(London):\n\"\"\"\n    Merge fork\n    \"\"\"\n\n    @classmethod\n    def header_prev_randao_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Prev Randao is required starting from Merge.\n        \"\"\"\n        return True\n\n    @classmethod\n    def header_zero_difficulty_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Zero difficulty is required starting from Merge.\n        \"\"\"\n        return True\n\n    @classmethod\n    def get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        Merge updates the reward to 0.\n        \"\"\"\n        return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Merge updates the reward to 0.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    Merge updates the reward to 0.\n    \"\"\"\n    return 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Prev Randao is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Prev Randao is required starting from Merge.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Zero difficulty is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Zero difficulty is required starting from Merge.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MergeToShanghaiAtTime15k","title":"<code>MergeToShanghaiAtTime15k</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Merge to Shanghai transition at Timestamp 15k fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Shanghai)\nclass MergeToShanghaiAtTime15k(Merge):\n\"\"\"\n    Merge to Shanghai transition at Timestamp 15k fork\n    \"\"\"\n\n    @classmethod\n    def header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\n        return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.MergeToShanghaiAtTime15k.header_withdrawals_required","title":"<code>header_withdrawals_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\n    return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MuirGlacier","title":"<code>MuirGlacier</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Muir Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class MuirGlacier(Istanbul):\n\"\"\"\n    Muir Glacier fork\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai","title":"<code>Shanghai</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Shanghai fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Shanghai(Merge):\n\"\"\"\n    Shanghai fork\n    \"\"\"\n\n    @classmethod\n    def header_withdrawals_required(\n        cls, block_number: int, timestamp: int\n    ) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Shanghai.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\n    cls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ShanghaiToCancunAtTime15k","title":"<code>ShanghaiToCancunAtTime15k</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Shanghai to Cancun transition at Timestamp 15k</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Cancun)\nclass ShanghaiToCancunAtTime15k(Shanghai):\n\"\"\"\n    Shanghai to Cancun transition at Timestamp 15k\n    \"\"\"\n\n    @classmethod\n    def header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Excess data gas is required if transitioning to Cancun.\n        \"\"\"\n        return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.ShanghaiToCancunAtTime15k.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required if transitioning to Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Excess data gas is required if transitioning to Cancun.\n    \"\"\"\n    return timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.fork_only","title":"<code>fork_only(fork)</code>","text":"<p>Returns the specified fork only if it's a fork that precedes the latest</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def fork_only(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork only if it's a fork that precedes the latest\n    \"\"\"\n    if issubclass(fork, TransitionBaseClass):\n        if fork.transitions_to() is not None:\n            if is_fork(\n                latest_fork_resolver.latest_fork, fork.transitions_to()\n            ):\n                return [fork]\n        return []\n    if is_fork(latest_fork_resolver.latest_fork, fork):\n        return [fork]\n    return []\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from","title":"<code>forks_from(fork)</code>","text":"<p>Returns the specified fork and all forks after it</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it\n    \"\"\"\n    return forks_from_until(fork, latest_fork_resolver.latest_fork)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from_until","title":"<code>forks_from_until(fork_from, fork_until)</code>","text":"<p>Returns the specified fork and all forks after it until and including the second specified fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from_until(fork_from: Fork, fork_until: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it until and including the\n    second specified fork\n    \"\"\"\n    prev_fork = fork_until\n\n    forks: List[Fork] = []\n\n    while prev_fork != BaseFork and prev_fork != fork_from:\n        forks.insert(0, prev_fork)\n\n        prev_fork = prev_fork.__base__\n\n    if prev_fork == BaseFork:\n        return []\n\n    forks.insert(0, fork_from)\n\n    return forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.is_fork","title":"<code>is_fork(fork, which)</code>","text":"<p>Returns <code>True</code> if <code>fork</code> is <code>which</code> or beyond, `False otherwise.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def is_fork(fork: Fork, which: Fork) -&gt; bool:\n\"\"\"\n    Returns `True` if `fork` is `which` or beyond, `False otherwise.\n    \"\"\"\n    prev_fork = fork\n\n    while prev_fork != BaseFork:\n        if prev_fork == which:\n            return True\n\n        prev_fork = prev_fork.__base__\n\n    return False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork","title":"<code>set_latest_fork(fork)</code>","text":"<p>Sets the latest fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork(fork: Fork) -&gt; None:\n\"\"\"\n    Sets the latest fork\n    \"\"\"\n    latest_fork_resolver.latest_fork = fork\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork_by_name","title":"<code>set_latest_fork_by_name(fork_name)</code>","text":"<p>Sets the latest fork by name</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork_by_name(fork_name: str) -&gt; None:\n\"\"\"\n    Sets the latest fork by name\n    \"\"\"\n    if fork_name in forks.__dict__:\n        set_latest_fork(forks.__dict__[fork_name])\n    elif fork_name in upcoming.__dict__:\n        set_latest_fork(upcoming.__dict__[fork_name])\n    else:\n        raise InvalidForkError(f'fork \"{fork_name}\" not found')\n</code></pre>"},{"location":"library/ethereum_test_tools/","title":"Ethereum Test Tools Package","text":"<p>Module containing tools for generating cross-client Ethereum execution layer tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.AccessList","title":"<code>AccessList</code>  <code>dataclass</code>","text":"<p>Access List for transactions.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass AccessList:\n\"\"\"\n    Access List for transactions.\n    \"\"\"\n\n    address: str\n    storage_keys: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>State associated with an address.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Account:\n\"\"\"\n    State associated with an address.\n    \"\"\"\n\n    nonce: int | None = None\n\"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\n    balance: int | None = None\n\"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\n    code: str | bytes | Code | None = None\n\"\"\"\n    Bytecode contained by the account.\n    \"\"\"\n    storage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None\n\"\"\"\n    Storage within a contract.\n    \"\"\"\n\n    NONEXISTENT: ClassVar[object] = object()\n\"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\n\n    class NonceMismatch(Exception):\n\"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\n\n        address: str\n        want: int | None\n        got: int | None\n\n        def __init__(\n            self, address: str, want: int | None, got: int | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected nonce for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    class BalanceMismatch(Exception):\n\"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\n\n        address: str\n        want: int | None\n        got: int | None\n\n        def __init__(\n            self, address: str, want: int | None, got: int | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected balance for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    class CodeMismatch(Exception):\n\"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\n\n        address: str\n        want: str | None\n        got: str | None\n\n        def __init__(\n            self, address: str, want: str | None, got: str | None, *args\n        ):\n            super().__init__(args)\n            self.address = address\n            self.want = want\n            self.got = got\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                f\"unexpected code for account {self.address}: \"\n                + f\"want {self.want}, got {self.got}\"\n            )\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\n        if self.storage is not None and type(self.storage) is dict:\n            self.storage = Storage(self.storage)\n\n    def check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n        Checks the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\n        if self.nonce is not None:\n            actual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\n            if self.nonce != actual_nonce:\n                raise Account.NonceMismatch(\n                    address=address,\n                    want=self.nonce,\n                    got=actual_nonce,\n                )\n\n        if self.balance is not None:\n            actual_balance = int_or_none(alloc.get(\"balance\"), 0)\n            if self.balance != actual_balance:\n                raise Account.BalanceMismatch(\n                    address=address,\n                    want=self.balance,\n                    got=actual_balance,\n                )\n\n        if self.code is not None:\n            expected_code = code_to_hex(self.code)\n            actual_code = str_or_none(alloc.get(\"code\"), \"0x\")\n            if expected_code != actual_code:\n                raise Account.CodeMismatch(\n                    address=address,\n                    want=expected_code,\n                    got=actual_code,\n                )\n\n        if self.storage is not None:\n            expected_storage = (\n                self.storage\n                if isinstance(self.storage, Storage)\n                else Storage(self.storage)\n            )\n            actual_storage = (\n                Storage(alloc[\"storage\"])\n                if \"storage\" in alloc\n                else Storage({})\n            )\n            expected_storage.must_be_equal(actual_storage)\n\n    @classmethod\n    def with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n        Create account with provided `code` and nonce of `1`.\n        \"\"\"\n        return Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NONEXISTENT","title":"<code>NONEXISTENT: object = object()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.balance","title":"<code>balance: int | None = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The amount of Wei (10-18 Eth) the account has.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.code","title":"<code>code: str | bytes | Code | None = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.nonce","title":"<code>nonce: int | None = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.storage","title":"<code>storage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch","title":"<code>BalanceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class BalanceMismatch(Exception):\n\"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\n\n    address: str\n    want: int | None\n    got: int | None\n\n    def __init__(\n        self, address: str, want: int | None, got: int | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected balance for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected balance for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch","title":"<code>CodeMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class CodeMismatch(Exception):\n\"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\n\n    address: str\n    want: str | None\n    got: str | None\n\n    def __init__(\n        self, address: str, want: str | None, got: str | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected code for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected code for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch","title":"<code>NonceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class NonceMismatch(Exception):\n\"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\n\n    address: str\n    want: int | None\n    got: int | None\n\n    def __init__(\n        self, address: str, want: int | None, got: int | None, *args\n    ):\n        super().__init__(args)\n        self.address = address\n        self.want = want\n        self.got = got\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            f\"unexpected nonce for account {self.address}: \"\n            + f\"want {self.want}, got {self.got}\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        f\"unexpected nonce for account {self.address}: \"\n        + f\"want {self.want}, got {self.got}\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Automatically init account members</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\n    if self.storage is not None and type(self.storage) is dict:\n        self.storage = Storage(self.storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.check_alloc","title":"<code>check_alloc(address, alloc)</code>","text":"<p>Checks the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n    Checks the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\n    if self.nonce is not None:\n        actual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\n        if self.nonce != actual_nonce:\n            raise Account.NonceMismatch(\n                address=address,\n                want=self.nonce,\n                got=actual_nonce,\n            )\n\n    if self.balance is not None:\n        actual_balance = int_or_none(alloc.get(\"balance\"), 0)\n        if self.balance != actual_balance:\n            raise Account.BalanceMismatch(\n                address=address,\n                want=self.balance,\n                got=actual_balance,\n            )\n\n    if self.code is not None:\n        expected_code = code_to_hex(self.code)\n        actual_code = str_or_none(alloc.get(\"code\"), \"0x\")\n        if expected_code != actual_code:\n            raise Account.CodeMismatch(\n                address=address,\n                want=expected_code,\n                got=actual_code,\n            )\n\n    if self.storage is not None:\n        expected_storage = (\n            self.storage\n            if isinstance(self.storage, Storage)\n            else Storage(self.storage)\n        )\n        actual_storage = (\n            Storage(alloc[\"storage\"])\n            if \"storage\" in alloc\n            else Storage({})\n        )\n        expected_storage.must_be_equal(actual_storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n    Create account with provided `code` and nonce of `1`.\n    \"\"\"\n    return Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest","title":"<code>BaseTest</code>","text":"<p>Represents a base Ethereum test which must return a genesis and a blockchain.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>class BaseTest:\n\"\"\"\n    Represents a base Ethereum test which must return a genesis and a\n    blockchain.\n    \"\"\"\n\n    pre: Mapping[str, Account]\n    tag: str = \"\"\n\n    @abstractmethod\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the test definition.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id: int = 1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Generate the blockchain that must be executed sequentially during test.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Must return the name of the parameter used in pytest to select this\n        spec type as filler for the test.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Generate the blockchain that must be executed sequentially during test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id: int = 1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Generate the blockchain that must be executed sequentially during test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>  <code>abstractmethod</code>","text":"<p>Create a genesis block from the test definition.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the test definition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Must return the name of the parameter used in pytest to select this spec type as filler for the test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@classmethod\n@abstractmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Must return the name of the parameter used in pytest to select this\n    spec type as filler for the test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Header</code></p> <p>Block type used to describe block properties in test specs</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Block(Header):\n\"\"\"\n    Block type used to describe block properties in test specs\n    \"\"\"\n\n    rlp: Optional[str] = None\n\"\"\"\n    If set, blockchain test will skip generating the block using\n    `evm_block_builder`, and will pass this value directly to the Fixture.\n\n    Only meant to be used to simulate blocks with bad formats, and therefore\n    requires the block to produce an exception.\n    \"\"\"\n    rlp_modifier: Optional[Header] = None\n\"\"\"\n    An RLP modifying header which values would be used to override the ones\n    returned by the  `evm_transition_tool`.\n    \"\"\"\n    exception: Optional[str] = None\n\"\"\"\n    If set, the block is expected to be rejected by the client.\n    \"\"\"\n    txs: Optional[List[Transaction]] = None\n\"\"\"\n    List of transactions included in the block.\n    \"\"\"\n    ommers: Optional[List[Header]] = None\n\"\"\"\n    List of ommer headers included in the block.\n    \"\"\"\n    withdrawals: Optional[List[Withdrawal]] = None\n\"\"\"\n    List of withdrawals to perform for this block.\n    \"\"\"\n\n    def set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n        Creates a copy of the environment with the characteristics of this\n        specific block.\n        \"\"\"\n        new_env = copy(env)\n\n\"\"\"\n        Values that need to be set in the environment and are `None` for\n        this block need to be set to their defaults.\n        \"\"\"\n        environment_default = Environment()\n        new_env.difficulty = self.difficulty\n        new_env.coinbase = (\n            self.coinbase\n            if self.coinbase is not None\n            else environment_default.coinbase\n        )\n        new_env.gas_limit = (\n            self.gas_limit\n            if self.gas_limit is not None\n            else environment_default.gas_limit\n        )\n        if not isinstance(self.base_fee, REMOVABLE):\n            new_env.base_fee = self.base_fee\n        new_env.withdrawals = self.withdrawals\n        if not isinstance(self.excess_data_gas, REMOVABLE):\n            new_env.excess_data_gas = self.excess_data_gas\n\n\"\"\"\n        These values are required, but they depend on the previous environment,\n        so they can be calculated here.\n        \"\"\"\n        if self.number is not None:\n            new_env.number = self.number\n        else:\n            # calculate the next block number for the environment\n            if len(new_env.block_hashes) == 0:\n                new_env.number = 0\n            else:\n                new_env.number = max(new_env.block_hashes.keys()) + 1\n\n        if self.timestamp is not None:\n            new_env.timestamp = self.timestamp\n        else:\n            assert new_env.parent_timestamp is not None\n            new_env.timestamp = new_env.parent_timestamp + 12\n\n        return new_env\n\n    def copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n        Creates a copy of the block and adds the specified RLP.\n        \"\"\"\n        new_block = deepcopy(self)\n        new_block.rlp = rlp\n        return new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.exception","title":"<code>exception: Optional[str] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>If set, the block is expected to be rejected by the client.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.ommers","title":"<code>ommers: Optional[List[Header]] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>List of ommer headers included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp","title":"<code>rlp: Optional[str] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>If set, blockchain test will skip generating the block using <code>evm_block_builder</code>, and will pass this value directly to the Fixture.</p> <p>Only meant to be used to simulate blocks with bad formats, and therefore requires the block to produce an exception.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp_modifier","title":"<code>rlp_modifier: Optional[Header] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>An RLP modifying header which values would be used to override the ones returned by the  <code>evm_transition_tool</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.txs","title":"<code>txs: Optional[List[Transaction]] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>List of transactions included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.withdrawals","title":"<code>withdrawals: Optional[List[Withdrawal]] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>List of withdrawals to perform for this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.copy_with_rlp","title":"<code>copy_with_rlp(rlp)</code>","text":"<p>Creates a copy of the block and adds the specified RLP.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n    Creates a copy of the block and adds the specified RLP.\n    \"\"\"\n    new_block = deepcopy(self)\n    new_block.rlp = rlp\n    return new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.set_environment","title":"<code>set_environment(env)</code>","text":"<p>Creates a copy of the environment with the characteristics of this specific block.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n    Creates a copy of the environment with the characteristics of this\n    specific block.\n    \"\"\"\n    new_env = copy(env)\n\n\"\"\"\n    Values that need to be set in the environment and are `None` for\n    this block need to be set to their defaults.\n    \"\"\"\n    environment_default = Environment()\n    new_env.difficulty = self.difficulty\n    new_env.coinbase = (\n        self.coinbase\n        if self.coinbase is not None\n        else environment_default.coinbase\n    )\n    new_env.gas_limit = (\n        self.gas_limit\n        if self.gas_limit is not None\n        else environment_default.gas_limit\n    )\n    if not isinstance(self.base_fee, REMOVABLE):\n        new_env.base_fee = self.base_fee\n    new_env.withdrawals = self.withdrawals\n    if not isinstance(self.excess_data_gas, REMOVABLE):\n        new_env.excess_data_gas = self.excess_data_gas\n\n\"\"\"\n    These values are required, but they depend on the previous environment,\n    so they can be calculated here.\n    \"\"\"\n    if self.number is not None:\n        new_env.number = self.number\n    else:\n        # calculate the next block number for the environment\n        if len(new_env.block_hashes) == 0:\n            new_env.number = 0\n        else:\n            new_env.number = max(new_env.block_hashes.keys()) + 1\n\n    if self.timestamp is not None:\n        new_env.timestamp = self.timestamp\n    else:\n        assert new_env.parent_timestamp is not None\n        new_env.timestamp = new_env.parent_timestamp + 12\n\n    return new_env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest","title":"<code>BlockchainTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests multiple blocks (valid or invalid) in a chain.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass BlockchainTest(BaseTest):\n\"\"\"\n    Filler type that tests multiple blocks (valid or invalid) in a chain.\n    \"\"\"\n\n    pre: Mapping[str, Account]\n    post: Mapping[str, Account]\n    blocks: List[Block]\n    genesis_environment: Environment = Environment()\n    tag: str = \"\"\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\n        return \"blockchain_test\"\n\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\n        env = self.genesis_environment.set_fork_requirements(fork)\n\n        genesis = FixtureHeader(\n            parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            coinbase=\"0x0000000000000000000000000000000000000000\",\n            state_root=t8n.calc_state_root(\n                to_json(self.pre),\n                fork,\n            ),\n            transactions_root=EmptyTrieRoot,\n            receipt_root=EmptyTrieRoot,\n            bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=0,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=\"0x00\",\n            mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            nonce=\"0x0000000000000000\",\n            base_fee=env.base_fee,\n            excess_data_gas=env.excess_data_gas,\n            withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n            if env.withdrawals is not None\n            else None,\n        )\n\n        (genesis_rlp, genesis.hash) = b11r.build(\n            header=genesis.to_geth_dict(),\n            txs=\"\",\n            ommers=[],\n            withdrawals=env.withdrawals,\n        )\n        return genesis_rlp, genesis\n\n    def make_block(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n        block: Block,\n        previous_env: Environment,\n        previous_alloc: Dict[str, Any],\n        previous_head: str,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n        Produces a block based on the previous environment and allocation.\n        If the block is an invalid block, the environment and allocation\n        returned are the same as passed as parameters.\n        Raises exception on invalid test behavior.\n\n        Returns\n        -------\n            FixtureBlock: Block to be appended to the fixture.\n            Environment: Environment for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                environment as the one passed as parameter.\n            Dict[str, Any]: Allocation for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                allocation as the one passed as parameter.\n            str: Hash of the head of the chain, only updated if the produced\n                block is not invalid.\n\n        \"\"\"\n        if block.rlp and block.exception is not None:\n            raise Exception(\n                \"test correctness: post-state cannot be verified if the \"\n                + \"block's rlp is supplied and the block is not supposed \"\n                + \"to produce an exception\"\n            )\n\n        if block.rlp is None:\n            # This is the most common case, the RLP needs to be constructed\n            # based on the transactions to be included in the block.\n            # Set the environment according to the block to execute.\n            env = block.set_environment(previous_env)\n            env = env.set_fork_requirements(fork)\n\n            (next_alloc, result, txs_rlp) = t8n.evaluate(\n                alloc=previous_alloc,\n                txs=to_json_or_none(block.txs),\n                env=to_json(env),\n                fork=fork,\n                chain_id=chain_id,\n                reward=fork.get_reward(env.number, env.timestamp),\n                eips=eips,\n            )\n            try:\n                rejected_txs = verify_transactions(block.txs, result)\n            except Exception as e:\n                print_traces(t8n.get_traces())\n                pprint(result)\n                pprint(previous_alloc)\n                pprint(next_alloc)\n                raise e\n\n            if len(rejected_txs) &gt; 0 and block.exception is None:\n                print_traces(t8n.get_traces())\n                raise Exception(\n                    \"one or more transactions in `BlockchainTest` are \"\n                    + \"intrinsically invalid, but the block was not expected \"\n                    + \"to be invalid. Please verify whether the transaction \"\n                    + \"was indeed expected to fail and add the proper \"\n                    + \"`block.exception`\"\n                )\n\n            header = FixtureHeader.from_dict(\n                result\n                | {\n                    \"parentHash\": env.parent_hash(),\n                    \"miner\": env.coinbase,\n                    \"transactionsRoot\": result.get(\"txRoot\"),\n                    \"difficulty\": str_or_none(\n                        result.get(\"currentDifficulty\"), \"0\"\n                    ),\n                    \"number\": str(env.number),\n                    \"gasLimit\": str(env.gas_limit),\n                    \"timestamp\": str(env.timestamp),\n                    \"extraData\": block.extra_data\n                    if block.extra_data is not None\n                    and len(block.extra_data) != 0\n                    else \"0x\",\n                    \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                    \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                    \"nonce\": \"0x0000000000000000\",\n                    \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                    \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n                }\n            )\n\n            assert len(header.state_root) == 66\n\n            if block.rlp_modifier is not None:\n                # Modify any parameter specified in the `rlp_modifier` after\n                # transition tool processing.\n                header = header.join(block.rlp_modifier)\n\n            rlp, header.hash = b11r.build(\n                header=header.to_geth_dict(),\n                txs=txs_rlp,\n                ommers=[],\n                withdrawals=to_json_or_none(env.withdrawals),\n            )\n\n            if block.exception is None:\n                # Return environment and allocation of the following block\n                return (\n                    FixtureBlock(\n                        rlp=rlp,\n                        block_header=header,\n                        block_number=header.number,\n                        txs=block.txs if block.txs is not None else [],\n                        ommers=[],\n                        withdrawals=env.withdrawals,\n                    ),\n                    env.apply_new_parent(header),\n                    next_alloc,\n                    header.hash,\n                )\n            else:\n                return (\n                    FixtureBlock(\n                        rlp=rlp,\n                        expected_exception=block.exception,\n                        block_number=header.number,\n                    ),\n                    previous_env,\n                    previous_alloc,\n                    previous_head,\n                )\n        else:\n            return (\n                FixtureBlock(\n                    rlp=block.rlp,\n                    expected_exception=block.exception,\n                ),\n                previous_env,\n                previous_alloc,\n                previous_head,\n            )\n\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block list from the blockchain test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\n        alloc = to_json(self.pre)\n        env = Environment.from_parent_header(genesis)\n        blocks: List[FixtureBlock] = []\n        head = (\n            genesis.hash\n            if genesis.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        )\n        for block in self.blocks:\n            fixture_block, env, alloc, head = self.make_block(\n                b11r=b11r,\n                t8n=t8n,\n                fork=fork,\n                block=block,\n                previous_env=env,\n                previous_alloc=alloc,\n                previous_head=head,\n                chain_id=chain_id,\n                eips=eips,\n            )\n            blocks.append(fixture_block)\n\n        try:\n            verify_post_alloc(self.post, alloc)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            raise e\n\n        return (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block","title":"<code>make_block(b11r, t8n, fork, block, previous_env, previous_alloc, previous_head, chain_id=1, eips=None)</code>","text":"<p>Produces a block based on the previous environment and allocation. If the block is an invalid block, the environment and allocation returned are the same as passed as parameters. Raises exception on invalid test behavior.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block--returns","title":"Returns","text":"<pre><code>FixtureBlock: Block to be appended to the fixture.\nEnvironment: Environment for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    environment as the one passed as parameter.\nDict[str, Any]: Allocation for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    allocation as the one passed as parameter.\nstr: Hash of the head of the chain, only updated if the produced\n    block is not invalid.\n</code></pre> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_block(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n    block: Block,\n    previous_env: Environment,\n    previous_alloc: Dict[str, Any],\n    previous_head: str,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n    Produces a block based on the previous environment and allocation.\n    If the block is an invalid block, the environment and allocation\n    returned are the same as passed as parameters.\n    Raises exception on invalid test behavior.\n\n    Returns\n    -------\n        FixtureBlock: Block to be appended to the fixture.\n        Environment: Environment for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            environment as the one passed as parameter.\n        Dict[str, Any]: Allocation for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            allocation as the one passed as parameter.\n        str: Hash of the head of the chain, only updated if the produced\n            block is not invalid.\n\n    \"\"\"\n    if block.rlp and block.exception is not None:\n        raise Exception(\n            \"test correctness: post-state cannot be verified if the \"\n            + \"block's rlp is supplied and the block is not supposed \"\n            + \"to produce an exception\"\n        )\n\n    if block.rlp is None:\n        # This is the most common case, the RLP needs to be constructed\n        # based on the transactions to be included in the block.\n        # Set the environment according to the block to execute.\n        env = block.set_environment(previous_env)\n        env = env.set_fork_requirements(fork)\n\n        (next_alloc, result, txs_rlp) = t8n.evaluate(\n            alloc=previous_alloc,\n            txs=to_json_or_none(block.txs),\n            env=to_json(env),\n            fork=fork,\n            chain_id=chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            eips=eips,\n        )\n        try:\n            rejected_txs = verify_transactions(block.txs, result)\n        except Exception as e:\n            print_traces(t8n.get_traces())\n            pprint(result)\n            pprint(previous_alloc)\n            pprint(next_alloc)\n            raise e\n\n        if len(rejected_txs) &gt; 0 and block.exception is None:\n            print_traces(t8n.get_traces())\n            raise Exception(\n                \"one or more transactions in `BlockchainTest` are \"\n                + \"intrinsically invalid, but the block was not expected \"\n                + \"to be invalid. Please verify whether the transaction \"\n                + \"was indeed expected to fail and add the proper \"\n                + \"`block.exception`\"\n            )\n\n        header = FixtureHeader.from_dict(\n            result\n            | {\n                \"parentHash\": env.parent_hash(),\n                \"miner\": env.coinbase,\n                \"transactionsRoot\": result.get(\"txRoot\"),\n                \"difficulty\": str_or_none(\n                    result.get(\"currentDifficulty\"), \"0\"\n                ),\n                \"number\": str(env.number),\n                \"gasLimit\": str(env.gas_limit),\n                \"timestamp\": str(env.timestamp),\n                \"extraData\": block.extra_data\n                if block.extra_data is not None\n                and len(block.extra_data) != 0\n                else \"0x\",\n                \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                \"nonce\": \"0x0000000000000000\",\n                \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n            }\n        )\n\n        assert len(header.state_root) == 66\n\n        if block.rlp_modifier is not None:\n            # Modify any parameter specified in the `rlp_modifier` after\n            # transition tool processing.\n            header = header.join(block.rlp_modifier)\n\n        rlp, header.hash = b11r.build(\n            header=header.to_geth_dict(),\n            txs=txs_rlp,\n            ommers=[],\n            withdrawals=to_json_or_none(env.withdrawals),\n        )\n\n        if block.exception is None:\n            # Return environment and allocation of the following block\n            return (\n                FixtureBlock(\n                    rlp=rlp,\n                    block_header=header,\n                    block_number=header.number,\n                    txs=block.txs if block.txs is not None else [],\n                    ommers=[],\n                    withdrawals=env.withdrawals,\n                ),\n                env.apply_new_parent(header),\n                next_alloc,\n                header.hash,\n            )\n        else:\n            return (\n                FixtureBlock(\n                    rlp=rlp,\n                    expected_exception=block.exception,\n                    block_number=header.number,\n                ),\n                previous_env,\n                previous_alloc,\n                previous_head,\n            )\n    else:\n        return (\n            FixtureBlock(\n                rlp=block.rlp,\n                expected_exception=block.exception,\n            ),\n            previous_env,\n            previous_alloc,\n            previous_head,\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block list from the blockchain test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block list from the blockchain test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\n    alloc = to_json(self.pre)\n    env = Environment.from_parent_header(genesis)\n    blocks: List[FixtureBlock] = []\n    head = (\n        genesis.hash\n        if genesis.hash is not None\n        else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    )\n    for block in self.blocks:\n        fixture_block, env, alloc, head = self.make_block(\n            b11r=b11r,\n            t8n=t8n,\n            fork=fork,\n            block=block,\n            previous_env=env,\n            previous_alloc=alloc,\n            previous_head=head,\n            chain_id=chain_id,\n            eips=eips,\n        )\n        blocks.append(fixture_block)\n\n    try:\n        verify_post_alloc(self.post, alloc)\n    except Exception as e:\n        print_traces(t8n.get_traces())\n        raise e\n\n    return (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\n    env = self.genesis_environment.set_fork_requirements(fork)\n\n    genesis = FixtureHeader(\n        parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n        coinbase=\"0x0000000000000000000000000000000000000000\",\n        state_root=t8n.calc_state_root(\n            to_json(self.pre),\n            fork,\n        ),\n        transactions_root=EmptyTrieRoot,\n        receipt_root=EmptyTrieRoot,\n        bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=0,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=\"0x00\",\n        mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        nonce=\"0x0000000000000000\",\n        base_fee=env.base_fee,\n        excess_data_gas=env.excess_data_gas,\n        withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n        if env.withdrawals is not None\n        else None,\n    )\n\n    (genesis_rlp, genesis.hash) = b11r.build(\n        header=genesis.to_geth_dict(),\n        txs=\"\",\n        ommers=[],\n        withdrawals=env.withdrawals,\n    )\n    return genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\n    return \"blockchain_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Code","title":"<code>Code</code>  <code>dataclass</code>","text":"<p>Generic code object.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>@dataclass(kw_only=True)\nclass Code:\n\"\"\"\n    Generic code object.\n    \"\"\"\n\n    bytecode: Optional[bytes] = None\n\"\"\"\n    bytes array that represents the bytecode of this object.\n    \"\"\"\n    name: Optional[str] = None\n\"\"\"\n    Name used to describe this code.\n    Usually used to add extra information to a test case.\n    \"\"\"\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Transform the Code object into bytes.\n        Normally will be overriden by the classes that inherit this class.\n        \"\"\"\n        if self.bytecode is None:\n            return bytes()\n        else:\n            return self.bytecode\n\n    def __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\n        return Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\n\n    def __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\n        return Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.bytecode","title":"<code>bytecode: Optional[bytes] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>bytes array that represents the bytecode of this object.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.name","title":"<code>name: Optional[str] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Name used to describe this code. Usually used to add extra information to a test case.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\n    return Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\n    return Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.assemble","title":"<code>assemble()</code>","text":"<p>Transform the Code object into bytes. Normally will be overriden by the classes that inherit this class.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Transform the Code object into bytes.\n    Normally will be overriden by the classes that inherit this class.\n    \"\"\"\n    if self.bytecode is None:\n        return bytes()\n    else:\n        return self.bytecode\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure","title":"<code>CodeGasMeasure</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate bytecode that measures gas usage of a bytecode, taking into account and subtracting any extra overhead gas costs required to execute. By default, the result gas calculation is saved to storage key 0.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeGasMeasure(Code):\n\"\"\"\n    Helper class used to generate bytecode that measures gas usage of a\n    bytecode, taking into account and subtracting any extra overhead gas costs\n    required to execute.\n    By default, the result gas calculation is saved to storage key 0.\n    \"\"\"\n\n    code: bytes | str | Code\n\"\"\"\n    Bytecode to be executed to measure the gas usage.\n    \"\"\"\n    overhead_cost: int = 0\n\"\"\"\n    Extra gas cost to be subtracted from extra operations.\n    \"\"\"\n    extra_stack_items: int = 0\n\"\"\"\n    Extra stack items that remain at the end of the execution.\n    To be considered when subtracting the value of the previous GAS operation,\n    and to be popped at the end of the execution.\n    \"\"\"\n    sstore_key: int = 0\n\"\"\"\n    Storage key to save the gas used.\n    \"\"\"\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Assemble the bytecode that measures gas usage.\n        \"\"\"\n        res = bytes()\n        res += bytes(\n            [\n                0x5A,  # GAS\n            ]\n        )\n        res += code_to_bytes(self.code)  # Execute code to measure its gas cost\n        res += bytes(\n            [\n                0x5A,  # GAS\n            ]\n        )\n        # We need to swap and pop for each extra stack item that remained from\n        # the execution of the code\n        res += (\n            bytes(\n                [\n                    0x90,  # SWAP1\n                    0x50,  # POP\n                ]\n            )\n            * self.extra_stack_items\n        )\n        res += bytes(\n            [\n                0x90,  # SWAP1\n                0x03,  # SUB\n                0x60,  # PUSH1\n                self.overhead_cost + 2,  # Overhead cost + GAS opcode price\n                0x90,  # SWAP1\n                0x03,  # SUB\n                0x60,  # PUSH1\n                self.sstore_key,  # -&gt; SSTORE key\n                0x55,  # SSTORE\n                0x00,  # STOP\n            ]\n        )\n        return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.code","title":"<code>code: bytes | str | Code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be executed to measure the gas usage.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.extra_stack_items","title":"<code>extra_stack_items: int = 0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Extra stack items that remain at the end of the execution. To be considered when subtracting the value of the previous GAS operation, and to be popped at the end of the execution.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.overhead_cost","title":"<code>overhead_cost: int = 0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Extra gas cost to be subtracted from extra operations.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.sstore_key","title":"<code>sstore_key: int = 0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Storage key to save the gas used.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.assemble","title":"<code>assemble()</code>","text":"<p>Assemble the bytecode that measures gas usage.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assemble the bytecode that measures gas usage.\n    \"\"\"\n    res = bytes()\n    res += bytes(\n        [\n            0x5A,  # GAS\n        ]\n    )\n    res += code_to_bytes(self.code)  # Execute code to measure its gas cost\n    res += bytes(\n        [\n            0x5A,  # GAS\n        ]\n    )\n    # We need to swap and pop for each extra stack item that remained from\n    # the execution of the code\n    res += (\n        bytes(\n            [\n                0x90,  # SWAP1\n                0x50,  # POP\n            ]\n        )\n        * self.extra_stack_items\n    )\n    res += bytes(\n        [\n            0x90,  # SWAP1\n            0x03,  # SUB\n            0x60,  # PUSH1\n            self.overhead_cost + 2,  # Overhead cost + GAS opcode price\n            0x90,  # SWAP1\n            0x03,  # SUB\n            0x60,  # PUSH1\n            self.sstore_key,  # -&gt; SSTORE key\n            0x55,  # SSTORE\n            0x00,  # STOP\n        ]\n    )\n    return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Environment","title":"<code>Environment</code>  <code>dataclass</code>","text":"<p>Structure used to keep track of the context in which a block must be executed.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Environment:\n\"\"\"\n    Structure used to keep track of the context in which a block\n    must be executed.\n    \"\"\"\n\n    coinbase: str = \"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\"\n    gas_limit: int = 100000000000000000\n    number: int = 1\n    timestamp: int = 1000\n    difficulty: Optional[int] = None\n    prev_randao: Optional[int] = None\n    block_hashes: Dict[int, str] = field(default_factory=dict)\n    base_fee: Optional[int] = None\n    parent_difficulty: Optional[int] = None\n    parent_timestamp: Optional[int] = None\n    parent_base_fee: Optional[int] = None\n    parent_gas_used: Optional[int] = None\n    parent_gas_limit: Optional[int] = None\n    parent_ommers_hash: Optional[str] = None\n    withdrawals: Optional[List[Withdrawal]] = None\n    excess_data_gas: Optional[int] = None\n    parent_excess_data_gas: Optional[int] = None\n\n    @staticmethod\n    def from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Instantiates a new environment with the provided header as parent.\n        \"\"\"\n        return Environment(\n            parent_difficulty=parent.difficulty,\n            parent_timestamp=parent.timestamp,\n            parent_base_fee=parent.base_fee,\n            parent_excess_data_gas=parent.excess_data_gas,\n            parent_gas_used=parent.gas_used,\n            parent_gas_limit=parent.gas_limit,\n            parent_ommers_hash=parent.ommers_hash,\n            block_hashes={\n                parent.number: parent.hash\n                if parent.hash is not None\n                else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n            },\n        )\n\n    def parent_hash(self) -&gt; str:\n\"\"\"\n        Obtjains the latest hash according to the highest block number in\n        `block_hashes`.\n        \"\"\"\n        if len(self.block_hashes) == 0:\n            return \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        last_index = max(self.block_hashes.keys())\n        return self.block_hashes[last_index]\n\n    def apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Applies a header as parent to a copy of this environment.\n        \"\"\"\n        env = copy(self)\n        env.parent_difficulty = new_parent.difficulty\n        env.parent_timestamp = new_parent.timestamp\n        env.parent_base_fee = new_parent.base_fee\n        env.parent_excess_data_gas = new_parent.excess_data_gas\n        env.parent_gas_used = new_parent.gas_used\n        env.parent_gas_limit = new_parent.gas_limit\n        env.parent_ommers_hash = new_parent.ommers_hash\n        env.block_hashes[new_parent.number] = (\n            new_parent.hash\n            if new_parent.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        )\n        return env\n\n    def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n        Fills the required fields in an environment depending on the fork.\n        \"\"\"\n        res = copy(self)\n\n        if (\n            fork.header_prev_randao_required(self.number, self.timestamp)\n            and res.prev_randao is None\n        ):\n            res.prev_randao = 0\n\n        if (\n            fork.header_withdrawals_required(self.number, self.timestamp)\n            and res.withdrawals is None\n        ):\n            res.withdrawals = []\n\n        if (\n            fork.header_base_fee_required(self.number, self.timestamp)\n            and res.base_fee is None\n            and res.parent_base_fee is None\n        ):\n            res.base_fee = DEFAULT_BASE_FEE\n\n        if fork.header_zero_difficulty_required(self.number, self.timestamp):\n            res.difficulty = 0\n\n        if (\n            fork.header_excess_data_gas_required(self.number, self.timestamp)\n            and res.excess_data_gas is None\n        ):\n            res.excess_data_gas = 0\n\n        return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.apply_new_parent","title":"<code>apply_new_parent(new_parent)</code>","text":"<p>Applies a header as parent to a copy of this environment.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Applies a header as parent to a copy of this environment.\n    \"\"\"\n    env = copy(self)\n    env.parent_difficulty = new_parent.difficulty\n    env.parent_timestamp = new_parent.timestamp\n    env.parent_base_fee = new_parent.base_fee\n    env.parent_excess_data_gas = new_parent.excess_data_gas\n    env.parent_gas_used = new_parent.gas_used\n    env.parent_gas_limit = new_parent.gas_limit\n    env.parent_ommers_hash = new_parent.ommers_hash\n    env.block_hashes[new_parent.number] = (\n        new_parent.hash\n        if new_parent.hash is not None\n        else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    )\n    return env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.from_parent_header","title":"<code>from_parent_header(parent)</code>  <code>staticmethod</code>","text":"<p>Instantiates a new environment with the provided header as parent.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@staticmethod\ndef from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Instantiates a new environment with the provided header as parent.\n    \"\"\"\n    return Environment(\n        parent_difficulty=parent.difficulty,\n        parent_timestamp=parent.timestamp,\n        parent_base_fee=parent.base_fee,\n        parent_excess_data_gas=parent.excess_data_gas,\n        parent_gas_used=parent.gas_used,\n        parent_gas_limit=parent.gas_limit,\n        parent_ommers_hash=parent.ommers_hash,\n        block_hashes={\n            parent.number: parent.hash\n            if parent.hash is not None\n            else \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n        },\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.parent_hash","title":"<code>parent_hash()</code>","text":"<p>Obtjains the latest hash according to the highest block number in <code>block_hashes</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def parent_hash(self) -&gt; str:\n\"\"\"\n    Obtjains the latest hash according to the highest block number in\n    `block_hashes`.\n    \"\"\"\n    if len(self.block_hashes) == 0:\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n    last_index = max(self.block_hashes.keys())\n    return self.block_hashes[last_index]\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.set_fork_requirements","title":"<code>set_fork_requirements(fork)</code>","text":"<p>Fills the required fields in an environment depending on the fork.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n    Fills the required fields in an environment depending on the fork.\n    \"\"\"\n    res = copy(self)\n\n    if (\n        fork.header_prev_randao_required(self.number, self.timestamp)\n        and res.prev_randao is None\n    ):\n        res.prev_randao = 0\n\n    if (\n        fork.header_withdrawals_required(self.number, self.timestamp)\n        and res.withdrawals is None\n    ):\n        res.withdrawals = []\n\n    if (\n        fork.header_base_fee_required(self.number, self.timestamp)\n        and res.base_fee is None\n        and res.parent_base_fee is None\n    ):\n        res.base_fee = DEFAULT_BASE_FEE\n\n    if fork.header_zero_difficulty_required(self.number, self.timestamp):\n        res.difficulty = 0\n\n    if (\n        fork.header_excess_data_gas_required(self.number, self.timestamp)\n        and res.excess_data_gas is None\n    ):\n        res.excess_data_gas = 0\n\n    return res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Fixture","title":"<code>Fixture</code>  <code>dataclass</code>","text":"<p>Cross-client compatible Ethereum test fixture.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Fixture:\n\"\"\"\n    Cross-client compatible Ethereum test fixture.\n    \"\"\"\n\n    blocks: List[FixtureBlock]\n    genesis: FixtureHeader\n    genesis_rlp: str\n    head: str\n    fork: str\n    pre_state: Mapping[str, Account]\n    post_state: Optional[Mapping[str, Account]]\n    seal_engine: str\n    info: Dict[str, str] = field(default_factory=dict)\n    name: str = \"\"\n    index: int = 0\n\n    _json: Dict[str, Any] | None = None\n\n    def __post_init__(self):\n\"\"\"\n        Post init hook to convert to JSON after instantiation.\n        \"\"\"\n        self._json = to_json(self)\n\n    def fill_info(\n        self,\n        t8n: TransitionTool,\n        b11r: BlockBuilder,\n        ref_spec: ReferenceSpec | None,\n    ):\n\"\"\"\n        Fill the info field for this fixture\n        \"\"\"\n        self.info[\"filling-transition-tool\"] = t8n.version()\n        self.info[\"filling-block-build-tool\"] = b11r.version()\n        if ref_spec is not None:\n            ref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init hook to convert to JSON after instantiation.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self):\n\"\"\"\n    Post init hook to convert to JSON after instantiation.\n    \"\"\"\n    self._json = to_json(self)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.fill_info","title":"<code>fill_info(t8n, b11r, ref_spec)</code>","text":"<p>Fill the info field for this fixture</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def fill_info(\n    self,\n    t8n: TransitionTool,\n    b11r: BlockBuilder,\n    ref_spec: ReferenceSpec | None,\n):\n\"\"\"\n    Fill the info field for this fixture\n    \"\"\"\n    self.info[\"filling-transition-tool\"] = t8n.version()\n    self.info[\"filling-block-build-tool\"] = b11r.version()\n    if ref_spec is not None:\n        ref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header","title":"<code>Header</code>  <code>dataclass</code>","text":"<p>Header type used to describe block header properties in test specs.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Header:\n\"\"\"\n    Header type used to describe block header properties in test specs.\n    \"\"\"\n\n    parent_hash: Optional[str] = None\n    ommers_hash: Optional[str] = None\n    coinbase: Optional[str] = None\n    state_root: Optional[str] = None\n    transactions_root: Optional[str] = None\n    receipt_root: Optional[str] = None\n    bloom: Optional[str] = None\n    difficulty: Optional[int] = None\n    number: Optional[int] = None\n    gas_limit: Optional[int] = None\n    gas_used: Optional[int] = None\n    timestamp: Optional[int] = None\n    extra_data: Optional[str] = None\n    mix_digest: Optional[str] = None\n    nonce: Optional[str] = None\n    base_fee: Optional[int | REMOVABLE] = None\n    withdrawals_root: Optional[str | REMOVABLE] = None\n    excess_data_gas: Optional[int | REMOVABLE] = None\n    hash: Optional[str] = None\n\n    REMOVE_FIELD: ClassVar[REMOVABLE] = REMOVABLE()\n\"\"\"\n    Sentinel object used to specify that a header field should be removed.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Header.REMOVE_FIELD","title":"<code>REMOVE_FIELD: REMOVABLE = REMOVABLE()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify that a header field should be removed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode","title":"<code>Initcode</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate initcode for the specified deployment code.</p> <p>The execution gas cost of the initcode is calculated, and also the deployment gas costs for the deployed code.</p> <p>The initcode can be padded to a certain length if necessary, which does not affect the deployed code.</p> <p>Other costs such as the CREATE2 hashing costs or the initcode_word_cost of EIP-3860 are not taken into account by any of these calculated costs.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Initcode(Code):\n\"\"\"\n    Helper class used to generate initcode for the specified deployment code.\n\n    The execution gas cost of the initcode is calculated, and also the\n    deployment gas costs for the deployed code.\n\n    The initcode can be padded to a certain length if necessary, which\n    does not affect the deployed code.\n\n    Other costs such as the CREATE2 hashing costs or the initcode_word_cost\n    of EIP-3860 are *not* taken into account by any of these calculated\n    costs.\n    \"\"\"\n\n    deploy_code: bytes | str | Code\n\"\"\"\n    Bytecode to be deployed by the initcode.\n    \"\"\"\n    execution_gas: int\n\"\"\"\n    Gas cost of executing the initcode, without considering deployment gas\n    costs.\n    \"\"\"\n    deployment_gas: int\n\"\"\"\n    Gas cost of deploying the cost, subtracted after initcode execution,\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        deploy_code: str | bytes | Code,\n        initcode_length: Optional[int] = None,\n        padding_byte: int = 0x00,\n        name: Optional[str] = None,\n    ):\n\"\"\"\n        Generate legacy initcode that inits a contract with the specified code.\n        The initcode can be padded to a specified length for testing purposes.\n        \"\"\"\n        self.execution_gas = 0\n        self.deploy_code = deploy_code\n        deploy_code_bytes = code_to_bytes(self.deploy_code)\n        code_length = len(deploy_code_bytes)\n\n        initcode = bytearray()\n\n        # PUSH2: length=&lt;bytecode length&gt;\n        initcode.append(0x61)\n        initcode += code_length.to_bytes(length=2, byteorder=\"big\")\n        self.execution_gas += 3\n\n        # PUSH1: offset=0\n        initcode.append(0x60)\n        initcode.append(0x00)\n        self.execution_gas += 3\n\n        # DUP2\n        initcode.append(0x81)\n        self.execution_gas += 3\n\n        # PUSH1: initcode_length=11 (constant)\n        initcode.append(0x60)\n        initcode.append(0x0B)\n        self.execution_gas += 3\n\n        # DUP3\n        initcode.append(0x82)\n        self.execution_gas += 3\n\n        # CODECOPY: destinationOffset=0, offset=0, length\n        initcode.append(0x39)\n        self.execution_gas += (\n            3\n            + (3 * ceiling_division(code_length, 32))\n            + (3 * code_length)\n            + ((code_length * code_length) // 512)\n        )\n\n        # RETURN: offset=0, length\n        initcode.append(0xF3)\n        self.execution_gas += 0\n\n        pre_padding_bytes = bytes(initcode) + deploy_code_bytes\n\n        if initcode_length is not None:\n            if len(pre_padding_bytes) &gt; initcode_length:\n                raise Exception(\"Invalid specified length for initcode\")\n\n            padding_bytes = bytes(\n                [padding_byte] * (initcode_length - len(pre_padding_bytes))\n            )\n        else:\n            padding_bytes = bytes()\n\n        self.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\n            deploy_code_bytes\n        )\n\n        super().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deploy_code","title":"<code>deploy_code: bytes | str | Code = deploy_code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be deployed by the initcode.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deployment_gas","title":"<code>deployment_gas: int = GAS_PER_DEPLOYED_CODE_BYTE * len(deploy_code_bytes)</code>  <code>instance-attribute</code>","text":"<p>Gas cost of deploying the cost, subtracted after initcode execution,</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.execution_gas","title":"<code>execution_gas: int = 0</code>  <code>instance-attribute</code>","text":"<p>Gas cost of executing the initcode, without considering deployment gas costs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.__init__","title":"<code>__init__(*, deploy_code, initcode_length=None, padding_byte=0, name=None)</code>","text":"<p>Generate legacy initcode that inits a contract with the specified code. The initcode can be padded to a specified length for testing purposes.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __init__(\n    self,\n    *,\n    deploy_code: str | bytes | Code,\n    initcode_length: Optional[int] = None,\n    padding_byte: int = 0x00,\n    name: Optional[str] = None,\n):\n\"\"\"\n    Generate legacy initcode that inits a contract with the specified code.\n    The initcode can be padded to a specified length for testing purposes.\n    \"\"\"\n    self.execution_gas = 0\n    self.deploy_code = deploy_code\n    deploy_code_bytes = code_to_bytes(self.deploy_code)\n    code_length = len(deploy_code_bytes)\n\n    initcode = bytearray()\n\n    # PUSH2: length=&lt;bytecode length&gt;\n    initcode.append(0x61)\n    initcode += code_length.to_bytes(length=2, byteorder=\"big\")\n    self.execution_gas += 3\n\n    # PUSH1: offset=0\n    initcode.append(0x60)\n    initcode.append(0x00)\n    self.execution_gas += 3\n\n    # DUP2\n    initcode.append(0x81)\n    self.execution_gas += 3\n\n    # PUSH1: initcode_length=11 (constant)\n    initcode.append(0x60)\n    initcode.append(0x0B)\n    self.execution_gas += 3\n\n    # DUP3\n    initcode.append(0x82)\n    self.execution_gas += 3\n\n    # CODECOPY: destinationOffset=0, offset=0, length\n    initcode.append(0x39)\n    self.execution_gas += (\n        3\n        + (3 * ceiling_division(code_length, 32))\n        + (3 * code_length)\n        + ((code_length * code_length) // 512)\n    )\n\n    # RETURN: offset=0, length\n    initcode.append(0xF3)\n    self.execution_gas += 0\n\n    pre_padding_bytes = bytes(initcode) + deploy_code_bytes\n\n    if initcode_length is not None:\n        if len(pre_padding_bytes) &gt; initcode_length:\n            raise Exception(\"Invalid specified length for initcode\")\n\n        padding_bytes = bytes(\n            [padding_byte] * (initcode_length - len(pre_padding_bytes))\n        )\n    else:\n        padding_bytes = bytes()\n\n    self.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\n        deploy_code_bytes\n    )\n\n    super().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.JSONEncoder","title":"<code>JSONEncoder</code>","text":"<p>         Bases: <code>json.JSONEncoder</code></p> <p>Custom JSON encoder for <code>ethereum_test</code> types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class JSONEncoder(json.JSONEncoder):\n\"\"\"\n    Custom JSON encoder for `ethereum_test` types.\n    \"\"\"\n\n    def default(self, obj):\n\"\"\"\n        Enocdes types defined in this module using basic python facilities.\n        \"\"\"\n        if isinstance(obj, Storage):\n            return obj.to_dict()\n        elif isinstance(obj, Account):\n            account = {\n                \"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n                \"balance\": hex_or_none(\n                    obj.balance, hex(ACCOUNT_DEFAULTS.balance)\n                ),\n                \"code\": code_or_none(obj.code, \"0x\"),\n                \"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n            }\n            return even_padding(account, excluded=[\"storage\"])\n        elif isinstance(obj, AccessList):\n            access_list = {\"address\": obj.address}\n            if obj.storage_keys is not None:\n                access_list[\"storageKeys\"] = obj.storage_keys\n            return access_list\n        elif isinstance(obj, Transaction):\n            tx = {\n                \"type\": hex(obj.ty),\n                \"chainId\": hex(obj.chain_id),\n                \"nonce\": hex(obj.nonce),\n                \"gasPrice\": hex_or_none(obj.gas_price),\n                \"maxPriorityFeePerGas\": hex_or_none(\n                    obj.max_priority_fee_per_gas\n                ),\n                \"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n                \"gas\": hex(obj.gas_limit),\n                \"value\": hex(obj.value),\n                \"input\": code_to_hex(obj.data),\n                \"to\": obj.to,\n                \"accessList\": obj.access_list,\n                \"protected\": obj.protected,\n                \"secretKey\": obj.secret_key,\n                \"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n            }\n\n            if obj.blob_versioned_hashes is not None:\n                hashes: List[str] = []\n                for h in obj.blob_versioned_hashes:\n                    if type(h) is str:\n                        hashes.append(h)\n                    elif type(h) is bytes:\n                        if len(h) != 32:\n                            raise TypeError(\n                                \"improper byte size for blob_versioned_hashes\"\n                            )\n                        hashes.append(\"0x\" + h.hex())\n                    else:\n                        raise TypeError(\n                            \"improper type for blob_versioned_hashes\"\n                        )\n                tx[\"blobVersionedHashes\"] = hashes\n\n            if obj.secret_key is None:\n                assert obj.signature is not None\n                assert len(obj.signature) == 3\n                tx[\"v\"] = obj.signature[0]\n                tx[\"r\"] = obj.signature[1]\n                tx[\"s\"] = obj.signature[2]\n            else:\n                tx[\"v\"] = \"\"\n                tx[\"r\"] = \"\"\n                tx[\"s\"] = \"\"\n            return {k: v for (k, v) in tx.items() if v is not None}\n        elif isinstance(obj, Withdrawal):\n            withdrawal = {\n                \"index\": hex(obj.index),\n                \"validatorIndex\": hex(obj.validator),\n                \"address\": obj.address,\n                \"amount\": hex(obj.amount),\n            }\n            return withdrawal\n        elif isinstance(obj, Environment):\n            env = {\n                \"currentCoinbase\": obj.coinbase,\n                \"currentGasLimit\": str_or_none(obj.gas_limit),\n                \"currentNumber\": str_or_none(obj.number),\n                \"currentTimestamp\": str_or_none(obj.timestamp),\n                \"currentRandom\": str_or_none(obj.prev_randao),\n                \"currentDifficulty\": str_or_none(obj.difficulty),\n                \"parentDifficulty\": str_or_none(obj.parent_difficulty),\n                \"parentBaseFee\": str_or_none(obj.parent_base_fee),\n                \"parentGasUsed\": str_or_none(obj.parent_gas_used),\n                \"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n                \"parentTimstamp\": str_or_none(obj.parent_timestamp),\n                \"blockHashes\": {\n                    str(k): v for (k, v) in obj.block_hashes.items()\n                },\n                \"ommers\": [],\n                \"withdrawals\": to_json_or_none(obj.withdrawals),\n                \"parentUncleHash\": obj.parent_ommers_hash,\n                \"currentBaseFee\": str_or_none(obj.base_fee),\n                \"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n                \"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n            }\n\n            return {k: v for (k, v) in env.items() if v is not None}\n        elif isinstance(obj, FixtureHeader):\n            header = {\n                \"parentHash\": obj.parent_hash,\n                \"uncleHash\": obj.ommers_hash,\n                \"coinbase\": obj.coinbase,\n                \"stateRoot\": obj.state_root,\n                \"transactionsTrie\": obj.transactions_root,\n                \"receiptTrie\": obj.receipt_root,\n                \"bloom\": obj.bloom,\n                \"difficulty\": hex(obj.difficulty),\n                \"number\": hex(obj.number),\n                \"gasLimit\": hex(obj.gas_limit),\n                \"gasUsed\": hex(obj.gas_used),\n                \"timestamp\": hex(obj.timestamp),\n                \"extraData\": obj.extra_data\n                if len(obj.extra_data) != 0\n                else \"0x\",  # noqa: E501\n                \"mixHash\": obj.mix_digest,\n                \"nonce\": obj.nonce,\n            }\n            if obj.base_fee is not None:\n                header[\"baseFeePerGas\"] = hex(obj.base_fee)\n            if obj.hash is not None:\n                header[\"hash\"] = obj.hash\n            if obj.withdrawals_root is not None:\n                header[\"withdrawalsRoot\"] = obj.withdrawals_root\n            if obj.excess_data_gas is not None:\n                header[\"excessDataGas\"] = hex(obj.excess_data_gas)\n            return even_padding(\n                header,\n                excluded=[\n                    \"parentHash\",\n                    \"uncleHash\",\n                    \"stateRoot\",\n                    \"coinbase\",\n                    \"transactionsTrie\",\n                    \"receiptTrie\",\n                    \"bloom\",\n                    \"nonce\",\n                    \"mixHash\",\n                    \"hash\",\n                    \"withdrawalsRoot\",\n                    \"extraData\",\n                ],\n            )\n        elif isinstance(obj, FixtureTransaction):\n            json_tx = to_json(obj.tx)\n            if json_tx[\"v\"] == \"\":\n                del json_tx[\"v\"]\n                del json_tx[\"r\"]\n                del json_tx[\"s\"]\n            if \"input\" in json_tx:\n                json_tx[\"data\"] = json_tx[\"input\"]\n                del json_tx[\"input\"]\n            if \"gas\" in json_tx:\n                json_tx[\"gasLimit\"] = json_tx[\"gas\"]\n                del json_tx[\"gas\"]\n            if \"protected\" in json_tx:\n                del json_tx[\"protected\"]\n            if \"to\" not in json_tx:\n                json_tx[\"to\"] = \"\"\n            return even_padding(\n                json_tx,\n                excluded=[\"to\", \"accessList\"],\n            )\n        elif isinstance(obj, FixtureBlock):\n            b = {\"rlp\": obj.rlp}\n            if obj.block_header is not None:\n                b[\"blockHeader\"] = json.loads(\n                    json.dumps(obj.block_header, cls=JSONEncoder)\n                )\n            if obj.expected_exception is not None:\n                b[\"expectException\"] = obj.expected_exception\n            if obj.block_number is not None:\n                b[\"blocknumber\"] = str(obj.block_number)\n            if obj.txs is not None:\n                b[\"transactions\"] = [\n                    FixtureTransaction(tx=tx) for tx in obj.txs\n                ]\n            if obj.ommers is not None:\n                b[\"uncleHeaders\"] = obj.ommers\n            if obj.withdrawals is not None:\n                b[\"withdrawals\"] = [\n                    even_padding(to_json(wd), excluded=[\"address\"])\n                    for wd in obj.withdrawals\n                ]\n            return b\n        elif isinstance(obj, Fixture):\n            if obj._json is not None:\n                obj._json[\"_info\"] = obj.info\n                return obj._json\n\n            f = {\n                \"_info\": obj.info,\n                \"blocks\": [\n                    json.loads(json.dumps(b, cls=JSONEncoder))\n                    for b in obj.blocks\n                ],\n                \"genesisBlockHeader\": self.default(obj.genesis),\n                \"genesisRLP\": obj.genesis_rlp,\n                \"lastblockhash\": obj.head,\n                \"network\": obj.fork,\n                \"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n                \"postState\": json.loads(\n                    json.dumps(obj.post_state, cls=JSONEncoder)\n                ),\n                \"sealEngine\": obj.seal_engine,\n            }\n            if f[\"postState\"] is None:\n                del f[\"postState\"]\n            return f\n        else:\n            return super().default(obj)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.JSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Enocdes types defined in this module using basic python facilities.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def default(self, obj):\n\"\"\"\n    Enocdes types defined in this module using basic python facilities.\n    \"\"\"\n    if isinstance(obj, Storage):\n        return obj.to_dict()\n    elif isinstance(obj, Account):\n        account = {\n            \"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n            \"balance\": hex_or_none(\n                obj.balance, hex(ACCOUNT_DEFAULTS.balance)\n            ),\n            \"code\": code_or_none(obj.code, \"0x\"),\n            \"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n        }\n        return even_padding(account, excluded=[\"storage\"])\n    elif isinstance(obj, AccessList):\n        access_list = {\"address\": obj.address}\n        if obj.storage_keys is not None:\n            access_list[\"storageKeys\"] = obj.storage_keys\n        return access_list\n    elif isinstance(obj, Transaction):\n        tx = {\n            \"type\": hex(obj.ty),\n            \"chainId\": hex(obj.chain_id),\n            \"nonce\": hex(obj.nonce),\n            \"gasPrice\": hex_or_none(obj.gas_price),\n            \"maxPriorityFeePerGas\": hex_or_none(\n                obj.max_priority_fee_per_gas\n            ),\n            \"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n            \"gas\": hex(obj.gas_limit),\n            \"value\": hex(obj.value),\n            \"input\": code_to_hex(obj.data),\n            \"to\": obj.to,\n            \"accessList\": obj.access_list,\n            \"protected\": obj.protected,\n            \"secretKey\": obj.secret_key,\n            \"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n        }\n\n        if obj.blob_versioned_hashes is not None:\n            hashes: List[str] = []\n            for h in obj.blob_versioned_hashes:\n                if type(h) is str:\n                    hashes.append(h)\n                elif type(h) is bytes:\n                    if len(h) != 32:\n                        raise TypeError(\n                            \"improper byte size for blob_versioned_hashes\"\n                        )\n                    hashes.append(\"0x\" + h.hex())\n                else:\n                    raise TypeError(\n                        \"improper type for blob_versioned_hashes\"\n                    )\n            tx[\"blobVersionedHashes\"] = hashes\n\n        if obj.secret_key is None:\n            assert obj.signature is not None\n            assert len(obj.signature) == 3\n            tx[\"v\"] = obj.signature[0]\n            tx[\"r\"] = obj.signature[1]\n            tx[\"s\"] = obj.signature[2]\n        else:\n            tx[\"v\"] = \"\"\n            tx[\"r\"] = \"\"\n            tx[\"s\"] = \"\"\n        return {k: v for (k, v) in tx.items() if v is not None}\n    elif isinstance(obj, Withdrawal):\n        withdrawal = {\n            \"index\": hex(obj.index),\n            \"validatorIndex\": hex(obj.validator),\n            \"address\": obj.address,\n            \"amount\": hex(obj.amount),\n        }\n        return withdrawal\n    elif isinstance(obj, Environment):\n        env = {\n            \"currentCoinbase\": obj.coinbase,\n            \"currentGasLimit\": str_or_none(obj.gas_limit),\n            \"currentNumber\": str_or_none(obj.number),\n            \"currentTimestamp\": str_or_none(obj.timestamp),\n            \"currentRandom\": str_or_none(obj.prev_randao),\n            \"currentDifficulty\": str_or_none(obj.difficulty),\n            \"parentDifficulty\": str_or_none(obj.parent_difficulty),\n            \"parentBaseFee\": str_or_none(obj.parent_base_fee),\n            \"parentGasUsed\": str_or_none(obj.parent_gas_used),\n            \"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n            \"parentTimstamp\": str_or_none(obj.parent_timestamp),\n            \"blockHashes\": {\n                str(k): v for (k, v) in obj.block_hashes.items()\n            },\n            \"ommers\": [],\n            \"withdrawals\": to_json_or_none(obj.withdrawals),\n            \"parentUncleHash\": obj.parent_ommers_hash,\n            \"currentBaseFee\": str_or_none(obj.base_fee),\n            \"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n            \"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n        }\n\n        return {k: v for (k, v) in env.items() if v is not None}\n    elif isinstance(obj, FixtureHeader):\n        header = {\n            \"parentHash\": obj.parent_hash,\n            \"uncleHash\": obj.ommers_hash,\n            \"coinbase\": obj.coinbase,\n            \"stateRoot\": obj.state_root,\n            \"transactionsTrie\": obj.transactions_root,\n            \"receiptTrie\": obj.receipt_root,\n            \"bloom\": obj.bloom,\n            \"difficulty\": hex(obj.difficulty),\n            \"number\": hex(obj.number),\n            \"gasLimit\": hex(obj.gas_limit),\n            \"gasUsed\": hex(obj.gas_used),\n            \"timestamp\": hex(obj.timestamp),\n            \"extraData\": obj.extra_data\n            if len(obj.extra_data) != 0\n            else \"0x\",  # noqa: E501\n            \"mixHash\": obj.mix_digest,\n            \"nonce\": obj.nonce,\n        }\n        if obj.base_fee is not None:\n            header[\"baseFeePerGas\"] = hex(obj.base_fee)\n        if obj.hash is not None:\n            header[\"hash\"] = obj.hash\n        if obj.withdrawals_root is not None:\n            header[\"withdrawalsRoot\"] = obj.withdrawals_root\n        if obj.excess_data_gas is not None:\n            header[\"excessDataGas\"] = hex(obj.excess_data_gas)\n        return even_padding(\n            header,\n            excluded=[\n                \"parentHash\",\n                \"uncleHash\",\n                \"stateRoot\",\n                \"coinbase\",\n                \"transactionsTrie\",\n                \"receiptTrie\",\n                \"bloom\",\n                \"nonce\",\n                \"mixHash\",\n                \"hash\",\n                \"withdrawalsRoot\",\n                \"extraData\",\n            ],\n        )\n    elif isinstance(obj, FixtureTransaction):\n        json_tx = to_json(obj.tx)\n        if json_tx[\"v\"] == \"\":\n            del json_tx[\"v\"]\n            del json_tx[\"r\"]\n            del json_tx[\"s\"]\n        if \"input\" in json_tx:\n            json_tx[\"data\"] = json_tx[\"input\"]\n            del json_tx[\"input\"]\n        if \"gas\" in json_tx:\n            json_tx[\"gasLimit\"] = json_tx[\"gas\"]\n            del json_tx[\"gas\"]\n        if \"protected\" in json_tx:\n            del json_tx[\"protected\"]\n        if \"to\" not in json_tx:\n            json_tx[\"to\"] = \"\"\n        return even_padding(\n            json_tx,\n            excluded=[\"to\", \"accessList\"],\n        )\n    elif isinstance(obj, FixtureBlock):\n        b = {\"rlp\": obj.rlp}\n        if obj.block_header is not None:\n            b[\"blockHeader\"] = json.loads(\n                json.dumps(obj.block_header, cls=JSONEncoder)\n            )\n        if obj.expected_exception is not None:\n            b[\"expectException\"] = obj.expected_exception\n        if obj.block_number is not None:\n            b[\"blocknumber\"] = str(obj.block_number)\n        if obj.txs is not None:\n            b[\"transactions\"] = [\n                FixtureTransaction(tx=tx) for tx in obj.txs\n            ]\n        if obj.ommers is not None:\n            b[\"uncleHeaders\"] = obj.ommers\n        if obj.withdrawals is not None:\n            b[\"withdrawals\"] = [\n                even_padding(to_json(wd), excluded=[\"address\"])\n                for wd in obj.withdrawals\n            ]\n        return b\n    elif isinstance(obj, Fixture):\n        if obj._json is not None:\n            obj._json[\"_info\"] = obj.info\n            return obj._json\n\n        f = {\n            \"_info\": obj.info,\n            \"blocks\": [\n                json.loads(json.dumps(b, cls=JSONEncoder))\n                for b in obj.blocks\n            ],\n            \"genesisBlockHeader\": self.default(obj.genesis),\n            \"genesisRLP\": obj.genesis_rlp,\n            \"lastblockhash\": obj.head,\n            \"network\": obj.fork,\n            \"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n            \"postState\": json.loads(\n                json.dumps(obj.post_state, cls=JSONEncoder)\n            ),\n            \"sealEngine\": obj.seal_engine,\n        }\n        if f[\"postState\"] is None:\n            del f[\"postState\"]\n        return f\n    else:\n        return super().default(obj)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode","title":"<code>Opcode</code>","text":"<p>         Bases: <code>bytes</code></p> <p>Represents a single Opcode instruction in the EVM, with extra metadata useful to parametrize tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode--parameters","title":"Parameters","text":"<ul> <li>popped_stack_items: number of items the opcode pops from the stack</li> <li>pushed_stack_items: number of items the opcode pushes to the stack</li> <li>min_stack_height: minimum stack height required by the opcode</li> <li>data_portion_length: number of bytes after the opcode in the bytecode     that represent data</li> </ul> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcode(bytes):\n\"\"\"\n    Represents a single Opcode instruction in the EVM, with extra\n    metadata useful to parametrize tests.\n\n    Parameters\n    ----------\n    - popped_stack_items: number of items the opcode pops from the stack\n    - pushed_stack_items: number of items the opcode pushes to the stack\n    - min_stack_height: minimum stack height required by the opcode\n    - data_portion_length: number of bytes after the opcode in the bytecode\n        that represent data\n    \"\"\"\n\n    popped_stack_items: int\n    pushed_stack_items: int\n    min_stack_height: int\n    data_portion_length: int\n\n    def __new__(\n        cls,\n        opcode_or_byte: Union[int, \"Opcode\"],\n        *,\n        popped_stack_items: int = 0,\n        pushed_stack_items: int = 0,\n        min_stack_height: int = 0,\n        data_portion_length: int = 0\n    ):\n\"\"\"\n        Creates a new opcode instance.\n        \"\"\"\n        if type(opcode_or_byte) is Opcode:\n            # Required because Enum class calls the base class with the\n            # instantiated object as parameter.\n            return opcode_or_byte\n        elif isinstance(opcode_or_byte, int):\n            obj = super().__new__(cls, [opcode_or_byte])\n            obj.popped_stack_items = popped_stack_items\n            obj.pushed_stack_items = pushed_stack_items\n            obj.min_stack_height = min_stack_height\n            obj.data_portion_length = data_portion_length\n            return obj\n\n    def __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n        Makes all opcode instances callable to return formatted bytecode,\n        which constitutes a data portion, that is located after the opcode\n        byte, and pre-opcode bytecode, which is normally used to set up the\n        stack.\n\n        This useful to automatically format, e.g., push opcodes and their\n        data sections as `Opcodes.PUSH1(0x00)`.\n\n        Data sign is automatically detected but for this reason the range\n        of the input must be:\n        `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n        where:\n        `data_portion_bits == data_portion_length * 8`\n\n        For the stack, the arguments are set up in the opposite order they are\n        given, so the first argument is the last item pushed to the stack.\n\n        The resulting stack arrangement does not take into account opcode stack\n        element consumption, so the stack height is not guaranteed to be\n        correct and the user must take this into consideration.\n\n        Integers can also be used as stack elements, in which case they are\n        automatically converted to PUSH operations, and negative numbers always\n        use a PUSH32 operation.\n\n\n        \"\"\"\n        args: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\n        pre_opcode_bytecode = bytes()\n        data_portion = bytes()\n\n        if self.data_portion_length &gt; 0:\n            # For opcodes with a data portion, the first argument is the data\n            # and the rest of the arguments form the stack.\n            if len(args) == 0:\n                raise ValueError(\n                    \"Opcode with data portion requires at least one argument\"\n                )\n            data = args.pop(0)\n            if isinstance(data, bytes):\n                data_portion = data\n            elif isinstance(data, int):\n                signed = data &lt; 0\n                data_portion = data.to_bytes(\n                    length=self.data_portion_length,\n                    byteorder=\"big\",\n                    signed=signed,\n                )\n            else:\n                raise TypeError(\n                    \"Opcode data portion must be either an int or a bytes\"\n                )\n\n        # The rest of the arguments conform the stack.\n        while len(args) &gt; 0:\n            data = args.pop()\n            if isinstance(data, bytes):\n                pre_opcode_bytecode += data\n            elif isinstance(data, int):\n                # We are going to push a constant to the stack.\n                signed = data &lt; 0\n                data_size = _get_int_size(data)\n                if data_size &gt; 32:\n                    raise ValueError(\n                        \"Opcode stack data must be less than 32 bytes\"\n                    )\n                elif data_size == 0:\n                    # Pushing 0 is done with the PUSH1 opcode for compatibility\n                    # reasons.\n                    data_size = 1\n\n                pre_opcode_bytecode += _push_opcodes_byte_list[data_size]\n                pre_opcode_bytecode += data.to_bytes(\n                    length=data_size,\n                    byteorder=\"big\",\n                    signed=signed,\n                )\n\n            else:\n                raise TypeError(\n                    \"Opcode stack data must be either an int or a bytes\"\n                )\n\n        return pre_opcode_bytecode + self + data_portion\n\n    def __len__(self) -&gt; int:\n\"\"\"\n        Returns the total bytecode length of the opcode, taking into account\n        its data portion.\n        \"\"\"\n        return self.data_portion_length + 1\n\n    def int(self) -&gt; int:\n\"\"\"\n        Returns the integer representation of the opcode.\n        \"\"\"\n        return int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__call__","title":"<code>__call__(*args_t)</code>","text":"<p>Makes all opcode instances callable to return formatted bytecode, which constitutes a data portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally used to set up the stack.</p> <p>This useful to automatically format, e.g., push opcodes and their data sections as <code>Opcodes.PUSH1(0x00)</code>.</p> <p>Data sign is automatically detected but for this reason the range of the input must be: <code>[-2^(data_portion_bits-1), 2^(data_portion_bits)]</code> where: <code>data_portion_bits == data_portion_length * 8</code></p> <p>For the stack, the arguments are set up in the opposite order they are given, so the first argument is the last item pushed to the stack.</p> <p>The resulting stack arrangement does not take into account opcode stack element consumption, so the stack height is not guaranteed to be correct and the user must take this into consideration.</p> <p>Integers can also be used as stack elements, in which case they are automatically converted to PUSH operations, and negative numbers always use a PUSH32 operation.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n    Makes all opcode instances callable to return formatted bytecode,\n    which constitutes a data portion, that is located after the opcode\n    byte, and pre-opcode bytecode, which is normally used to set up the\n    stack.\n\n    This useful to automatically format, e.g., push opcodes and their\n    data sections as `Opcodes.PUSH1(0x00)`.\n\n    Data sign is automatically detected but for this reason the range\n    of the input must be:\n    `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n    where:\n    `data_portion_bits == data_portion_length * 8`\n\n    For the stack, the arguments are set up in the opposite order they are\n    given, so the first argument is the last item pushed to the stack.\n\n    The resulting stack arrangement does not take into account opcode stack\n    element consumption, so the stack height is not guaranteed to be\n    correct and the user must take this into consideration.\n\n    Integers can also be used as stack elements, in which case they are\n    automatically converted to PUSH operations, and negative numbers always\n    use a PUSH32 operation.\n\n\n    \"\"\"\n    args: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\n    pre_opcode_bytecode = bytes()\n    data_portion = bytes()\n\n    if self.data_portion_length &gt; 0:\n        # For opcodes with a data portion, the first argument is the data\n        # and the rest of the arguments form the stack.\n        if len(args) == 0:\n            raise ValueError(\n                \"Opcode with data portion requires at least one argument\"\n            )\n        data = args.pop(0)\n        if isinstance(data, bytes):\n            data_portion = data\n        elif isinstance(data, int):\n            signed = data &lt; 0\n            data_portion = data.to_bytes(\n                length=self.data_portion_length,\n                byteorder=\"big\",\n                signed=signed,\n            )\n        else:\n            raise TypeError(\n                \"Opcode data portion must be either an int or a bytes\"\n            )\n\n    # The rest of the arguments conform the stack.\n    while len(args) &gt; 0:\n        data = args.pop()\n        if isinstance(data, bytes):\n            pre_opcode_bytecode += data\n        elif isinstance(data, int):\n            # We are going to push a constant to the stack.\n            signed = data &lt; 0\n            data_size = _get_int_size(data)\n            if data_size &gt; 32:\n                raise ValueError(\n                    \"Opcode stack data must be less than 32 bytes\"\n                )\n            elif data_size == 0:\n                # Pushing 0 is done with the PUSH1 opcode for compatibility\n                # reasons.\n                data_size = 1\n\n            pre_opcode_bytecode += _push_opcodes_byte_list[data_size]\n            pre_opcode_bytecode += data.to_bytes(\n                length=data_size,\n                byteorder=\"big\",\n                signed=signed,\n            )\n\n        else:\n            raise TypeError(\n                \"Opcode stack data must be either an int or a bytes\"\n            )\n\n    return pre_opcode_bytecode + self + data_portion\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total bytecode length of the opcode, taking into account its data portion.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Returns the total bytecode length of the opcode, taking into account\n    its data portion.\n    \"\"\"\n    return self.data_portion_length + 1\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__new__","title":"<code>__new__(opcode_or_byte, *, popped_stack_items=0, pushed_stack_items=0, min_stack_height=0, data_portion_length=0)</code>","text":"<p>Creates a new opcode instance.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __new__(\n    cls,\n    opcode_or_byte: Union[int, \"Opcode\"],\n    *,\n    popped_stack_items: int = 0,\n    pushed_stack_items: int = 0,\n    min_stack_height: int = 0,\n    data_portion_length: int = 0\n):\n\"\"\"\n    Creates a new opcode instance.\n    \"\"\"\n    if type(opcode_or_byte) is Opcode:\n        # Required because Enum class calls the base class with the\n        # instantiated object as parameter.\n        return opcode_or_byte\n    elif isinstance(opcode_or_byte, int):\n        obj = super().__new__(cls, [opcode_or_byte])\n        obj.popped_stack_items = popped_stack_items\n        obj.pushed_stack_items = pushed_stack_items\n        obj.min_stack_height = min_stack_height\n        obj.data_portion_length = data_portion_length\n        return obj\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.int","title":"<code>int()</code>","text":"<p>Returns the integer representation of the opcode.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def int(self) -&gt; int:\n\"\"\"\n    Returns the integer representation of the opcode.\n    \"\"\"\n    return int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcodes","title":"<code>Opcodes</code>","text":"<p>         Bases: <code>Opcode</code>, <code>Enum</code></p> <p>Enum containing all known opcodes.</p> <p>Contains deprecated and not yet implemented opcodes.</p> <p>This enum is !! NOT !! meant to be iterated over by the tests. Instead, create a list with cherry-picked opcodes from this Enum within the test if iteration is needed.</p> <p>Do !! NOT !! remove or modify existing opcodes from this list.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcodes(Opcode, Enum):\n\"\"\"\n    Enum containing all known opcodes.\n\n    Contains deprecated and not yet implemented opcodes.\n\n    This enum is !! NOT !! meant to be iterated over by the tests. Instead,\n    create a list with cherry-picked opcodes from this Enum within the test\n    if iteration is needed.\n\n    Do !! NOT !! remove or modify existing opcodes from this list.\n    \"\"\"\n\n    STOP = Opcode(0x00)\n    ADD = Opcode(0x01, popped_stack_items=2, pushed_stack_items=1)\n    MUL = Opcode(0x02, popped_stack_items=2, pushed_stack_items=1)\n    SUB = Opcode(0x03, popped_stack_items=2, pushed_stack_items=1)\n    DIV = Opcode(0x04, popped_stack_items=2, pushed_stack_items=1)\n    SDIV = Opcode(0x05, popped_stack_items=2, pushed_stack_items=1)\n    MOD = Opcode(0x06, popped_stack_items=2, pushed_stack_items=1)\n    SMOD = Opcode(0x07, popped_stack_items=2, pushed_stack_items=1)\n    ADDMOD = Opcode(0x08, popped_stack_items=3, pushed_stack_items=1)\n    MULMOD = Opcode(0x09, popped_stack_items=3, pushed_stack_items=1)\n    EXP = Opcode(0x0A, popped_stack_items=2, pushed_stack_items=1)\n    SIGNEXTEND = Opcode(0x0B, popped_stack_items=2, pushed_stack_items=1)\n\n    LT = Opcode(0x10, popped_stack_items=2, pushed_stack_items=1)\n    GT = Opcode(0x11, popped_stack_items=2, pushed_stack_items=1)\n    SLT = Opcode(0x12, popped_stack_items=2, pushed_stack_items=1)\n    SGT = Opcode(0x13, popped_stack_items=2, pushed_stack_items=1)\n    EQ = Opcode(0x14, popped_stack_items=2, pushed_stack_items=1)\n    ISZERO = Opcode(0x15, popped_stack_items=1, pushed_stack_items=1)\n    AND = Opcode(0x16, popped_stack_items=2, pushed_stack_items=1)\n    OR = Opcode(0x17, popped_stack_items=2, pushed_stack_items=1)\n    XOR = Opcode(0x18, popped_stack_items=2, pushed_stack_items=1)\n    NOT = Opcode(0x19, popped_stack_items=1, pushed_stack_items=1)\n    BYTE = Opcode(0x1A, popped_stack_items=2, pushed_stack_items=1)\n    SHL = Opcode(0x1B, popped_stack_items=2, pushed_stack_items=1)\n    SHR = Opcode(0x1C, popped_stack_items=2, pushed_stack_items=1)\n    SAR = Opcode(0x1D, popped_stack_items=2, pushed_stack_items=1)\n\n    SHA3 = Opcode(0x20, popped_stack_items=2, pushed_stack_items=1)\n\n    ADDRESS = Opcode(0x30, pushed_stack_items=1)\n    BALANCE = Opcode(0x31, popped_stack_items=1, pushed_stack_items=1)\n    ORIGIN = Opcode(0x32, pushed_stack_items=1)\n    CALLER = Opcode(0x33, pushed_stack_items=1)\n    CALLVALUE = Opcode(0x34, pushed_stack_items=1)\n    CALLDATALOAD = Opcode(0x35, popped_stack_items=1, pushed_stack_items=1)\n    CALLDATASIZE = Opcode(0x36, pushed_stack_items=1)\n    CALLDATACOPY = Opcode(0x37, popped_stack_items=3)\n    CODESIZE = Opcode(0x38, pushed_stack_items=1)\n    CODECOPY = Opcode(0x39, popped_stack_items=3)\n    GASPRICE = Opcode(0x3A, pushed_stack_items=1)\n    EXTCODESIZE = Opcode(0x3B, popped_stack_items=1, pushed_stack_items=1)\n    EXTCODECOPY = Opcode(0x3C, popped_stack_items=4)\n    RETURNDATASIZE = Opcode(0x3D, pushed_stack_items=1)\n    RETURNDATACOPY = Opcode(0x3E, popped_stack_items=3)\n    EXTCODEHASH = Opcode(0x3F, popped_stack_items=1, pushed_stack_items=1)\n\n    BLOCKHASH = Opcode(0x40, popped_stack_items=1, pushed_stack_items=1)\n    COINBASE = Opcode(0x41, pushed_stack_items=1)\n    TIMESTAMP = Opcode(0x42, pushed_stack_items=1)\n    NUMBER = Opcode(0x43, pushed_stack_items=1)\n    PREVRANDAO = Opcode(0x44, pushed_stack_items=1)\n    GASLIMIT = Opcode(0x45, pushed_stack_items=1)\n    CHAINID = Opcode(0x46, pushed_stack_items=1)\n    SELFBALANCE = Opcode(0x47, pushed_stack_items=1)\n    BASEFEE = Opcode(0x48, pushed_stack_items=1)\n    DATAHASH = Opcode(0x49, popped_stack_items=1, pushed_stack_items=1)\n\n    POP = Opcode(0x50, popped_stack_items=1)\n    MLOAD = Opcode(0x51, popped_stack_items=1, pushed_stack_items=1)\n    MSTORE = Opcode(0x52, popped_stack_items=2)\n    MSTORE8 = Opcode(0x53, popped_stack_items=2)\n    SLOAD = Opcode(0x54, popped_stack_items=1, pushed_stack_items=1)\n    SSTORE = Opcode(0x55, popped_stack_items=2)\n    JUMP = Opcode(0x56, popped_stack_items=1)\n    JUMPI = Opcode(0x57, popped_stack_items=2)\n    PC = Opcode(0x58, pushed_stack_items=1)\n    MSIZE = Opcode(0x59, pushed_stack_items=1)\n    GAS = Opcode(0x5A, pushed_stack_items=1)\n    JUMPDEST = Opcode(0x5B)\n    RJUMP = Opcode(0x5C, data_portion_length=2)\n    RJUMPI = Opcode(0x5D, popped_stack_items=1, data_portion_length=2)\n    CALLF = Opcode(0x5E, data_portion_length=2)\n    RETF = Opcode(0x49)\n\n    PUSH0 = Opcode(0x5F, pushed_stack_items=1)\n    PUSH1 = Opcode(0x60, pushed_stack_items=1, data_portion_length=1)\n    PUSH2 = Opcode(0x61, pushed_stack_items=1, data_portion_length=2)\n    PUSH3 = Opcode(0x62, pushed_stack_items=1, data_portion_length=3)\n    PUSH4 = Opcode(0x63, pushed_stack_items=1, data_portion_length=4)\n    PUSH5 = Opcode(0x64, pushed_stack_items=1, data_portion_length=5)\n    PUSH6 = Opcode(0x65, pushed_stack_items=1, data_portion_length=6)\n    PUSH7 = Opcode(0x66, pushed_stack_items=1, data_portion_length=7)\n    PUSH8 = Opcode(0x67, pushed_stack_items=1, data_portion_length=8)\n    PUSH9 = Opcode(0x68, pushed_stack_items=1, data_portion_length=9)\n    PUSH10 = Opcode(0x69, pushed_stack_items=1, data_portion_length=10)\n    PUSH11 = Opcode(0x6A, pushed_stack_items=1, data_portion_length=11)\n    PUSH12 = Opcode(0x6B, pushed_stack_items=1, data_portion_length=12)\n    PUSH13 = Opcode(0x6C, pushed_stack_items=1, data_portion_length=13)\n    PUSH14 = Opcode(0x6D, pushed_stack_items=1, data_portion_length=14)\n    PUSH15 = Opcode(0x6E, pushed_stack_items=1, data_portion_length=15)\n    PUSH16 = Opcode(0x6F, pushed_stack_items=1, data_portion_length=16)\n    PUSH17 = Opcode(0x70, pushed_stack_items=1, data_portion_length=17)\n    PUSH18 = Opcode(0x71, pushed_stack_items=1, data_portion_length=18)\n    PUSH19 = Opcode(0x72, pushed_stack_items=1, data_portion_length=19)\n    PUSH20 = Opcode(0x73, pushed_stack_items=1, data_portion_length=20)\n    PUSH21 = Opcode(0x74, pushed_stack_items=1, data_portion_length=21)\n    PUSH22 = Opcode(0x75, pushed_stack_items=1, data_portion_length=22)\n    PUSH23 = Opcode(0x76, pushed_stack_items=1, data_portion_length=23)\n    PUSH24 = Opcode(0x77, pushed_stack_items=1, data_portion_length=24)\n    PUSH25 = Opcode(0x78, pushed_stack_items=1, data_portion_length=25)\n    PUSH26 = Opcode(0x79, pushed_stack_items=1, data_portion_length=26)\n    PUSH27 = Opcode(0x7A, pushed_stack_items=1, data_portion_length=27)\n    PUSH28 = Opcode(0x7B, pushed_stack_items=1, data_portion_length=28)\n    PUSH29 = Opcode(0x7C, pushed_stack_items=1, data_portion_length=29)\n    PUSH30 = Opcode(0x7D, pushed_stack_items=1, data_portion_length=30)\n    PUSH31 = Opcode(0x7E, pushed_stack_items=1, data_portion_length=31)\n    PUSH32 = Opcode(0x7F, pushed_stack_items=1, data_portion_length=32)\n\n    DUP1 = Opcode(0x80, pushed_stack_items=1, min_stack_height=1)\n    DUP2 = Opcode(0x81, pushed_stack_items=1, min_stack_height=2)\n    DUP3 = Opcode(0x82, pushed_stack_items=1, min_stack_height=3)\n    DUP4 = Opcode(0x83, pushed_stack_items=1, min_stack_height=4)\n    DUP5 = Opcode(0x84, pushed_stack_items=1, min_stack_height=5)\n    DUP6 = Opcode(0x85, pushed_stack_items=1, min_stack_height=6)\n    DUP7 = Opcode(0x86, pushed_stack_items=1, min_stack_height=7)\n    DUP8 = Opcode(0x87, pushed_stack_items=1, min_stack_height=8)\n    DUP9 = Opcode(0x88, pushed_stack_items=1, min_stack_height=9)\n    DUP10 = Opcode(0x89, pushed_stack_items=1, min_stack_height=10)\n    DUP11 = Opcode(0x8A, pushed_stack_items=1, min_stack_height=11)\n    DUP12 = Opcode(0x8B, pushed_stack_items=1, min_stack_height=12)\n    DUP13 = Opcode(0x8C, pushed_stack_items=1, min_stack_height=13)\n    DUP14 = Opcode(0x8D, pushed_stack_items=1, min_stack_height=14)\n    DUP15 = Opcode(0x8E, pushed_stack_items=1, min_stack_height=15)\n    DUP16 = Opcode(0x8F, pushed_stack_items=1, min_stack_height=16)\n\n    SWAP1 = Opcode(0x90, min_stack_height=2)\n    SWAP2 = Opcode(0x91, min_stack_height=3)\n    SWAP3 = Opcode(0x92, min_stack_height=4)\n    SWAP4 = Opcode(0x93, min_stack_height=5)\n    SWAP5 = Opcode(0x94, min_stack_height=6)\n    SWAP6 = Opcode(0x95, min_stack_height=7)\n    SWAP7 = Opcode(0x96, min_stack_height=8)\n    SWAP8 = Opcode(0x97, min_stack_height=9)\n    SWAP9 = Opcode(0x98, min_stack_height=10)\n    SWAP10 = Opcode(0x99, min_stack_height=11)\n    SWAP11 = Opcode(0x9A, min_stack_height=12)\n    SWAP12 = Opcode(0x9B, min_stack_height=13)\n    SWAP13 = Opcode(0x9C, min_stack_height=14)\n    SWAP14 = Opcode(0x9D, min_stack_height=15)\n    SWAP15 = Opcode(0x9E, min_stack_height=16)\n    SWAP16 = Opcode(0x9F, min_stack_height=17)\n\n    LOG0 = Opcode(0xA0, popped_stack_items=2)\n    LOG1 = Opcode(0xA1, popped_stack_items=3)\n    LOG2 = Opcode(0xA2, popped_stack_items=4)\n    LOG3 = Opcode(0xA3, popped_stack_items=5)\n    LOG4 = Opcode(0xA4, popped_stack_items=6)\n\n    TLOAD = Opcode(0xB3, popped_stack_items=1, pushed_stack_items=1)\n    TSTORE = Opcode(0xB4, popped_stack_items=2)\n\n    CREATE = Opcode(0xF0, popped_stack_items=3, pushed_stack_items=1)\n    CALL = Opcode(0xF1, popped_stack_items=7, pushed_stack_items=1)\n    CALLCODE = Opcode(0xF2, popped_stack_items=7, pushed_stack_items=1)\n    RETURN = Opcode(0xF3, popped_stack_items=2)\n    DELEGATECALL = Opcode(0xF4, popped_stack_items=6, pushed_stack_items=1)\n    CREATE2 = Opcode(0xF5, popped_stack_items=4, pushed_stack_items=1)\n\n    STATICCALL = Opcode(0xFA, popped_stack_items=6, pushed_stack_items=1)\n\n    REVERT = Opcode(0xFD, popped_stack_items=2)\n    INVALID = Opcode(0xFE)\n\n    SELFDESTRUCT = Opcode(0xFF, popped_stack_items=1)\n    SENDALL = Opcode(0xFF, popped_stack_items=1)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec","title":"<code>ReferenceSpec</code>","text":"<p>Reference Specification Description Abstract Class.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>class ReferenceSpec:\n\"\"\"\n    Reference Specification Description Abstract Class.\n    \"\"\"\n\n    @abstractmethod\n    def name(self) -&gt; str:\n\"\"\"\n        Returns the name of the spec.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def has_known_version(self) -&gt; bool:\n\"\"\"\n        Returns true if the reference spec object is hard-coded with a latest\n        known version.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def known_version(self) -&gt; str:\n\"\"\"\n        Returns the latest known version in the reference.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def latest_version(self) -&gt; str:\n\"\"\"\n        Returns a digest that points to the latest version of the spec.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_outdated(self) -&gt; bool:\n\"\"\"\n        Checks whether the reference specification has been updated since the\n        test was last updated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def write_info(self, info: Dict[str, str]):\n\"\"\"\n        Writes info about the reference specification used into the output\n        fixture.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n        Checks whether the module's dict contains required reference spec\n        information.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n        Parses the module's dict into a reference spec.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.has_known_version","title":"<code>has_known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns true if the reference spec object is hard-coded with a latest known version.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef has_known_version(self) -&gt; bool:\n\"\"\"\n    Returns true if the reference spec object is hard-coded with a latest\n    known version.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.is_outdated","title":"<code>is_outdated()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the reference specification has been updated since the test was last updated.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef is_outdated(self) -&gt; bool:\n\"\"\"\n    Checks whether the reference specification has been updated since the\n    test was last updated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.known_version","title":"<code>known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns the latest known version in the reference.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef known_version(self) -&gt; str:\n\"\"\"\n    Returns the latest known version in the reference.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.latest_version","title":"<code>latest_version()</code>  <code>abstractmethod</code>","text":"<p>Returns a digest that points to the latest version of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef latest_version(self) -&gt; str:\n\"\"\"\n    Returns a digest that points to the latest version of the spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Returns the name of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n\"\"\"\n    Returns the name of the spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parse_from_module","title":"<code>parse_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Parses the module's dict into a reference spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n    Parses the module's dict into a reference spec.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parseable_from_module","title":"<code>parseable_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Checks whether the module's dict contains required reference spec information.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n    Checks whether the module's dict contains required reference spec\n    information.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.write_info","title":"<code>write_info(info)</code>  <code>abstractmethod</code>","text":"<p>Writes info about the reference specification used into the output fixture.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef write_info(self, info: Dict[str, str]):\n\"\"\"\n    Writes info about the reference specification used into the output\n    fixture.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest","title":"<code>StateTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests transactions over the period of a single block.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass StateTest(BaseTest):\n\"\"\"\n    Filler type that tests transactions over the period of a single block.\n    \"\"\"\n\n    env: Environment\n    pre: Mapping[str, Account]\n    post: Mapping[str, Account]\n    txs: List[Transaction]\n    tag: str = \"\"\n\n    @classmethod\n    def pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\n        return \"state_test\"\n\n    def make_genesis(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        fork: Fork,\n    ) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\n        env = self.env.set_fork_requirements(fork)\n\n        genesis = FixtureHeader(\n            parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            coinbase=\"0x0000000000000000000000000000000000000000\",\n            state_root=t8n.calc_state_root(\n                to_json(self.pre),\n                fork,\n            ),\n            transactions_root=EmptyTrieRoot,\n            receipt_root=EmptyTrieRoot,\n            bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            difficulty=0x20000 if env.difficulty is None else env.difficulty,\n            number=env.number - 1,\n            gas_limit=env.gas_limit,\n            gas_used=0,\n            timestamp=0,\n            extra_data=\"0x00\",\n            mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            nonce=\"0x0000000000000000\",\n            base_fee=env.base_fee,\n            excess_data_gas=env.excess_data_gas,\n            withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n            if env.withdrawals is not None\n            else None,\n        )\n\n        (genesis_rlp, genesis.hash) = b11r.build(\n            header=genesis.to_geth_dict(),\n            txs=\"\",\n            ommers=[],\n            withdrawals=env.withdrawals,\n        )\n        return genesis_rlp, genesis\n\n    def make_blocks(\n        self,\n        b11r: BlockBuilder,\n        t8n: TransitionTool,\n        genesis: FixtureHeader,\n        fork: Fork,\n        chain_id=1,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block from the state test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\n        env = self.env.apply_new_parent(genesis)\n        env = env.set_fork_requirements(fork)\n\n        (alloc, result, txs_rlp) = t8n.evaluate(\n            alloc=to_json(self.pre),\n            txs=to_json(self.txs),\n            env=to_json(env),\n            fork=fork,\n            chain_id=chain_id,\n            reward=fork.get_reward(env.number, env.timestamp),\n            eips=eips,\n        )\n\n        rejected_txs = verify_transactions(self.txs, result)\n        if len(rejected_txs) &gt; 0:\n            raise Exception(\n                \"one or more transactions in `StateTest` are \"\n                + \"intrinsically invalid, which are not allowed. \"\n                + \"Use `BlockchainTest` to verify rejection of blocks \"\n                + \"that include invalid transactions.\"\n            )\n\n        try:\n            verify_post_alloc(self.post, alloc)\n        except Exception as e:\n            print_traces(traces=t8n.get_traces())\n            raise e\n\n        header = FixtureHeader.from_dict(\n            result\n            | {\n                \"parentHash\": genesis.hash,\n                \"miner\": env.coinbase,\n                \"transactionsRoot\": result.get(\"txRoot\"),\n                \"difficulty\": str_or_none(\n                    env.difficulty, result.get(\"currentDifficulty\")\n                ),\n                \"number\": str(env.number),\n                \"gasLimit\": str(env.gas_limit),\n                \"timestamp\": str(env.timestamp),\n                \"extraData\": \"0x00\",\n                \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n                \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n                \"nonce\": \"0x0000000000000000\",\n                \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n                \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n            }\n        )\n\n        block, head = b11r.build(\n            header=header.to_geth_dict(),\n            txs=txs_rlp,\n            ommers=[],\n            withdrawals=to_json_or_none(env.withdrawals),\n        )\n        header.hash = head\n\n        return (\n            [\n                FixtureBlock(\n                    rlp=block,\n                    block_header=header,\n                    txs=self.txs if self.txs is not None else [],\n                    ommers=[],\n                    withdrawals=env.withdrawals,\n                )\n            ],\n            head,\n            alloc,\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block from the state test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_blocks(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    genesis: FixtureHeader,\n    fork: Fork,\n    chain_id=1,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block from the state test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\n    env = self.env.apply_new_parent(genesis)\n    env = env.set_fork_requirements(fork)\n\n    (alloc, result, txs_rlp) = t8n.evaluate(\n        alloc=to_json(self.pre),\n        txs=to_json(self.txs),\n        env=to_json(env),\n        fork=fork,\n        chain_id=chain_id,\n        reward=fork.get_reward(env.number, env.timestamp),\n        eips=eips,\n    )\n\n    rejected_txs = verify_transactions(self.txs, result)\n    if len(rejected_txs) &gt; 0:\n        raise Exception(\n            \"one or more transactions in `StateTest` are \"\n            + \"intrinsically invalid, which are not allowed. \"\n            + \"Use `BlockchainTest` to verify rejection of blocks \"\n            + \"that include invalid transactions.\"\n        )\n\n    try:\n        verify_post_alloc(self.post, alloc)\n    except Exception as e:\n        print_traces(traces=t8n.get_traces())\n        raise e\n\n    header = FixtureHeader.from_dict(\n        result\n        | {\n            \"parentHash\": genesis.hash,\n            \"miner\": env.coinbase,\n            \"transactionsRoot\": result.get(\"txRoot\"),\n            \"difficulty\": str_or_none(\n                env.difficulty, result.get(\"currentDifficulty\")\n            ),\n            \"number\": str(env.number),\n            \"gasLimit\": str(env.gas_limit),\n            \"timestamp\": str(env.timestamp),\n            \"extraData\": \"0x00\",\n            \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n            \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n            \"nonce\": \"0x0000000000000000\",\n            \"baseFeePerGas\": result.get(\"currentBaseFee\"),\n            \"excessDataGas\": result.get(\"currentExcessDataGas\"),\n        }\n    )\n\n    block, head = b11r.build(\n        header=header.to_geth_dict(),\n        txs=txs_rlp,\n        ommers=[],\n        withdrawals=to_json_or_none(env.withdrawals),\n    )\n    header.hash = head\n\n    return (\n        [\n            FixtureBlock(\n                rlp=block,\n                block_header=header,\n                txs=self.txs if self.txs is not None else [],\n                ommers=[],\n                withdrawals=env.withdrawals,\n            )\n        ],\n        head,\n        alloc,\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_genesis(\n    self,\n    b11r: BlockBuilder,\n    t8n: TransitionTool,\n    fork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\n    env = self.env.set_fork_requirements(fork)\n\n    genesis = FixtureHeader(\n        parent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        ommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n        coinbase=\"0x0000000000000000000000000000000000000000\",\n        state_root=t8n.calc_state_root(\n            to_json(self.pre),\n            fork,\n        ),\n        transactions_root=EmptyTrieRoot,\n        receipt_root=EmptyTrieRoot,\n        bloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        difficulty=0x20000 if env.difficulty is None else env.difficulty,\n        number=env.number - 1,\n        gas_limit=env.gas_limit,\n        gas_used=0,\n        timestamp=0,\n        extra_data=\"0x00\",\n        mix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n        nonce=\"0x0000000000000000\",\n        base_fee=env.base_fee,\n        excess_data_gas=env.excess_data_gas,\n        withdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\n        if env.withdrawals is not None\n        else None,\n    )\n\n    (genesis_rlp, genesis.hash) = b11r.build(\n        header=genesis.to_geth_dict(),\n        txs=\"\",\n        ommers=[],\n        withdrawals=env.withdrawals,\n    )\n    return genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\n    return \"state_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Transaction","title":"<code>Transaction</code>  <code>dataclass</code>","text":"<p>Generic object that can represent all Ethereum transaction types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Transaction:\n\"\"\"\n    Generic object that can represent all Ethereum transaction types.\n    \"\"\"\n\n    ty: Optional[int] = None\n\"\"\"\n    Transaction type value.\n    \"\"\"\n    chain_id: int = 1\n    nonce: int = 0\n    to: Optional[str] = AddrAA\n    value: int = 0\n    data: bytes | str | Code = bytes()\n    gas_limit: int = 21000\n    access_list: Optional[List[AccessList]] = None\n\n    gas_price: Optional[int] = None\n    max_fee_per_gas: Optional[int] = None\n    max_priority_fee_per_gas: Optional[int] = None\n\n    max_fee_per_data_gas: Optional[int] = None\n    blob_versioned_hashes: Optional[Sequence[str | bytes]] = None\n\n    blob_kzgs: Optional[Sequence[bytes]] = None\n    blobs: Optional[Sequence[Sequence[int]]] = None\n    kzg_aggregated_proof: Optional[str | bytes] = None\n\n    signature: Optional[Tuple[str, str, str]] = None\n    secret_key: Optional[str] = None\n    protected: bool = True\n    error: Optional[str] = None\n\n    class InvalidFeePayment(Exception):\n\"\"\"\n        Transaction described more than one fee payment type.\n        \"\"\"\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return (\n                \"only one type of fee payment field can be used in a single tx\"\n            )\n\n    class InvalidSignaturePrivateKey(Exception):\n\"\"\"\n        Transaction describes both the signature and private key of\n        source account.\n        \"\"\"\n\n        def __str__(self):\n\"\"\"Print exception string\"\"\"\n            return \"can't define both 'signature' and 'private_key'\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"\n        Ensures the transaction has no conflicting properties.\n        \"\"\"\n        if (\n            self.gas_price is not None\n            and self.max_fee_per_gas is not None\n            and self.max_priority_fee_per_gas is not None\n        ):\n            raise Transaction.InvalidFeePayment()\n\n        if (\n            self.gas_price is None\n            and self.max_fee_per_gas is None\n            and self.max_priority_fee_per_gas is None\n        ):\n            self.gas_price = 10\n\n        if self.signature is not None and self.secret_key is not None:\n            raise Transaction.InvalidSignaturePrivateKey()\n\n        if self.signature is None and self.secret_key is None:\n            self.secret_key = TestPrivateKey\n\n        if self.ty is None:\n            # Try to deduce transaction type from included fields\n            if self.max_fee_per_data_gas is not None:\n                self.ty = 5\n            elif self.max_fee_per_gas is not None:\n                self.ty = 2\n            elif self.access_list is not None:\n                self.ty = 1\n            else:\n                self.ty = 0\n\n    def with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with an added error.\n        \"\"\"\n        tx = copy(self)\n        tx.error = error\n        return tx\n\n    def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with a modified nonce.\n        \"\"\"\n        tx = copy(self)\n        tx.nonce = nonce\n        return tx\n\n    def with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n        Create a deepcopy of the transaction with modified fields.\n        \"\"\"\n        tx = deepcopy(self)\n        for key, value in kwargs.items():\n            if hasattr(tx, key):\n                setattr(tx, key, value)\n            else:\n                raise ValueError(f\"Invalid field '{key}' for Transaction\")\n        return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.ty","title":"<code>ty: Optional[int] = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Transaction type value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment","title":"<code>InvalidFeePayment</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction described more than one fee payment type.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidFeePayment(Exception):\n\"\"\"\n    Transaction described more than one fee payment type.\n    \"\"\"\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return (\n            \"only one type of fee payment field can be used in a single tx\"\n        )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return (\n        \"only one type of fee payment field can be used in a single tx\"\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey","title":"<code>InvalidSignaturePrivateKey</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction describes both the signature and private key of source account.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidSignaturePrivateKey(Exception):\n\"\"\"\n    Transaction describes both the signature and private key of\n    source account.\n    \"\"\"\n\n    def __str__(self):\n\"\"\"Print exception string\"\"\"\n        return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\n    return \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures the transaction has no conflicting properties.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"\n    Ensures the transaction has no conflicting properties.\n    \"\"\"\n    if (\n        self.gas_price is not None\n        and self.max_fee_per_gas is not None\n        and self.max_priority_fee_per_gas is not None\n    ):\n        raise Transaction.InvalidFeePayment()\n\n    if (\n        self.gas_price is None\n        and self.max_fee_per_gas is None\n        and self.max_priority_fee_per_gas is None\n    ):\n        self.gas_price = 10\n\n    if self.signature is not None and self.secret_key is not None:\n        raise Transaction.InvalidSignaturePrivateKey()\n\n    if self.signature is None and self.secret_key is None:\n        self.secret_key = TestPrivateKey\n\n    if self.ty is None:\n        # Try to deduce transaction type from included fields\n        if self.max_fee_per_data_gas is not None:\n            self.ty = 5\n        elif self.max_fee_per_gas is not None:\n            self.ty = 2\n        elif self.access_list is not None:\n            self.ty = 1\n        else:\n            self.ty = 0\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_error","title":"<code>with_error(error)</code>","text":"<p>Create a copy of the transaction with an added error.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with an added error.\n    \"\"\"\n    tx = copy(self)\n    tx.error = error\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_fields","title":"<code>with_fields(**kwargs)</code>","text":"<p>Create a deepcopy of the transaction with modified fields.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n    Create a deepcopy of the transaction with modified fields.\n    \"\"\"\n    tx = deepcopy(self)\n    for key, value in kwargs.items():\n        if hasattr(tx, key):\n            setattr(tx, key, value)\n        else:\n            raise ValueError(f\"Invalid field '{key}' for Transaction\")\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_nonce","title":"<code>with_nonce(nonce)</code>","text":"<p>Create a copy of the transaction with a modified nonce.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with a modified nonce.\n    \"\"\"\n    tx = copy(self)\n    tx.nonce = nonce\n    return tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Withdrawal","title":"<code>Withdrawal</code>  <code>dataclass</code>","text":"<p>Structure to represent a single withdrawal of a validator's balance from the beacon chain.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Withdrawal:\n\"\"\"\n    Structure to represent a single withdrawal of a validator's balance from\n    the beacon chain.\n    \"\"\"\n\n    index: int\n    validator: int\n    address: str\n    amount: int\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Yul","title":"<code>Yul</code>","text":"<p>         Bases: <code>Code</code></p> <p>Yul compiler. Compiles Yul source code into bytecode.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>class Yul(Code):\n\"\"\"\n    Yul compiler.\n    Compiles Yul source code into bytecode.\n    \"\"\"\n\n    source: str\n    compiled: Optional[bytes] = None\n\n    def __init__(self, source: str):\n        self.source = source\n\n    def assemble(self) -&gt; bytes:\n\"\"\"\n        Assembles using `solc --assemble`.\n        \"\"\"\n        if not self.compiled:\n            result = run(\n                SOLC_ARGS,\n                input=str.encode(self.source),\n                stdout=PIPE,\n                stderr=PIPE,\n            )\n\n            if result.returncode != 0:\n                stderr_lines = result.stderr.decode().split(\"\\n\")\n                stderr_message = \"\\n\".join(\n                    line.strip() for line in stderr_lines\n                )\n                raise Exception(\n                    f\"failed to compile yul source:\\n{stderr_message[7:]}\"\n                )\n\n            lines = result.stdout.decode().split(\"\\n\")\n\n            hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n            self.compiled = bytes.fromhex(hex_str)\n        return self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.yul.Yul.assemble","title":"<code>assemble()</code>","text":"<p>Assembles using <code>solc --assemble</code>.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assembles using `solc --assemble`.\n    \"\"\"\n    if not self.compiled:\n        result = run(\n            SOLC_ARGS,\n            input=str.encode(self.source),\n            stdout=PIPE,\n            stderr=PIPE,\n        )\n\n        if result.returncode != 0:\n            stderr_lines = result.stderr.decode().split(\"\\n\")\n            stderr_message = \"\\n\".join(\n                line.strip() for line in stderr_lines\n            )\n            raise Exception(\n                f\"failed to compile yul source:\\n{stderr_message[7:]}\"\n            )\n\n        lines = result.stdout.decode().split(\"\\n\")\n\n        hex_str = lines[lines.index(\"Binary representation:\") + 1]\n\n        self.compiled = bytes.fromhex(hex_str)\n    return self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ceiling_division","title":"<code>ceiling_division(a, b)</code>","text":"<p>Calculates the ceil without using floating point. Used by many of the EVM's formulas</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def ceiling_division(a: int, b: int) -&gt; int:\n\"\"\"\n    Calculates the ceil without using floating point.\n    Used by many of the EVM's formulas\n    \"\"\"\n    return -(a // -b)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create2_address","title":"<code>compute_create2_address(address, salt, initcode)</code>","text":"<p>Compute address of the resulting contract created using the <code>CREATE2</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create2_address(\n    address: str | int, salt: int, initcode: bytes\n) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using the `CREATE2`\n    opcode.\n    \"\"\"\n    ff = bytes([0xFF])\n    if type(address) is str:\n        if address.startswith(\"0x\"):\n            address = address[2:]\n        address_bytes = bytes.fromhex(address)\n    elif type(address) is int:\n        address_bytes = address.to_bytes(length=20, byteorder=\"big\")\n    salt_bytes = salt.to_bytes(length=32, byteorder=\"big\")\n    initcode_hash = keccak256(initcode)\n    hash = keccak256(ff + address_bytes + salt_bytes + initcode_hash)\n    return \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create_address","title":"<code>compute_create_address(address, nonce)</code>","text":"<p>Compute address of the resulting contract created using a transaction or the <code>CREATE</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create_address(address: str | int, nonce: int) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using a transaction\n    or the `CREATE` opcode.\n    \"\"\"\n    if type(address) is str:\n        if address.startswith(\"0x\"):\n            address = address[2:]\n        address_bytes = bytes.fromhex(address)\n    elif type(address) is int:\n        address_bytes = address.to_bytes(length=20, byteorder=\"big\")\n    if nonce == 0:\n        nonce_bytes = bytes()\n    else:\n        nonce_bytes = nonce.to_bytes(length=1, byteorder=\"big\")\n    hash = keccak256(encode([address_bytes, nonce_bytes]))\n    return \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.eip_2028_transaction_data_cost","title":"<code>eip_2028_transaction_data_cost(data)</code>","text":"<p>Calculates the cost of a given data as part of a transaction, based on the costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def eip_2028_transaction_data_cost(data: bytes | str) -&gt; int:\n\"\"\"\n    Calculates the cost of a given data as part of a transaction, based on the\n    costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028\n    \"\"\"\n    if type(data) is str:\n        if data.startswith(\"0x\"):\n            data = data[2:]\n        data = bytes.fromhex(data)\n    cost = 0\n    for b in data:\n        if b == 0:\n            cost += 4\n        else:\n            cost += 16\n    return cost\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.fill_test","title":"<code>fill_test(t8n, b11r, test_spec, fork, engine, spec, eips=None)</code>","text":"<p>Fills fixtures for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/fill.py</code> <pre><code>def fill_test(\n    t8n: TransitionTool,\n    b11r: BlockBuilder,\n    test_spec: BaseTest,\n    fork: Fork,\n    engine: str,\n    spec: ReferenceSpec | None,\n    eips: Optional[List[int]] = None,\n) -&gt; Fixture:\n\"\"\"\n    Fills fixtures for the specified fork.\n    \"\"\"\n    t8n.reset_traces()\n\n    genesis_rlp, genesis = test_spec.make_genesis(b11r, t8n, fork)\n\n    (blocks, head, alloc) = test_spec.make_blocks(\n        b11r,\n        t8n,\n        genesis,\n        fork,\n        eips=eips,\n    )\n\n    fork_name = fork.name()\n    fixture = Fixture(\n        blocks=blocks,\n        genesis=genesis,\n        genesis_rlp=genesis_rlp,\n        head=head,\n        fork=\"+\".join([fork_name] + [str(eip) for eip in eips])\n        if eips is not None\n        else fork_name,\n        pre_state=copy(test_spec.pre),\n        post_state=alloc_to_accounts(alloc),\n        seal_engine=engine,\n        name=test_spec.tag,\n    )\n    fixture.fill_info(t8n, b11r, spec)\n\n    return fixture\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from","title":"<code>test_from(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from(\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\n    return _filler_decorator(forks=forks_from(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from_until","title":"<code>test_from_until(fork_from, fork_until, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from_until(\n    fork_from: Fork,\n    fork_until: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\n    return _filler_decorator(\n        forks=forks_from_until(fork_from, fork_until), eips=eips\n    )\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_only","title":"<code>test_only(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it only for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_only(\n    fork: Fork,\n    eips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it only for the specified\n    fork.\n    \"\"\"\n    return _filler_decorator(forks=fork_only(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_address","title":"<code>to_address(input)</code>","text":"<p>Converts an int or str into proper address 20-byte hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_address(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper address 20-byte hex string.\n    \"\"\"\n    if type(input) is str:\n        # Convert to int\n        input = int(input, 0)\n    if type(input) is int:\n        return \"0x\" + input.to_bytes(20, \"big\").hex()\n    raise Exception(\"invalid type to convert to account address\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash","title":"<code>to_hash(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper 32-byte hash hex string.\n    \"\"\"\n    return \"0x\" + to_hash_bytes(input).hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash_bytes","title":"<code>to_hash_bytes(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash_bytes(input: int | str) -&gt; bytes:\n\"\"\"\n    Converts an int or str into proper 32-byte hash.\n    \"\"\"\n    if type(input) is str:\n        # Convert to int\n        input = int(input, 0)\n    if type(input) is int:\n        return input.to_bytes(32, \"big\")\n    raise Exception(\"invalid type to convert to hash\")\n</code></pre>"},{"location":"library/evm_block_builder/","title":"EVM Block Builder Package","text":"<p>Python wrapper for the <code>evm b11r</code> tool.</p>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder","title":"<code>BlockBuilder</code>","text":"<p>Generic Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class BlockBuilder:\n\"\"\"\n    Generic Block builder frontend.\n    \"\"\"\n\n    @abstractmethod\n    def build(\n        self,\n        header: Any,\n        txs: Any,\n        ommers: Any,\n        withdrawals: Optional[Any] = None,\n        clique: Optional[Any] = None,\n        ethash: bool = False,\n        ethash_mode: str = \"normal\",\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Build a block with specified parameters and return RLP and hash\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to build the block\n        \"\"\"\n        pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>  <code>abstractmethod</code>","text":"<p>Build a block with specified parameters and return RLP and hash</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef build(\n    self,\n    header: Any,\n    txs: Any,\n    ommers: Any,\n    withdrawals: Optional[Any] = None,\n    clique: Optional[Any] = None,\n    ethash: bool = False,\n    ethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Build a block with specified parameters and return RLP and hash\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to build the block</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to build the block\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder","title":"<code>EvmBlockBuilder</code>","text":"<p>         Bases: <code>BlockBuilder</code></p> <p>Go-ethereum <code>evm</code> Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class EvmBlockBuilder(BlockBuilder):\n\"\"\"\n    Go-ethereum `evm` Block builder frontend.\n    \"\"\"\n\n    binary: Path\n    cached_version: Optional[str] = None\n\n    def __init__(self, binary: Optional[Path] = None):\n        if binary is None:\n            which_path = which(\"evm\")\n            if which_path is not None:\n                binary = Path(which_path)\n        if binary is None or not binary.exists():\n            raise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n            )\n        self.binary = binary\n\n    def build(\n        self,\n        header: Any,\n        txs: Any,\n        ommers: Any,\n        withdrawals: Optional[Any] = None,\n        clique: Optional[Any] = None,\n        ethash: bool = False,\n        ethash_mode: str = \"normal\",\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Executes `evm b11r` with the specified arguments.\n        \"\"\"\n        args = [\n            str(self.binary),\n            \"b11r\",\n            \"--input.header=stdin\",\n            \"--input.txs=stdin\",\n            \"--input.ommers=stdin\",\n            \"--seal.clique=stdin\",\n            \"--output.block=stdout\",\n            \"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n        ]\n\n        if ethash:\n            args.append(\"--seal.ethash\")\n            args.append(\"--seal.ethash.mode=\" + ethash_mode)\n\n        stdin = {\n            \"header\": header,\n            \"txs\": txs,\n            \"uncles\": ommers,\n            \"clique\": clique,\n        }\n        if withdrawals is not None:\n            stdin[\"withdrawals\"] = withdrawals\n\n        result = subprocess.run(\n            args,\n            input=str.encode(json.dumps(stdin)),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\"failed to build\")\n\n        output = json.loads(result.stdout)\n\n        if \"rlp\" not in output or \"hash\" not in output:\n            Exception(\"malformed result\")\n\n        return (output[\"rlp\"], output[\"hash\"])\n\n    def version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\n        if self.cached_version is None:\n            result = subprocess.run(\n                [str(self.binary), \"-v\"],\n                stdout=subprocess.PIPE,\n            )\n\n            if result.returncode != 0:\n                raise Exception(\n                    \"failed to evaluate: \" + result.stderr.decode()\n                )\n\n            self.cached_version = result.stdout.decode().strip()\n\n        return self.cached_version\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>","text":"<p>Executes <code>evm b11r</code> with the specified arguments.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def build(\n    self,\n    header: Any,\n    txs: Any,\n    ommers: Any,\n    withdrawals: Optional[Any] = None,\n    clique: Optional[Any] = None,\n    ethash: bool = False,\n    ethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Executes `evm b11r` with the specified arguments.\n    \"\"\"\n    args = [\n        str(self.binary),\n        \"b11r\",\n        \"--input.header=stdin\",\n        \"--input.txs=stdin\",\n        \"--input.ommers=stdin\",\n        \"--seal.clique=stdin\",\n        \"--output.block=stdout\",\n        \"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n    ]\n\n    if ethash:\n        args.append(\"--seal.ethash\")\n        args.append(\"--seal.ethash.mode=\" + ethash_mode)\n\n    stdin = {\n        \"header\": header,\n        \"txs\": txs,\n        \"uncles\": ommers,\n        \"clique\": clique,\n    }\n    if withdrawals is not None:\n        stdin[\"withdrawals\"] = withdrawals\n\n    result = subprocess.run(\n        args,\n        input=str.encode(json.dumps(stdin)),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    if result.returncode != 0:\n        raise Exception(\"failed to build\")\n\n    output = json.loads(result.stdout)\n\n    if \"rlp\" not in output or \"hash\" not in output:\n        Exception(\"malformed result\")\n\n    return (output[\"rlp\"], output[\"hash\"])\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\n    if self.cached_version is None:\n        result = subprocess.run(\n            [str(self.binary), \"-v\"],\n            stdout=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\n                \"failed to evaluate: \" + result.stderr.decode()\n            )\n\n        self.cached_version = result.stdout.decode().strip()\n\n    return self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/","title":"EVM Transition Tool Package","text":"<p>Python wrapper for the <code>evm t8n</code> tool.</p>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool","title":"<code>EvmTransitionTool</code>","text":"<p>         Bases: <code>TransitionTool</code></p> <p>Go-ethereum <code>evm</code> Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class EvmTransitionTool(TransitionTool):\n\"\"\"\n    Go-ethereum `evm` Transition tool frontend.\n    \"\"\"\n\n    binary: Path\n    cached_version: Optional[str] = None\n    trace: bool\n\n    def __init__(\n        self,\n        binary: Optional[Path] = None,\n        trace: bool = False,\n    ):\n        if binary is None:\n            which_path = which(\"evm\")\n            if which_path is not None:\n                binary = Path(which_path)\n        if binary is None or not binary.exists():\n            raise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n            )\n        self.binary = binary\n        self.trace = trace\n\n    def evaluate(\n        self,\n        alloc: Any,\n        txs: Any,\n        env: Any,\n        fork: Fork,\n        chain_id: int = 1,\n        reward: int = 0,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Executes `evm t8n` with the specified arguments.\n        \"\"\"\n        fork_name = fork.name()\n        if eips is not None:\n            fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n        temp_dir = tempfile.TemporaryDirectory()\n\n        args = [\n            str(self.binary),\n            \"t8n\",\n            \"--input.alloc=stdin\",\n            \"--input.txs=stdin\",\n            \"--input.env=stdin\",\n            \"--output.result=stdout\",\n            \"--output.alloc=stdout\",\n            \"--output.body=txs.rlp\",\n            f\"--output.basedir={temp_dir.name}\",\n            f\"--state.fork={fork_name}\",\n            f\"--state.chainid={chain_id}\",\n            f\"--state.reward={reward}\",\n        ]\n\n        if self.trace:\n            args.append(\"--trace\")\n\n        stdin = {\n            \"alloc\": alloc,\n            \"txs\": txs,\n            \"env\": env,\n        }\n\n        encoded_input = str.encode(json.dumps(stdin))\n        result = subprocess.run(\n            args,\n            input=encoded_input,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n        output = json.loads(result.stdout)\n\n        if \"alloc\" not in output or \"result\" not in output:\n            raise Exception(\"malformed result\")\n\n        with open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\n            txs_rlp = txs_rlp_file.read().strip('\"')\n\n        if self.trace:\n            receipts: List[Any] = output[\"result\"][\"receipts\"]\n            traces: List[List[Dict]] = []\n            for i, r in enumerate(receipts):\n                h = r[\"transactionHash\"]\n                trace_file_name = f\"trace-{i}-{h}.jsonl\"\n                with open(\n                    os.path.join(temp_dir.name, trace_file_name), \"r\"\n                ) as trace_file:\n                    tx_traces: List[Dict] = []\n                    for trace_line in trace_file.readlines():\n                        tx_traces.append(json.loads(trace_line))\n                    traces.append(tx_traces)\n            self.append_traces(traces)\n\n        temp_dir.cleanup()\n\n        return (output[\"alloc\"], output[\"result\"], txs_rlp)\n\n    def version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\n        if self.cached_version is None:\n            result = subprocess.run(\n                [str(self.binary), \"-v\"],\n                stdout=subprocess.PIPE,\n            )\n\n            if result.returncode != 0:\n                raise Exception(\n                    \"failed to evaluate: \" + result.stderr.decode()\n                )\n\n            self.cached_version = result.stdout.decode().strip()\n\n        return self.cached_version\n\n    def is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\n        return True\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>","text":"<p>Executes <code>evm t8n</code> with the specified arguments.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def evaluate(\n    self,\n    alloc: Any,\n    txs: Any,\n    env: Any,\n    fork: Fork,\n    chain_id: int = 1,\n    reward: int = 0,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Executes `evm t8n` with the specified arguments.\n    \"\"\"\n    fork_name = fork.name()\n    if eips is not None:\n        fork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\n\n    temp_dir = tempfile.TemporaryDirectory()\n\n    args = [\n        str(self.binary),\n        \"t8n\",\n        \"--input.alloc=stdin\",\n        \"--input.txs=stdin\",\n        \"--input.env=stdin\",\n        \"--output.result=stdout\",\n        \"--output.alloc=stdout\",\n        \"--output.body=txs.rlp\",\n        f\"--output.basedir={temp_dir.name}\",\n        f\"--state.fork={fork_name}\",\n        f\"--state.chainid={chain_id}\",\n        f\"--state.reward={reward}\",\n    ]\n\n    if self.trace:\n        args.append(\"--trace\")\n\n    stdin = {\n        \"alloc\": alloc,\n        \"txs\": txs,\n        \"env\": env,\n    }\n\n    encoded_input = str.encode(json.dumps(stdin))\n    result = subprocess.run(\n        args,\n        input=encoded_input,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    if result.returncode != 0:\n        raise Exception(\"failed to evaluate: \" + result.stderr.decode())\n\n    output = json.loads(result.stdout)\n\n    if \"alloc\" not in output or \"result\" not in output:\n        raise Exception(\"malformed result\")\n\n    with open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\n        txs_rlp = txs_rlp_file.read().strip('\"')\n\n    if self.trace:\n        receipts: List[Any] = output[\"result\"][\"receipts\"]\n        traces: List[List[Dict]] = []\n        for i, r in enumerate(receipts):\n            h = r[\"transactionHash\"]\n            trace_file_name = f\"trace-{i}-{h}.jsonl\"\n            with open(\n                os.path.join(temp_dir.name, trace_file_name), \"r\"\n            ) as trace_file:\n                tx_traces: List[Dict] = []\n                for trace_line in trace_file.readlines():\n                    tx_traces.append(json.loads(trace_line))\n                traces.append(tx_traces)\n        self.append_traces(traces)\n\n    temp_dir.cleanup()\n\n    return (output[\"alloc\"], output[\"result\"], txs_rlp)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.is_fork_supported","title":"<code>is_fork_supported(_)</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\n    return True\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\n    if self.cached_version is None:\n        result = subprocess.run(\n            [str(self.binary), \"-v\"],\n            stdout=subprocess.PIPE,\n        )\n\n        if result.returncode != 0:\n            raise Exception(\n                \"failed to evaluate: \" + result.stderr.decode()\n            )\n\n        self.cached_version = result.stdout.decode().strip()\n\n    return self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool","title":"<code>TransitionTool</code>","text":"<p>Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class TransitionTool:\n\"\"\"\n    Transition tool frontend.\n    \"\"\"\n\n    traces: List[List[List[Dict]]] | None = None\n\n    @abstractmethod\n    def evaluate(\n        self,\n        alloc: Any,\n        txs: Any,\n        env: Any,\n        fork: Fork,\n        chain_id: int = 1,\n        reward: int = 0,\n        eips: Optional[List[int]] = None,\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Simulate a state transition with specified parameters\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to state transition\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\n        pass\n\n    def reset_traces(self):\n\"\"\"\n        Resets the internal trace storage for a new test to begin\n        \"\"\"\n        self.traces = None\n\n    def append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n        Appends a list of traces of a state transition to the current list\n        \"\"\"\n        if self.traces is None:\n            self.traces = []\n        self.traces.append(new_traces)\n\n    def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n        Returns the accumulated traces\n        \"\"\"\n        return self.traces\n\n    def calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\n        env: Dict[str, Any] = {\n            \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n            \"currentDifficulty\": \"0x0\",\n            \"currentGasLimit\": \"0x0\",\n            \"currentNumber\": \"0\",\n            \"currentTimestamp\": \"0\",\n        }\n\n        if fork.header_base_fee_required(0, 0):\n            env[\"currentBaseFee\"] = \"7\"\n\n        if fork.header_prev_randao_required(0, 0):\n            env[\"currentRandom\"] = \"0\"\n\n        if fork.header_withdrawals_required(0, 0):\n            env[\"withdrawals\"] = []\n\n        (_, result, _) = self.evaluate(alloc, [], env, fork)\n        state_root = result.get(\"stateRoot\")\n        if state_root is None or not isinstance(state_root, str):\n            raise Exception(\"Unable to calculate state root\")\n        return state_root\n\n    def calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\n        if type(withdrawals) is list and len(withdrawals) == 0:\n            # Optimize returning the empty root immediately\n            return \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\n\n        env: Dict[str, Any] = {\n            \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n            \"currentDifficulty\": \"0x0\",\n            \"currentGasLimit\": \"0x0\",\n            \"currentNumber\": \"0\",\n            \"currentTimestamp\": \"0\",\n            \"withdrawals\": withdrawals,\n        }\n\n        if fork.header_base_fee_required(0, 0):\n            env[\"currentBaseFee\"] = \"7\"\n\n        if fork.header_prev_randao_required(0, 0):\n            env[\"currentRandom\"] = \"0\"\n\n        if fork.header_excess_data_gas_required(0, 0):\n            env[\"currentExcessDataGas\"] = \"0\"\n\n        (_, result, _) = self.evaluate({}, [], env, fork)\n        withdrawals_root = result.get(\"withdrawalsRoot\")\n        if withdrawals_root is None:\n            raise Exception(\n                \"Unable to calculate withdrawals root: \"\n                + \"no value returned from transition tool\"\n            )\n        if type(withdrawals_root) is not str:\n            raise Exception(\n                \"Unable to calculate withdrawals root: \"\n                + \"incorrect type returned from transition tool: \"\n                + f\"{withdrawals_root}\"\n            )\n        return withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.append_traces","title":"<code>append_traces(new_traces)</code>","text":"<p>Appends a list of traces of a state transition to the current list</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n    Appends a list of traces of a state transition to the current list\n    \"\"\"\n    if self.traces is None:\n        self.traces = []\n    self.traces.append(new_traces)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_state_root","title":"<code>calc_state_root(alloc, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\n    env: Dict[str, Any] = {\n        \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n        \"currentDifficulty\": \"0x0\",\n        \"currentGasLimit\": \"0x0\",\n        \"currentNumber\": \"0\",\n        \"currentTimestamp\": \"0\",\n    }\n\n    if fork.header_base_fee_required(0, 0):\n        env[\"currentBaseFee\"] = \"7\"\n\n    if fork.header_prev_randao_required(0, 0):\n        env[\"currentRandom\"] = \"0\"\n\n    if fork.header_withdrawals_required(0, 0):\n        env[\"withdrawals\"] = []\n\n    (_, result, _) = self.evaluate(alloc, [], env, fork)\n    state_root = result.get(\"stateRoot\")\n    if state_root is None or not isinstance(state_root, str):\n        raise Exception(\"Unable to calculate state root\")\n    return state_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_withdrawals_root","title":"<code>calc_withdrawals_root(withdrawals, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\n    if type(withdrawals) is list and len(withdrawals) == 0:\n        # Optimize returning the empty root immediately\n        return \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\n\n    env: Dict[str, Any] = {\n        \"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n        \"currentDifficulty\": \"0x0\",\n        \"currentGasLimit\": \"0x0\",\n        \"currentNumber\": \"0\",\n        \"currentTimestamp\": \"0\",\n        \"withdrawals\": withdrawals,\n    }\n\n    if fork.header_base_fee_required(0, 0):\n        env[\"currentBaseFee\"] = \"7\"\n\n    if fork.header_prev_randao_required(0, 0):\n        env[\"currentRandom\"] = \"0\"\n\n    if fork.header_excess_data_gas_required(0, 0):\n        env[\"currentExcessDataGas\"] = \"0\"\n\n    (_, result, _) = self.evaluate({}, [], env, fork)\n    withdrawals_root = result.get(\"withdrawalsRoot\")\n    if withdrawals_root is None:\n        raise Exception(\n            \"Unable to calculate withdrawals root: \"\n            + \"no value returned from transition tool\"\n        )\n    if type(withdrawals_root) is not str:\n        raise Exception(\n            \"Unable to calculate withdrawals root: \"\n            + \"incorrect type returned from transition tool: \"\n            + f\"{withdrawals_root}\"\n        )\n    return withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Simulate a state transition with specified parameters</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef evaluate(\n    self,\n    alloc: Any,\n    txs: Any,\n    env: Any,\n    fork: Fork,\n    chain_id: int = 1,\n    reward: int = 0,\n    eips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Simulate a state transition with specified parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.get_traces","title":"<code>get_traces()</code>","text":"<p>Returns the accumulated traces</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n    Returns the accumulated traces\n    \"\"\"\n    return self.traces\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>  <code>abstractmethod</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.reset_traces","title":"<code>reset_traces()</code>","text":"<p>Resets the internal trace storage for a new test to begin</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def reset_traces(self):\n\"\"\"\n    Resets the internal trace storage for a new test to begin\n    \"\"\"\n    self.traces = None\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to state transition</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to state transition\n    \"\"\"\n    pass\n</code></pre>"},{"location":"library/library/","title":"Overview","text":""},{"location":"library/library/#library-tools-reference-documentation","title":"Library (Tools) Reference Documentation","text":"<p>Execution spec tests consists of several packages that implement helper classes and tools that enable and simplify filler implementation. This section contains their reference documentation:</p> <ul> <li><code>ethereum_test_forks</code></li> <li><code>ethereum_test_tools</code></li> <li><code>evm_block_builder</code></li> <li><code>evm_transition_tool</code></li> <li><code>pytest_plugins</code></li> </ul>"},{"location":"library/pytest_plugins/","title":"Pytest Plugins","text":""},{"location":"library/pytest_plugins/#pytest-framework-and-customizations","title":"Pytest Framework and Customizations","text":"<p>Package containing pytest plugins related to test filling.</p>"},{"location":"test_case_descriptions/eip4844/","title":"\ud83e\uddea Execution Specification Test Cases","text":"<p>Note: This is still a WIP but the tests can still be used by any client team. The priority levels (\ud83d\udd34, \ud83d\udfe0, \ud83d\udfe1, \ud83d\udfe2) represent very high, high, medium, low  priorities respectively.</p>"},{"location":"test_case_descriptions/eip4844/#datahash-opcode","title":"\ud83d\udcd6 Datahash Opcode","text":"<p>Test Module - <code>eip4844/datahash_opcode.py</code></p> <p>Verifies that the <code>DATAHASH</code> opcode, works as intended for a variety of contexts, retrieves the blob versioned hash correctly for a given index, returns the correct zeroed <code>bytes32</code> value for out-of-range indices, and consumes the correct amount of gas.</p> <p>1) \ud83d\udd34 test_datahash_opcode_contexts():</p> <p>Tests that the <code>DATAHASH</code> opcode functions correctly when called in different contexts including: - <code>DATAHASH</code> opcode on the top level of the call stack. - <code>DATAHASH</code> opcode on the max value. - <code>DATAHASH</code> opcode on <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, and <code>CALLCODE</code>. - <code>DATAHASH</code> opcode on Initcode. - <code>DATAHASH</code> opcode on <code>CREATE</code> and <code>CREATE2</code>. - <code>DATAHASH</code> opcode on transaction types 0, 1 and 2.</p> <p>2) \ud83d\udd34 test_datahash_blob_versioned_hash():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the correct versioned hash for various valid indexes. This test covers various scenarios with random <code>blob_versioned_hash</code> values within the valid range <code>[0, 2**256-1]</code>.</p> <p>3) \ud83d\udd34 test_datahash_invalid_blob_index():</p> <p>Tests that the <code>DATAHASH</code> opcode returns a zeroed <code>bytes32</code> value for invalid indexes. This test includes cases where the index is negative (<code>index &lt; 0</code>) or exceeds the maximum number of <code>blob_versioned_hash</code> values stored (<code>index &gt;= len(tx.message.blob_versioned_hashes)</code>). It confirms that the returned value is a zeroed <code>bytes32</code> value for these cases.</p> <p>4) \ud83d\udfe0 test_datahash_gas_cost():</p> <p>Asserts the gas consumption of the <code>DATAHASH</code> opcode is correct by ensuring it matches <code>HASH_OPCODE_GAS = 3</code>. It includes both valid and invalid random index sizes from the range <code>[0, 2**256-1]</code>, for tx types 2 and 3.</p> <p>5) \ud83d\udfe1 test_datahash_multiple_txs_in_block():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the appropriate values when there is more than one blob tx type within a block (for tx types 2 and 3). Scenarios involve tx type 3 followed by tx type 2 running the same code within a block. In this case <code>DATAHASH</code> returns 0, but for the opposite scenario <code>DATAHASH</code> returns the correct <code>blob_versioned_hash</code>.</p>"},{"location":"test_case_descriptions/eip4844/#excess-data-gas","title":"\ud83d\udcbd\u26fd\ud83d\udcb8 Excess Data Gas","text":"<p>Test Module - <code>eip4844/excess_data_gas.py</code></p> <p>Predominantly verifies that <code>excess_data_gas</code> &amp; <code>data_gasprice</code> are calculated correctly ensuring both valid and invalid transactions are processed accordingly. Extra verification is added specifically for invalid blob transactions when the <code>max_fee_per_data_gas</code>, number of blobs or transaction type are errorneous. </p> <p>1) \ud83d\udd34 test_excess_data_gas_calculation():</p> <p>Tests that the <code>excess_data_gas</code> is calculated correctly within a single block for various contexts, where the <code>parent.excess_data_gas</code> and the proposed block <code>excess_data_gas</code> have a variety of values. The excess data gas is calculated using the following formula:</p> <pre><code>def calc_excess_data_gas(parent: Header, new_blobs: int) -&gt; int:\n    consumed_data_gas = new_blobs * DATA_GAS_PER_BLOB\n    if parent.excess_data_gas + consumed_data_gas &lt; TARGET_DATA_GAS_PER_BLOCK:\n        return 0\n    else:\n        return parent.excess_data_gas + consumed_data_gas - TARGET_DATA_GAS_PER_BLOCK\n</code></pre> <p>For blocks to be valid in these contexts they must meet the following conditions of the EIP:   - Each block can only have a maximum of <code>MAX_BLOBS_PER_BLOCK</code>.   - A type 5 blob transaction must have at least one blob - <code>len(versioned_hashes) &gt; 0</code>.   - The user is open to paying the current data gasprice for the transaction -<code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code>   - The account used for the blob transaction must have enough balance - <code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> <p>2) \ud83d\udd34 test_invalid_excess_data_gas_in_header():</p> <p>Asserts that blocks with invalid <code>excess_data_gas</code> values in the header are ignored, ensuring the blob transaction is rejected and no state changes occur. The invalidity of <code>excess_data_gas</code> within a new block header is tested across the following scenarios:</p> <ul> <li> <p><code>excess_data_gas</code> decreases or increases by <code>TARGET_DATA_GAS_PER_BLOCK + 1</code> in a single block. Note that the EIP only allows <code>excess_data_gas</code> to decrease &amp; increase by a maximum of <code>TARGET_DATA_GAS_PER_BLOCK</code>.</p> </li> <li> <p><code>excess_data_gas</code> is unchanged when the number of blobs in the proposed block doesn't equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are different from the target, <code>excess_data_gas</code> must change. </p> </li> <li> <p><code>excess_data_gas</code> is changed when the number of blobs in the proposed block does equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are equal to the target,<code>excess_data_gas</code> must remain the same value - <code>parent_excess_data_gas</code>.</p> </li> <li> <p><code>excess_data_gas</code> is less than the <code>TARGET_DATA_GAS_PER_BLOCK</code> when the parent has 0 blobs (<code>parent.excess_data_gas</code> = 0), and the calculated excess is non-zero. This is invalid as the first condition in the excess data gas calculation must be met, and hence return zero for this case. </p> </li> <li> <p><code>excess_data_gas</code> is a value greater than <code>2**256-1</code>. It must be a value that fits within 256-bits.</p> </li> </ul> <p>3) \ud83d\udd34 test_fork_transition_excess_data_gas_in_header():</p> <p>Tests that the <code>excess_data_gas</code> calculation is correct when transitioning from the Shanghai fork to the Cancun fork, where appended blocks are valid and state changes occur. Each block has a single transaction with <code>MAX_BLOBS_PER_BLOCK</code> blobs. The first block during the transition period has a parent of zero <code>excess_data_gas</code> in the header. Each block afterwards calculates <code>excess_data_gas</code> using the following <code>calc_excess_data_gas</code> function such that it continuously increases.</p> <p>4) \ud83d\udd34 test_invalid_blob_txs():</p> <p>Asserts that blocks with invalid blob transactions are rejected and no state changes occur. This is tested across the following scenarios:</p> <ul> <li><code>max_fee_per_data_gas</code> is less than the required <code>data_gasprice</code> for a set number of excess blobs. This is invaild as a valid block must obey the following condition:</li> <li> <p><code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> is greater than the required <code>data_gasprice</code> for a set number of excess blobs but the account doesn't have the required balance to cover the total cost of the transaction. A valid block must prove true for the following condition: </p> </li> <li> <p><code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> has an invalid value of zero. This value is invalid as it is less than <code>MIN_DATA_GASPRICE = 1</code>.</p> </li> <li> <p><code>len(blobs)</code> is greater than <code>MAX_BLOBS_PER_BLOCK =  MAX_DATA_GAS_PER_BLOCK // DATA_GAS_PER_BLOB</code> in a single transaction within one block. There cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(wrapper.tx.message)</code> is greater that <code>MAX_BLOBS_PER_BLOCK</code> but with <code>len(blobs) = 1</code> for each transaction. As before there cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(blobs)</code> is zero within a transaction. Valid blob txs (type 3) must have at least one blob within it, obeying the following condition:</p> </li> <li> <p><code>len(tx.message.blob_versioned_hashes) &gt; 0</code></p> </li> <li> <p>Blob transaction type 3 is used in a pre-Cancun fork. This transcation type can only be used in a post-Cancun fork.</p> </li> </ul>"},{"location":"tutorials/blockchain/","title":"Blockchain Tests","text":"<p>This tutorial teaches you to create a blockchain execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will process given blocks and arrive at a defined post-state.</p>"},{"location":"tutorials/blockchain/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a blockchain test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> <li>Understand how to write an execution spec state transition test.</li> </ul>"},{"location":"tutorials/blockchain/#example-tests","title":"Example Tests","text":"<p>In this tutorial we will go over [test_block_number] in <code>block_example.py</code>(https://github.com/ethereum/execution-spec-tests/tree/main/fillers/example/block_example.py#L19).</p> <p>It is assumed you have already gone through the state transition test tutorial. Only new concepts will be discussed.</p>"},{"location":"tutorials/blockchain/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is defined that is called by each transaction in the test. It stores a pointer to storage at <code>storage[0]</code>. When it is called storage cell <code>0</code> gets the current block number, and the pointer is incremented to the next value.</p> <pre><code>contract_addr: Account(\n    balance=1000000000000000000000,\n    code=Yul(\n        \"\"\"\n        {\n            let next_slot := sload(0)\n            sstore(next_slot, number())\n            sstore(0, add(next_slot, 1))\n        }\n        \"\"\"\n    ),\n    storage={\n        0x00: 0x01,\n    },\n),\n</code></pre>"},{"location":"tutorials/blockchain/#transaction-generator","title":"Transaction Generator","text":"<p>The transactions used in this test are nearly identical. Their only different is the <code>nonce</code> value which needs to be incremented. </p> <pre><code>def tx_generator():\n    nonce = 0  # Initial value\n    while True:\n        tx = Transaction(\n            ty=0x0,\n            chain_id=0x0,\n            nonce=nonce,\n            to=contractAddr,\n            gas_limit=500000,\n            gas_price=10,\n        )\n        nonce = nonce + 1\n        yield tx\n\ntx_generator = tx_generator()\n</code></pre> <p>This looks like an infinite loop but it isn't because this is a generator function. When generator encounters the <code>yield</code> keyword it returns the value and stops execution, keeping a copy of all the local variables, until it is called again. Hence infinite loops inside a generator are not a problem as long as they include <code>yield</code>. This code section is responsible for creating the <code>Transaction</code> object and incrementing the <code>nonce</code>.</p> <p>Every time the function <code>tx_generator()</code> is called, it returns a new generator with a <code>nonce</code> of zero. To increment the <code>nonce</code> we need to use the same generator. We assign this generator to <code>tx_generator</code>.</p>"},{"location":"tutorials/blockchain/#blocks","title":"Blocks","text":"<p>Each integer in the <code>tx_per_block</code> array is the number of transactions in a block. The genesis block is block 0 (no transactions). It follows that we have 2 transactions in block 1, 0 in block two, 4 in block 3, ..., and 50 in block 9.</p> <pre><code>tx_per_block = [2, 0, 4, 8, 0, 0, 20, 1, 50]\n</code></pre> <p>The code section that creates the blocks is a bit complex in this test. For some simpler definitions of Block creation you can browse tests within <code>withdrawals.py</code>.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list(map(lambda x: next(tx_generator), range(len)))\n    ),\n    tx_per_block,\n)\n</code></pre> <p>We use <code>lambda</code> notation to specify short functions. In this case, the function doesn't actually care about its input, it just returns the next transaction from the generator.</p> <pre><code>lambda x: next(tx_generator)\n</code></pre> <p>Python uses <code>range(n)</code> to create a list of numbers from <code>0</code> to <code>n-1</code>. Among other things, it's a simple way to create a list of <code>n</code> values.</p> <pre><code>range(len)\n</code></pre> <p>The <code>map</code> function runs the function (the first parameter) on every element of the list (the second parameter). Putting together what we know, it means that it runs <code>next(tx_generator)</code> <code>len</code> times, giving us <code>len</code> transactions. We then use <code>list</code> to turn the transactions into a list that we can provide as the <code>txs</code> parameter to the <code>Block</code> constructor.</p> <pre><code>list(map(lambda x: next(tx_generator), range(len)))\n</code></pre> <p>The outer <code>lambda</code> function takes an integer, <code>len</code>, and creates a <code>Block</code> object with <code>len</code> transactions. This function is then run on every value of <code>tx_per_block</code> to generate the blocks.</p> <pre><code>blocks = map(\n    lambda len: Block(\n        txs=list of len transactions\n    ),\n    tx_per_block,\n)\n</code></pre> <p>For example, if we had <code>tx_per_block = [0,2,4]</code>, we'd get this result:</p> <pre><code>blocks = [\n    Blocks(txs=[]),\n    Blocks(txs=[next(tx_generator), next(tx_generator)]),\n    Blocks(txs=[next(tx_generator), next(tx_generator), next(tx_generator), next(tx_generator)])        \n]\n</code></pre>"},{"location":"tutorials/blockchain/#post-state","title":"Post State","text":"<p>Recall that storage slot 0 retains the value of the next slot that the block number is written into. It starts at one and is incremented after each transaction. Hence it's the total number of transactions plus 1.</p> <pre><code>storage = {0: sum(tx_per_block) + 1}\n</code></pre> <p>For every block and transaction within the block, we write the block number and increment the next slot number in storage slot 0. As Python lists are 0 indexed, we must increment the block number by 1.</p> <pre><code>next_slot = 1\nfor blocknum in range(len(tx_per_block)):\n    for _ in range(tx_per_block[blocknum]):\n        storage[next_slot] = blocknum + 1\n        next_slot = next_slot + 1\n</code></pre> <p>Now that the expeced storage values are calculated, the post state can be defined and yielded within the <code>BlockchainTest</code>, synonymous to the state test example.</p> <pre><code>post = {contract_addr: Account(storage=storage)}\n\nyield BlockchainTest(\n    genesis_environment=env,\n    pre=pre,\n    blocks=blocks,\n    post=post,\n)\n</code></pre> <p>Note that because of the <code>yield</code> we could have multiple tests under the same name.</p>"},{"location":"tutorials/blockchain/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to write blockchain tests.</p>"},{"location":"tutorials/state_transition/","title":"State Transition Tests","text":"<p>This tutorial teaches you to create a state transition execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will reach a specified post-state after executing a set of specific transactions.</p>"},{"location":"tutorials/state_transition/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a static state transition test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> </ul>"},{"location":"tutorials/state_transition/#example-tests","title":"Example Tests","text":"<p>The most effective method of learning how to write tests is to study a couple of straightforward examples. In this tutorial we will go over the Yul and Bad Opcode state tests.</p>"},{"location":"tutorials/state_transition/#yul-test","title":"Yul Test","text":"<p>You can find the source code for the Yul test here. It is the spec test equivalent of this static test. </p> <p>Lets examine each section.</p> <pre><code>\"\"\"\nTest Yul Source Code Examples\n\"\"\"\n</code></pre> <p>In Python, multi-line strings are denoted using <code>\"\"\"</code>. As a convention, a file's purpose is often described in the opening string of the file.</p> <pre><code>from ethereum_test_tools import (\n    Account,\n    Environment,\n    StateTest,\n    TestAddress,\n    Transaction,\n    Yul,\n    test_from,\n)\n</code></pre> <p>Next the following constants, types and helper functions are imported from <code>ethereum_test_tools</code> and <code>ethereum_test_forks</code>. We will go over these as we come across them.</p> <pre><code>@test_from(Berlin)\n</code></pre> <p>In Python this kind of definition is called a decorator. It modifies the action of the function after it. In this case, it specifies to the test running code that the following function is only a valid test for the Berlin fork and the forks after it.</p> <pre><code>def test_yul(fork):\n    \"\"\"\n    Test YUL compiled bytecode.\n    \"\"\"\n</code></pre> <p>This is the format of a Python function. It starts with <code>def &lt;function name&gt;(&lt;parameters&gt;):</code>, and then has indented code for the function. The function definition ends when there is a line that is no longer indented. As with files, by convention functions start with a string that explains what the function does.</p> <p>Note</p> <p>Recall from quick start that to solely run the test case <code>test_yul</code> we ommit <code>test_</code> from the test filler: <code>tf --test-case yul --output fixtures</code>.</p> <pre><code>    env = Environment()\n</code></pre> <p>This line specifies that <code>env</code> is an <code>Environment</code> object, and that we just use the default parameters. If necessary we can modify the environment to have different block gas limits, block numbers, etc. In most tests the defaults are good enough.</p> <p>For more information, see the static test documentation.</p>"},{"location":"tutorials/state_transition/#pre-state","title":"Pre State","text":"<pre><code>    pre = {\n</code></pre> <p>Here we define the pre-state section, the one that tells us what is on the \"blockchain\" before the test. It is a dictionary, which is the Python term for an associative array.</p> <pre><code>        \"0x1000000000000000000000000000000000000000\": Account(\n</code></pre> <p>The keys of the dictionary are addresses (as strings), and the values are <code>Account</code> objects. You can read more about address fields in the static test documentation. </p> <pre><code>            balance=0x0BA1A9CE0BA1A9CE,\n</code></pre> <p>This field is the balance: the amount of Wei that the account has. It usually doesn't matter what its value is in the case of state test contracts.</p> <pre><code>            code=Yul(\n</code></pre> <p>Here we define the Yul code for the contract. It is defined as a multi-line string and starts and ends with curly braces (<code>{ &lt;yul&gt; }</code>).</p> <p>When running the test filler <code>tf</code> the solidity compiler <code>solc</code> will automatically translate the Yul to EVM opcode at runtime. </p> <p>Note</p> <p>Currently Yul and direct EVM opcode are supported in execution spec tests. LLL and Solidity may be supported in the future.</p> <pre><code>                \"\"\"\n                {\n                    function f(a, b) -&gt; c {\n                        c := add(a, b)\n                    }\n                    sstore(0, f(1, 2))\n                    return(0, 32)\n                }\n                \"\"\"\n            ),\n        ),\n</code></pre> <p>Within this example test Yul code we have a function definition, and inside it we are using the Yul <code>add</code> instruction. When compiled with <code>solc</code> it translates the instruction directly to the<code>ADD</code> opcode. For further Yul instructions see here. Notice that function is utilised with the Yul <code>sstore</code> instruction, which stores the result of <code>add(1, 2)</code> to the storage address <code>0x00</code>.</p> <p>Generally for execution spec tests the <code>sstore</code> instruction acts as a high-level assertion method to check pre to post-state changes. The test filler achieves this by verifying that the correct value is held within post-state storage, hence we can validate that the Yul code has run successfully.</p> <pre><code>        TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n    }\n</code></pre> <p><code>TestAddress</code> is an address for which the test filler has the private key. This means that the test runner can issue a transaction as that contract. Of course, this address also needs a balance to be able to issue transactions.</p>"},{"location":"tutorials/state_transition/#transactions","title":"Transactions","text":"<pre><code>    tx = Transaction(\n        ty=0x0,\n        chain_id=0x0,\n        nonce=0,\n        to=\"0x1000000000000000000000000000000000000000\",\n        gas_limit=500000,\n        gas_price=10,\n        protected=False,\n    )\n</code></pre> <p>With the pre-state specified, we can add a description for the <code>Transaction</code>. For more information, see the static test documentation</p>"},{"location":"tutorials/state_transition/#post-state","title":"Post State","text":"<pre><code>    post = {\n        \"0x1000000000000000000000000000000000000000\": Account(\n            storage={\n                0x00: 0x03,\n            },\n        ),\n    }\n</code></pre> <p>This is the post-state which is equivalent to <code>expect</code> in static tests, but without the indexes. It is similar to the pre-state, except that we do not need to specify everything, only those accounts and fields we wish to test.</p> <p>In this case, we look at the storage of the contract we called and add to it what we expect to see. In this example storage cell <code>0x00</code> should be <code>0x03</code> as in the pre-state we essentially stored the result of the Yul instruction <code>add(1, 2)</code>.</p>"},{"location":"tutorials/state_transition/#state-test","title":"State Test","text":"<pre><code>    yield StateTest(env=env, pre=pre, post=post, txs=[tx])\n</code></pre> <p>This line produces the actual state test using the <code>ethereum_test_tools</code>  spec package, when running the test filler. It is <code>yield</code>, rather than <code>return</code>, because a single function can return multiple test cases as you'll see in the next example.</p>"},{"location":"tutorials/state_transition/#bad-opcode-test","title":"Bad Opcode Test","text":"<p>The source code for this test is here. We will only go over the parts that are new.</p> <p>We use Python string templates, so we need to import that library.</p> <pre><code>from string import Template\n</code></pre> <p>In this test we need a couple of addresses, so we create them here. Python lets us specify <code>&lt;string&gt;*&lt;number&gt;</code> when we need a string repeated multiple times, which makes for more readable code than <code>0x00...000C0DE</code>.</p> <pre><code>    code_addr = \"0x\" + \"0\"*(40-4) + \"C0DE\"\n    goat_addr = \"0x\" + \"0\"*(40-4) + \"60A7\"\n</code></pre> <p>We create <code>env</code> and <code>tx</code> first because they are constant. This function will <code>yield</code> multiple tests, but always with the same <code>env</code> and <code>tx</code> values.</p> <pre><code>    env = Environment()\n\n    tx = Transaction(\n           .\n           .\n           .\n        )\n</code></pre> <p>Here we create two post states. We will use whichever one is appropriate to the test we create.</p> <pre><code>    post_valid = {\n       code_addr: Account(\n         storage={0x00: 1},\n       ),\n    }\n\n    post_invalid = {\n       code_addr: Account(\n         storage={0x00: 0},\n       ),\n    }\n</code></pre> <p>Here we define a function (<code>opc_valid</code>) inside another function. Python supports this, and it has two advantages:</p> <ul> <li>Avoid namespace pollution by restricting the function to where it is needed.</li> <li>Functions defined inside other functions can use the parameters and local variables of those functions.   In this case, we need to use <code>fork</code>.</li> </ul> <pre><code>    # Check if an Opcode is valid\n    def opc_valid(opc):\n        \"\"\"\n        Return whether opc will be evaluated as valid by the test or not.\n        Note that some opcodes are evaluated as invalid because the way they act\n        \"\"\"\n</code></pre> <p>This is the syntax for Python comments, <code># &lt;rest of the line&gt;</code>. </p> <pre><code>        # PUSH0 is only valid Shanghai and later\n</code></pre> <p>Opcode 0x5F (<code>PUSH0</code>) is only valid starting with the Shangai fork. We don't know what will be the fork names after Shanghai, so it is easiest to specify that prior to Shanghai it is invalid. We don't need to worry about forks prior to London because the decorator for this test says it is only valid from London.</p> <pre><code>        if fork in {\"london\", \"merge\"} and opc==0x5F:\n</code></pre> <p>Python has a set data structure. We use this structure when the order of the values are irrelevant, and we just want to be able to check if something is a member or not.</p> <p>Note that <code>if</code> statements are also followed by a colon (<code>:</code>) and the code inside them indented. That is the general Python syntax.</p> <pre><code>            return False\n</code></pre> <p>Boolean values in Python are either <code>True</code> or <code>False</code>.</p> <p>This test works by running an opcode and then does a <code>SSTORE</code>. Opcodes that terminate execution, such as <code>STOP</code> and <code>RETURN</code> also cause the <code>SSTORE</code> not to happen, so they must be treated as invalid. The same is true for <code>JUMP</code>.</p> <pre><code>        # Valid opcodes, but they are terminal, and so cause\n        # the SSTORE not to happen\n        if opc in {0x00, 0xF3, 0xFD, 0xFF}:\n            return False\n\n\n        # Jumps. If you jump to a random location, you skip the SSTORE\n        if opc in {0x56}:\n            return False\n</code></pre> <p>Next we return <code>True</code> for supported opcodes.</p> <pre><code>        # Opcodes that aren't part of a range\n        # 0x20 - SHA3\n        # 0xFA - STATICCALL\n        if opc in {0x20, 0xFA}:\n            return True\n\n</code></pre> <p>In Python, as in math, you can use <code>a &lt; b &lt; c</code> for <code>a &lt; b and b &lt; c</code>.</p> <pre><code>        # Arithmetic opcodes\n        if 0x01 &lt;= opc &lt;= 0x0b:\n            return True\n\n        .\n        .\n        .\n</code></pre> <p>The last part the function returns <code>False</code>. If we got here, then this is not a valid opcode.</p> <pre><code>        return False\n        # End of opc_valid\n</code></pre> <p>As this is the end of the function, the next code line is unindented (compared to the function definition code).</p> <p>This is a <code>for</code> loop. For loops iterate over a sequnce, and the <code>range</code> function, in this case, gives us the range 0..255. As with functions and <code>if</code> statements, the <code>for</code> loop has a colon and includes the indented code.</p> <pre><code>    # For every possible opcode\n    for opc in range(256):\n</code></pre> <p>We have two post states.  One, <code>post_valid</code>, has the value of <code>1</code> in storage location <code>0</code>. The other, <code>post_invalid</code> has the value of <code>0</code> in storage location <code>0</code>. But <code>SELFDESTRUCT</code> destroys the contract so there is no longer an account at that address.  Neither is valid, so we just skip that test case.</p> <pre><code>        # We can't check SELFDESTRUCT using this technique\n        if opc in {0xFF}:\n           continue\n</code></pre> <p>We need the opcode in hexadecimal.  The function <code>hex</code> gives us the hexadecimal number in hex. However, it also gives us a <code>0x</code> prefix, which we don't want, so we use a slice to remove the first two characters.</p> <pre><code>        opc_hex = hex(opc)[2:]\n</code></pre> <p>We need <code>opc_hex</code> to be two characters. If the length is only one, prepend a zero.</p> <pre><code>        if len(opc_hex) == 1:\n          opc_hex = \"0\" + opc_hex\n</code></pre> <p>This is a <code>Template</code> string. This means we'll be able to substitute template variables (<code>${&lt;var name&gt;}</code>) with values to produce the actual code.</p> <pre><code>        yul_code = Template(\"\"\"\n        {\n</code></pre> <p>We start with a call <code>0x00...0060A7</code> (a.k.a. <code>goat_addr</code>) so we'll have some return data. Otherwise, <code>RETURNDATACOPY</code> will fail and appear like it is not an opcode.</p> <pre><code>           pop(call(gas(), 0x60A7, 0, 0, 0, 0, 0))\n\n           // fails on opcodes with &gt;20 inputs\n           // (currently dup16, at 17 inputs, is the\n           // one that goes deepest)\n           //\n           // Follow with 32 NOPs (0x5B) to handle PUSH, which has an immediate\n           // operand\n</code></pre> <p>Opcodes can have two types of operands:</p> <ul> <li>Immediate operands, which are part of the bytecode.   For example, <code>6001</code> is <code>PUSH1</code> with the value <code>0x01</code>.</li> <li>Implied operands (a.k.a. stack operands), which come from the stack.</li> </ul> <p>This <code>verbatim</code> code provides both operand types. The code, <code>${opcode}${nop32}</code> is the opcode we are testing, followed by 32 copies of 0x5B. When <code>0x5B</code> is not used as an operand, it is <code>JUMPDEST</code> and does nothing.</p> <pre><code>           verbatim_20i_0o(hex\"${opcode}${nop32}\",\n</code></pre> <p>The opcode string is followed by the input parameters (in this case, twenty of them). These can be Yul expressions, but for the sake of simplicity here we just use constant values.</p> <pre><code>              0x00, 0x00, 0x00, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n              0xFF, 0xFF, 0xFF, 0xFF, 0xFF)\n</code></pre> <p>If the opcode terminates the smart contract execution (as invalid opcodes do), we don't get here. If we do get here, write to storage cell <code>0x00</code> to record that fact.</p> <p>Note the syntax <code>let &lt;var&gt; := &lt;value&gt;</code>. This is how you specify variables in Yul.</p> <pre><code>           // We only get here is the opcode is legit (and it doesn't terminate\n           // execution like STOP and RETURN)\n           let zero := 0\n           let one := 1\n           sstore(zero, one)\n        }\n</code></pre> <p>Replace <code>${opcode}</code> with the one byte hex code, and <code>${nop32}</code> with 32 copies of <code>5b</code> (for NOP).</p> <pre><code>        \"\"\").substitute(opcode=opc_hex, nop32=\"5B\"*32)\n        pre = {\n           TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n           codeAddr: Account(\n        balance=0,\n        nonce=1,\n        code=Yul(yul_code)\n           ),\n</code></pre> <p>This is the account for <code>0x00..0060A7</code>.  It just returns data (all zeros).</p> <pre><code>           goat_addr: Account(\n                balance=0,\n                nonce=1,\n                code=Yul(\"{ return(0, 0x100) }\"),\n           )\n        }\n</code></pre> <p>Every time the <code>for</code> loop gets here, it <code>yields</code> a separate test.  Over the entire for loop, it yields 255 different tests.</p> <pre><code>    yield StateTest(\n        env=env, \n        pre=pre, \n        txs=[tx],\n        post=(post_valid if opc_valid(opc) else post_invalid),\n    )\n</code></pre> <p>The Python format for the ternary operation is a bit different from C-like languages. In C like languages the syntax is <code>&lt;condition&gt; ? &lt;yes value&gt; : &lt;no value&gt;</code>. In Python it is <code>&lt;yes value&gt; if &lt;condition&gt; else &lt;no value&gt;</code>. </p>"},{"location":"tutorials/state_transition/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to state transition tests within a single block.</p>"}]}