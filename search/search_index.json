{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Execution Spec Tests","text":""},{"location":"#overview","title":"Overview","text":"<p>ethereum/execution-spec-tests is both a collection of test cases and a framework to generate tests for Ethereum execution clients. The test cases, also known as test fillers, are implemented in Python. The framework collects and executes the test cases in order to generate test fixtures (JSON) which can be consumed by any execution client to verify their implementation of ethereum/execution-specs. Currently, the fixtures, which define state transition and block tests, are generated by the framework using the <code>t8n</code> and <code>b11r</code> commands from the ethereum/go-ethereum <code>evm</code> command-line tool.</p> <pre><code>---\ntitle: Test Fixture Generation with execution-spec-tests\n---\nflowchart LR\n  style C stroke:#333,stroke-width:2px\n  style D stroke:#333,stroke-width:2px\n  style F stroke:#F9A825,stroke-width:2px\n  style G stroke:#F9A825,stroke-width:2px\n\n  subgraph ethereum/go-ethereum\n    C[&lt;code&gt;evm&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/solidity\n    D[&lt;code&gt;solc&lt;/code&gt;\\nexternal executable]\n  end\n\n  subgraph ethereum/execution-spec-tests\n    A(&lt;code&gt;./fillers/**/*.py&lt;/code&gt;\\nPython Test Cases)\n    B([&lt;code&gt;$ pytest ./fillers/&lt;/code&gt;\\nPython Framework])\n  end\n\n  subgraph Test Fixture Consumers\n    subgraph ethereum/hive\n      F([&lt;code&gt;$ hive ...&lt;/code&gt;\\nGo Test Framework])\n    end\n    G([Client executables])\n  end\n\n  C &lt;-.-&gt; B  \n  A --&gt; B\n  D &lt;-.-&gt; B\n  B --&gt;|output| E(&lt;code&gt;./out/**/*.json&lt;/code&gt;\\nJSON Test Fixtures)\n  E --&gt;|input| F\n  E --&gt;|input| G</code></pre> <p>The generated test fixtures can be used:</p> <ol> <li>Directly by client teams' test frameworks, and,</li> <li>In the integration tests executed in the ethereum/hive framework.</li> </ol>"},{"location":"#relationship-to-ethereumtests","title":"Relationship to ethereum/tests","text":"<p>This collection of tests is relatively new (test case development started Q4, 2022) and mainly targets recent and upcoming Ethereum specification changes. It does not replace, but rather complements the existing tests in ethereum/tests.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The motivation to implement test cases in ethereum/execution-spec-tests is:</p> <ol> <li>To implement test cases as code and ensure that changes, due to spec changes, for example, can be easily made. Moreover, changes are easily understandable and available in version control.</li> <li>To avoid the 2-step approach often used in ethereum/tests:<ol> <li>Code (often unavailable) -&gt; Test case (YAML).</li> <li>Test case (YAML) -&gt; Fixtures (JSON).</li> </ol> </li> </ol> <p>Contributing</p> <p>Contributions via PR are welcome!</p>"},{"location":"dev/dev/","title":"Developer Documentation","text":"<p>This documentation is aimed at maintainers of <code>execution-spec-tests</code> but may be helpful during test case/filler development:</p> <ul> <li>generating documentation.</li> </ul>"},{"location":"dev/docs/","title":"Documentation","text":"<p><code>execution-spec-tests</code> documentation is generated via <code>mkdocs</code> and hosted remotely on readthedocs.io.</p>"},{"location":"dev/docs/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install -e .[docs]\n</code></pre>"},{"location":"dev/docs/#build-the-documentation","title":"Build the Documentation","text":"<p>One time build: <pre><code>mkdocs build\n</code></pre></p>"},{"location":"dev/docs/#local-deployment-and-test","title":"Local Deployment and Test","text":"<p>This runs continually and re-generates the documentation upon changes in the <code>./docs/</code> sub-director and deploys the site locally (127.0.0.1:8000, by default): <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"dev/docs/#test-remote-deployment","title":"Test Remote Deployment","text":"<p>This can be used to generate and deploy a local version of the documentation remotely on Github pages in order to share a preview with other developers. Note, as the documentation is generated locally, even changes that have not been pushed will be deployed: <pre><code>mkdocs gh-deploy\n</code></pre> It will be deployed to the Github pages of the repo's username (branch is ignored), e.g., https://danceratopz.github.io/execution-spec-tests.</p>"},{"location":"dev/docs/#production-deployment","title":"Production Deployment","text":"<p>Read the docs should pick up a push to the <code>main</code> branch and deploy an up-to-date version of the documentation. Active maintainers who wish to manage the documentation on readthedocs.org require a readthedocs account and be given permission (please ask one of the active maintainers).</p>"},{"location":"fillers/withdrawals/","title":"Withdrawals","text":"<p>Generate fixtures for this module with:</p> <pre><code>    pytest -v fillers/withdrawals/withdrawals.py\n</code></pre> <p>Test withdrawal system-level operation.</p>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress","title":"<code>TestMultipleWithdrawalsSameAddress</code>","text":"<p>Test that multiple withdrawals can be sent to the same address in:</p> <ol> <li> <p>A single block.</p> </li> <li> <p>Multiple blocks.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\"test_case\", [\"single_block\", \"multiple_blocks\"])\nclass TestMultipleWithdrawalsSameAddress:\n\"\"\"\n    Test that multiple withdrawals can be sent to the same address in:\n    1. A single block.\n    2. Multiple blocks.\n    \"\"\"\nADDRESSES = [\nto_address(0x0),  # Zero address\nto_address(0x1),  # Pre-compiles\nto_address(0x2),\nto_address(0x3),\nto_address(0x4),\nto_address(0x5),\nto_address(0x6),\nto_address(0x7),\nto_address(0x8),\nto_address(0x9),\nto_address(2**160 - 1),\n]\n@pytest.fixture\ndef blocks(self, test_case: str):  # noqa: D102\nif test_case == \"single_block\":\n# Many repeating withdrawals of the same accounts in the same\n# block.\nreturn [\nBlock(\nwithdrawals=[\nWithdrawal(\nindex=i,\nvalidator=0,\naddress=self.ADDRESSES[i % len(self.ADDRESSES)],\namount=1,\n)\nfor i in range(len(self.ADDRESSES) * 16)\n],\n),\n]\nif test_case == \"multiple_blocks\":\n# Similar test but now use multiple blocks each with multiple\n# withdrawals to the same withdrawal address.\nreturn [\nBlock(\nwithdrawals=[\nWithdrawal(\nindex=i * 16 + j,\nvalidator=i,\naddress=self.ADDRESSES[i],\namount=1,\n)\nfor j in range(16)\n],\n)\nfor i in range(len(self.ADDRESSES))\n]\nraise Exception(\"Invalid test case.\")\ndef test_multiple_withdrawals_same_address(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ntest_case: str,\nblocks: List[Block],\n):\n\"\"\"\n        Test Withdrawals can be done to the same address multiple times in\n        the same block.\n        \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\n}\nfor addr in self.ADDRESSES:\npre[addr] = Account(\ncode=SET_STORAGE,\n)\n# Expected post is the same for both test cases.\npost = {}\nfor addr in self.ADDRESSES:\npost[addr] = Account(\nbalance=16 * ONE_GWEI,\nstorage={},\n)\nblockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestMultipleWithdrawalsSameAddress.test_multiple_withdrawals_same_address","title":"<code>test_multiple_withdrawals_same_address(blockchain_test, fork, test_case, blocks)</code>","text":"<p>Test Withdrawals can be done to the same address multiple times in the same block.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_multiple_withdrawals_same_address(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ntest_case: str,\nblocks: List[Block],\n):\n\"\"\"\n    Test Withdrawals can be done to the same address multiple times in\n    the same block.\n    \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\n}\nfor addr in self.ADDRESSES:\npre[addr] = Account(\ncode=SET_STORAGE,\n)\n# Expected post is the same for both test cases.\npost = {}\nfor addr in self.ADDRESSES:\npost[addr] = Account(\nbalance=16 * ONE_GWEI,\nstorage={},\n)\nblockchain_test(pre=pre, post=post, blocks=blocks, tag=test_case)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx","title":"<code>TestUseValueInTx</code>","text":"<p>Test that the value from a withdrawal can be used in a transaction:</p> <ol> <li> <p><code>tx_in_withdrawals_block</code>:   Test that the withdrawal value can not be used by a transaction in   the same block as the withdrawal.</p> </li> <li> <p><code>tx_after_withdrawals_block</code>:   Test that the withdrawal value can be used by a transaction in the   subsequent block.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n\"test_case\",\n[\"tx_in_withdrawals_block\", \"tx_after_withdrawals_block\"],\nids=lambda x: x,\n)\nclass TestUseValueInTx:\n\"\"\"\n    Test that the value from a withdrawal can be used in a transaction:\n    1. `tx_in_withdrawals_block`:\n      Test that the withdrawal value can not be used by a transaction in\n      the same block as the withdrawal.\n    2. `tx_after_withdrawals_block`:\n      Test that the withdrawal value can be used by a transaction in the\n      subsequent block.\n    \"\"\"\n@pytest.fixture\ndef tx(self):  # noqa: D102\n# Transaction sent from the `TestAddress`, which has 0 balance at start\nreturn Transaction(\nnonce=0,\ngas_price=ONE_GWEI,\ngas_limit=21000,\nto=to_address(0x100),\ndata=\"0x\",\n)\n@pytest.fixture\ndef withdrawal(self, tx: Transaction):  # noqa: D102\nreturn Withdrawal(\nindex=0,\nvalidator=0,\naddress=TestAddress,\namount=tx.gas_limit + 1,\n)\n@pytest.fixture\ndef blocks(  # noqa: D102\nself, tx: Transaction, withdrawal: Withdrawal, test_case\n):\nif test_case == \"tx_in_withdrawals_block\":\nreturn [\nBlock(\ntxs=[\ntx.with_error(\n\"intrinsic gas too low: have 0, want 21000\"\n)\n],\nwithdrawals=[\nwithdrawal,\n],\nexception=\"Transaction without funds\",\n)\n]\nif test_case == \"tx_after_withdrawals_block\":\nreturn [\nBlock(\ntxs=[],\nwithdrawals=[\nwithdrawal,\n],\n),\nBlock(\ntxs=[tx],\nwithdrawals=[],\n),\n]\nraise Exception(\"Invalid test case.\")\n@pytest.fixture\ndef post(self, test_case: str) -&gt; Dict:  # noqa: D102\nif test_case == \"tx_in_withdrawals_block\":\nreturn {}\nif test_case == \"tx_after_withdrawals_block\":\nreturn {TestAddress: Account(balance=ONE_GWEI)}\nraise Exception(\"Invalid test case.\")\ndef test_use_value_in_tx(\nself,\nblockchain_test: BlockchainTestFiller,\npost: dict,\nblocks: List[Block],\n):\n\"\"\"\n        Test sending withdrawal value in a transaction.\n        \"\"\"\npre = {TestAddress: Account(balance=0)}\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestUseValueInTx.test_use_value_in_tx","title":"<code>test_use_value_in_tx(blockchain_test, post, blocks)</code>","text":"<p>Test sending withdrawal value in a transaction.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_tx(\nself,\nblockchain_test: BlockchainTestFiller,\npost: dict,\nblocks: List[Block],\n):\n\"\"\"\n    Test sending withdrawal value in a transaction.\n    \"\"\"\npre = {TestAddress: Account(balance=0)}\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount","title":"<code>TestZeroAmount</code>","text":"<p>Test withdrawals with zero amount for the following cases, all withdrawals are included in one block:</p> <ol> <li> <p>Two withdrawals of zero amount to two different addresses; one to an    untouched account, one to an account with a balance.</p> </li> <li> <p>As 1., but with an additional withdrawal with positive value.</p> </li> <li> <p>As 2., but with an additional withdrawal containing the maximum value    possible.</p> </li> <li> <p>As 3., but with order of withdrawals in the block reversed.</p> </li> </ol> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n\"test_case\",\n[case for case in ZeroAmountTestCases],\nids=[case.value for case in ZeroAmountTestCases],\n)\nclass TestZeroAmount:\n\"\"\"\n    Test withdrawals with zero amount for the following cases, all withdrawals\n    are included in one block:\n    1. Two withdrawals of zero amount to two different addresses; one to an\n       untouched account, one to an account with a balance.\n    2. As 1., but with an additional withdrawal with positive value.\n    3. As 2., but with an additional withdrawal containing the maximum value\n       possible.\n    4. As 3., but with order of withdrawals in the block reversed.\n    \"\"\"\n@pytest.fixture(scope=\"function\")\ndef test_case_parameters(self, test_case):  # noqa: D102\nwithdrawals = [\n# No value, untouched account\nWithdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x100),\namount=0,\n),\n# No value, touched account\nWithdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x200),\namount=0,\n),\n# Withdrawal with value\nWithdrawal(\nindex=1,\nvalidator=0,\naddress=to_address(0x300),\namount=1,\n),\n# Withdrawal with maximum amount\nWithdrawal(\nindex=2,\nvalidator=0,\naddress=to_address(0x400),\namount=2**64 - 1,\n),\n]\npost = {\nto_address(0x100): Account.NONEXISTENT,\nto_address(0x200): Account(code=\"0x00\", balance=0),\nto_address(0x300): Account(balance=ONE_GWEI),\nto_address(0x400): Account(balance=(2**64 - 1) * ONE_GWEI),\n}\nif test_case == ZeroAmountTestCases.TWO_ZERO:\nreturn {\n\"withdrawals\": withdrawals[0:2],\n\"post\": {\naccount: post[account]\nfor account in post\nif account in [to_address(0x100), to_address(0x200)]\n},\n}\nif test_case == ZeroAmountTestCases.THREE_ONE_WITH_VALUE:\nreturn {\n\"withdrawals\": withdrawals[0:3],\n\"post\": {\naccount: post[account]\nfor account in post\nif account\nin [\nto_address(0x100),\nto_address(0x200),\nto_address(0x300),\n]\n},\n}\nif test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX:\nreturn {\"withdrawals\": withdrawals, \"post\": post}\nif test_case == ZeroAmountTestCases.FOUR_ONE_WITH_MAX_REVERSED:\nwithdrawals.reverse()\nset_withdrawal_index(withdrawals)\nreturn {\"withdrawals\": withdrawals, \"post\": post}\nraise Exception(\"Unknown test case.\")\ndef test_zero_amount(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ntest_case: ZeroAmountTestCases,\ntest_case_parameters: Dict,\n):\n\"\"\"\n        Test Withdrawals where one of the withdrawal has a zero amount.\n        \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x200): Account(\ncode=\"0x00\",\nbalance=0,\n),\n}\nblockchain_test(\npre=pre,\npost=test_case_parameters[\"post\"],\nblocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\ntag=test_case.value,\n)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.TestZeroAmount.test_zero_amount","title":"<code>test_zero_amount(blockchain_test, fork, test_case, test_case_parameters)</code>","text":"<p>Test Withdrawals where one of the withdrawal has a zero amount.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_zero_amount(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ntest_case: ZeroAmountTestCases,\ntest_case_parameters: Dict,\n):\n\"\"\"\n    Test Withdrawals where one of the withdrawal has a zero amount.\n    \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x200): Account(\ncode=\"0x00\",\nbalance=0,\n),\n}\nblockchain_test(\npre=pre,\npost=test_case_parameters[\"post\"],\nblocks=[Block(withdrawals=test_case_parameters[\"withdrawals\"])],\ntag=test_case.value,\n)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.set_withdrawal_index","title":"<code>set_withdrawal_index(withdrawals, start_index=0)</code>","text":"<p>Automatically set the index of each withdrawal in a list in sequential order.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def set_withdrawal_index(\nwithdrawals: List[Withdrawal], start_index: int = 0\n) -&gt; None:\n\"\"\"\n    Automatically set the index of each withdrawal in a list in sequential\n    order.\n    \"\"\"\nfor i, w in enumerate(withdrawals):\nw.index = start_index + i\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_balance_within_block","title":"<code>test_balance_within_block(blockchain_test, fork)</code>","text":"<p>Test Withdrawal balance increase within the same block, inside contract call.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_balance_within_block(\nblockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test Withdrawal balance increase within the same block,\n    inside contract call.\n    \"\"\"\nSAVE_BALANCE_ON_BLOCK_NUMBER = Op.SSTORE(\nOp.NUMBER,\nOp.BALANCE(Op.CALLDATALOAD(0)),\n)\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x100): Account(\ncode=SAVE_BALANCE_ON_BLOCK_NUMBER,\n),\nto_address(0x200): Account(\nbalance=ONE_GWEI,\n),\n}\nblocks = [\nBlock(\ntxs=[\nTransaction(\nnonce=0,\ngas_limit=100000,\nto=to_address(0x100),\ndata=to_hash(0x200),\n)\n],\nwithdrawals=[\nWithdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x200),\namount=1,\n)\n],\n),\nBlock(\ntxs=[\nTransaction(\nnonce=1,\ngas_limit=100000,\nto=to_address(0x100),\ndata=to_hash(0x200),\n)\n]\n),\n]\npost = {\nto_address(0x100): Account(\nstorage={\n1: ONE_GWEI,\n2: 2 * ONE_GWEI,\n}\n)\n}\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_large_amount","title":"<code>test_large_amount(blockchain_test, fork)</code>","text":"<p>Test Withdrawals that have a large gwei amount, so that (gwei * 1e9) could overflow uint64 but not uint256.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_large_amount(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals that have a large gwei amount, so that (gwei * 1e9)\n    could overflow uint64 but not uint256.\n    \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\n}\nwithdrawals: List[Withdrawal] = []\namounts: List[int] = [\n(2**35),\n(2**64) - 1,\n(2**63) + 1,\n(2**63),\n(2**63) - 1,\n]\npost = {}\nfor i, amount in enumerate(amounts):\naddr = to_address(0x100 * (i + 1))\nwithdrawals.append(\nWithdrawal(\nindex=i,\nvalidator=i,\naddress=addr,\namount=amount,\n)\n)\npost[addr] = Account(balance=(amount * ONE_GWEI))\nblocks = [\nBlock(\nwithdrawals=withdrawals,\n)\n]\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_many_withdrawals","title":"<code>test_many_withdrawals(blockchain_test, fork)</code>","text":"<p>Test Withdrawals with a count of N withdrawals in a single block where N is a high number not expected to be seen in mainnet.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_many_withdrawals(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals with a count of N withdrawals in a single block where\n    N is a high number not expected to be seen in mainnet.\n    \"\"\"\nN = 400\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\n}\nwithdrawals = []\npost = {}\nfor i in range(N):\naddr = to_address(0x100 * i)\namount = i * 1\npre[addr] = Account(\ncode=SET_STORAGE,\n)\nwithdrawals.append(\nWithdrawal(\nindex=i,\nvalidator=i,\naddress=addr,\namount=amount,\n)\n)\npost[addr] = Account(\ncode=SET_STORAGE,\nbalance=amount * ONE_GWEI,\nstorage={},\n)\nblocks = [\nBlock(\nwithdrawals=withdrawals,\n),\n]\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_newly_created_contract","title":"<code>test_newly_created_contract(blockchain_test, fork, include_value_in_tx, request)</code>","text":"<p>Test Withdrawing to a newly created contract.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>@pytest.mark.parametrize(\n\"include_value_in_tx\",\n[False, True],\nids=[\"without_tx_value\", \"with_tx_value\"],\n)\ndef test_newly_created_contract(\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ninclude_value_in_tx: bool,\nrequest,\n):\n\"\"\"\n    Test Withdrawing to a newly created contract.\n    \"\"\"\ncreated_contract = compute_create_address(TestAddress, 0)\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\n}\ninitcode = Yul(\n\"\"\"\n        {\n            return(0, 1)\n        }\n        \"\"\"\n)\ntx = Transaction(\n# Transaction sent from the `TestAddress`, that creates a\n# new contract.\nnonce=0,\ngas_price=10,\ngas_limit=1000000,\nto=None,\ndata=initcode,\n)\nwithdrawal = Withdrawal(\nindex=0,\nvalidator=0,\naddress=created_contract,\namount=1,\n)\nblock = Block(\ntxs=[tx],\nwithdrawals=[withdrawal],\n)\npost = {\ncreated_contract: Account(\ncode=\"0x00\",\nbalance=ONE_GWEI,\n),\n}\nif include_value_in_tx:\ntx.value = ONE_GWEI\npost[created_contract].balance = 2 * ONE_GWEI\ntag = request.node.callspec.id.split(\"-\")[0]  # remove fork; brittle\nblockchain_test(pre=pre, post=post, blocks=[block], tag=tag)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_no_evm_execution","title":"<code>test_no_evm_execution(blockchain_test, fork)</code>","text":"<p>Test Withdrawals don't trigger EVM execution.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_no_evm_execution(blockchain_test: BlockchainTestFiller, fork: Fork):\n\"\"\"\n    Test Withdrawals don't trigger EVM execution.\n    \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x100): Account(\ncode=SET_STORAGE,\n),\nto_address(0x200): Account(\ncode=SET_STORAGE,\n),\nto_address(0x300): Account(\ncode=SET_STORAGE,\n),\nto_address(0x400): Account(\ncode=SET_STORAGE,\n),\n}\nblocks = [\nBlock(\ntxs=[\nTransaction(\nnonce=0,\ngas_limit=100000,\nto=to_address(0x300),\n),\nTransaction(\nnonce=1,\ngas_limit=100000,\nto=to_address(0x400),\n),\n],\nwithdrawals=[\nWithdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x100),\namount=1,\n),\nWithdrawal(\nindex=1,\nvalidator=1,\naddress=to_address(0x200),\namount=1,\n),\n],\n),\nBlock(\ntxs=[\nTransaction(\nnonce=2,\ngas_limit=100000,\nto=to_address(0x100),\n),\nTransaction(\nnonce=3,\ngas_limit=100000,\nto=to_address(0x200),\n),\n],\nwithdrawals=[\nWithdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x300),\namount=1,\n),\nWithdrawal(\nindex=1,\nvalidator=1,\naddress=to_address(0x400),\namount=1,\n),\n],\n),\n]\npost = {\nto_address(0x100): Account(storage={2: 1}),\nto_address(0x200): Account(storage={2: 1}),\nto_address(0x300): Account(storage={1: 1}),\nto_address(0x400): Account(storage={1: 1}),\n}\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_self_destructing_account","title":"<code>test_self_destructing_account(blockchain_test, fork)</code>","text":"<p>Test withdrawals can be done to self-destructed accounts. Account <code>0x100</code> self-destructs and sends all its balance to <code>0x200</code>. Then, a withdrawal is received at <code>0x100</code> with 99 wei.</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_self_destructing_account(\nblockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test withdrawals can be done to self-destructed accounts.\n    Account `0x100` self-destructs and sends all its balance to `0x200`.\n    Then, a withdrawal is received at `0x100` with 99 wei.\n    \"\"\"\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x100): Account(\ncode=Op.SELFDESTRUCT(Op.CALLDATALOAD(0)),\nbalance=(100 * ONE_GWEI),\n),\nto_address(0x200): Account(\nbalance=0,\n),\n}\ntx_1 = Transaction(\n# Transaction sent from the `TestAddress`, that calls a\n# self-destructing contract.\nnonce=0,\ngas_price=10,\ngas_limit=100000,\nto=to_address(0x100),\ndata=to_hash(0x200),\n)\nwithdrawal = Withdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x100),\namount=(99),\n)\nblock = Block(\ntxs=[tx_1],\nwithdrawals=[withdrawal],\n)\npost = {\nto_address(0x100): Account(\ncode=None,\nbalance=(99 * ONE_GWEI),\n),\nto_address(0x200): Account(\ncode=None,\nbalance=(100 * ONE_GWEI),\n),\n}\nblockchain_test(pre=pre, post=post, blocks=[block])\n</code></pre>"},{"location":"fillers/withdrawals/#fillers.withdrawals.withdrawals.test_use_value_in_contract","title":"<code>test_use_value_in_contract(blockchain_test, fork)</code>","text":"<p>Test sending value from contract that has not received a withdrawal</p> Source code in <code>fillers/withdrawals/withdrawals.py</code> <pre><code>def test_use_value_in_contract(\nblockchain_test: BlockchainTestFiller, fork: Fork\n):\n\"\"\"\n    Test sending value from contract that has not received a withdrawal\n    \"\"\"\nSEND_ONE_GWEI = Op.SSTORE(\nOp.NUMBER,\nOp.CALL(Op.GAS, 0x200, 1000000000, 0, 0, 0, 0),\n)\npre = {\nTestAddress: Account(balance=1000000000000000000000, nonce=0),\nto_address(0x100): Account(balance=0, code=SEND_ONE_GWEI),\nto_address(0x200): Account(balance=0),\n}\ntx = Transaction(\n# Transaction sent from the `TestAddress`, which has 0 balance at start\nnonce=0,\nvalue=0,\ngas_price=10,\ngas_limit=100000,\nto=to_address(0x100),\ndata=\"0x\",\n)\nwithdrawal = Withdrawal(\nindex=0,\nvalidator=0,\naddress=to_address(0x100),\namount=1,\n)\nblocks = [\nBlock(\ntxs=[tx.with_nonce(0)],\nwithdrawals=[withdrawal],\n),\nBlock(\ntxs=[tx.with_nonce(1)],  # Same tx again, just increase nonce\n),\n]\npost = {\nto_address(0x100): Account(\nstorage={\n0x1: 0x0,  # Call fails on the first attempt\n0x2: 0x1,  # Succeeds on the second attempt\n}\n),\nto_address(0x200): Account(\nbalance=ONE_GWEI,\n),\n}\nblockchain_test(pre=pre, post=post, blocks=blocks)\n</code></pre>"},{"location":"fillers/eips/eip3651/","title":"EIP-3651","text":""},{"location":"fillers/eips/eip3651/#eip-3651","title":"EIP-3651","text":"<p>Generate fixtures for this module with: <pre><code>pytest -v fillers/eips/eip3651.py\n</code></pre></p> <p>Test EIP-3651: Warm COINBASE EIP: https://eips.ethereum.org/EIPS/eip-3651 Source tests: https://github.com/ethereum/tests/pull/1082</p>"},{"location":"fillers/eips/eip3651/#fillers.eips.eip3651.test_warm_coinbase_call_out_of_gas","title":"<code>test_warm_coinbase_call_out_of_gas(state_test, fork, opcode, contract_under_test_code, call_gas_exact, use_sufficient_gas)</code>","text":"<p>Test warm coinbase.</p> Source code in <code>fillers/eips/eip3651.py</code> <pre><code>@pytest.mark.parametrize(\n\"use_sufficient_gas\",\n[True, False],\nids=[\"sufficient_gas\", \"insufficient_gas\"],\n)\n@pytest.mark.parametrize(\n\"opcode,contract_under_test_code,call_gas_exact\",\n[\n(\n\"call\",\nOp.POP(Op.CALL(0, Op.COINBASE, 0, 0, 0, 0, 0)),\n# Extra gas: COINBASE + 4*PUSH1 + 2*DUP1 + POP\nGAS_REQUIRED_CALL_WARM_ACCOUNT + 22,\n),\n(\n\"callcode\",\nOp.POP(Op.CALLCODE(0, Op.COINBASE, 0, 0, 0, 0, 0)),\n# Extra gas: COINBASE + 4*PUSH1 + 2*DUP1 + POP\nGAS_REQUIRED_CALL_WARM_ACCOUNT + 22,\n),\n(\n\"delegatecall\",\nOp.POP(Op.DELEGATECALL(0, Op.COINBASE, 0, 0, 0, 0)),\n# Extra: COINBASE + 3*PUSH1 + 2*DUP1 + POP\nGAS_REQUIRED_CALL_WARM_ACCOUNT + 19,\n),\n(\n\"staticcall\",\nOp.POP(Op.STATICCALL(0, Op.COINBASE, 0, 0, 0, 0)),\n# Extra: COINBASE + 3*PUSH1 + 2*DUP1 + POP\nGAS_REQUIRED_CALL_WARM_ACCOUNT + 19,\n),\n],\nids=[\"CALL\", \"CALLCODE\", \"DELEGATECALL\", \"STATICCALL\"],\n)\ndef test_warm_coinbase_call_out_of_gas(\nstate_test,\nfork,\nopcode,\ncontract_under_test_code,\ncall_gas_exact,\nuse_sufficient_gas,\n):\n\"\"\"\n    Test warm coinbase.\n    \"\"\"\nenv = Environment(\ncoinbase=\"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\",\ndifficulty=0x20000,\ngas_limit=10000000000,\nnumber=1,\ntimestamp=1000,\n)\ncaller_address = \"0xcccccccccccccccccccccccccccccccccccccccc\"\ncontract_under_test_address = 0x100\nif not use_sufficient_gas:\ncall_gas_exact -= 1\ncaller_code = Op.SSTORE(\n0,\nOp.CALL(call_gas_exact, contract_under_test_address, 0, 0, 0, 0, 0),\n)\npre = {\nTestAddress: Account(balance=1000000000000000000000),\ncaller_address: Account(code=caller_code),\nto_address(contract_under_test_address): Account(\ncode=contract_under_test_code\n),\n}\ntx = Transaction(\nty=0x0,\nchain_id=0x0,\nnonce=0,\nto=caller_address,\ngas_limit=100000000,\ngas_price=10,\nprotected=False,\n)\npost = {}\nif use_sufficient_gas and is_fork(fork=fork, which=Shanghai):\npost[caller_address] = Account(\nstorage={\n# On shanghai and beyond, calls with only 100 gas to\n# coinbase will succeed.\n0: 1,\n}\n)\nelse:\npost[caller_address] = Account(\nstorage={\n# Before shanghai, calls with only 100 gas to\n# coinbase will fail.\n0: 0,\n}\n)\nstate_test(\nenv=env,\npre=pre,\npost=post,\ntxs=[tx],\ntag=\"opcode_\" + opcode,\n)\n</code></pre>"},{"location":"fillers/eips/eip3651/#fillers.eips.eip3651.test_warm_coinbase_gas_usage","title":"<code>test_warm_coinbase_gas_usage(state_test, fork, opcode, code_gas_measure)</code>","text":"<p>Test gas usage of different opcodes assuming warm coinbase.</p> Source code in <code>fillers/eips/eip3651.py</code> <pre><code>@pytest.mark.parametrize(\n\"opcode,code_gas_measure\",\ngas_measured_opcodes,\nids=[i[0] for i in gas_measured_opcodes],\n)\ndef test_warm_coinbase_gas_usage(state_test, fork, opcode, code_gas_measure):\n\"\"\"\n    Test gas usage of different opcodes assuming warm coinbase.\n    \"\"\"\nenv = Environment(\ncoinbase=\"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\",\ndifficulty=0x20000,\ngas_limit=10000000000,\nnumber=1,\ntimestamp=1000,\n)\nmeasure_address = to_address(0x100)\npre = {\nTestAddress: Account(balance=1000000000000000000000),\nmeasure_address: Account(\ncode=code_gas_measure,\n),\n}\nif is_fork(fork, Shanghai):\nexpected_gas = 100  # Warm account access cost after EIP-3651\nelse:\nexpected_gas = 2600  # Cold account access cost before EIP-3651\npost = {\nmeasure_address: Account(\nstorage={\n0x00: expected_gas,\n}\n)\n}\ntx = Transaction(\nty=0x0,\nchain_id=0x0,\nnonce=0,\nto=measure_address,\ngas_limit=100000000,\ngas_price=10,\nprotected=False,\n)\nstate_test(\nenv=env,\npre=pre,\npost=post,\ntxs=[tx],\ntag=\"opcode_\" + opcode.lower(),\n)\n</code></pre>"},{"location":"fillers/eips/eip3855/","title":"EIP-3855","text":""},{"location":"fillers/eips/eip3855/#eip-3855","title":"EIP-3855","text":"<p>Generate fixtures for this module with: <pre><code>pytest -v fillers/eips/eip3855.py\n</code></pre></p> <p>Test EIP-3855: PUSH0 Instruction EIP: https://eips.ethereum.org/EIPS/eip-3855 Source tests: https://github.com/ethereum/tests/pull/1033</p>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_before_jumpdest","title":"<code>test_push0_before_jumpdest(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Jump to a JUMPDEST next to a PUSH0, must succeed.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_before_jumpdest(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Jump to a JUMPDEST next to a PUSH0, must succeed.\n    \"\"\"\ncode = (\nOp.PUSH1(4)\n+ Op.JUMP\n+ Op.PUSH0\n+ Op.JUMPDEST\n+ Op.SSTORE(Op.PUSH0, 1)\n+ Op.STOP\n)\npre[addr_1] = Account(code=code)\npost[addr_1] = Account(storage={0x00: 0x01})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"before_jumpdest\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_during_staticcall","title":"<code>test_push0_during_staticcall(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Test PUSH0 during staticcall.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_during_staticcall(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Test PUSH0 during staticcall.\n    \"\"\"\naddr_2 = to_address(0x200)\ncode_1 = Yul(\n\"\"\"\n        {\n            sstore(0, staticcall(100000, 0x200, 0, 0, 0, 0))\n            sstore(0, 1)\n            returndatacopy(0x1f, 0, 1)\n            sstore(1, mload(0))\n        }\n        \"\"\"\n)\ncode_2 = Op.MSTORE8(Op.PUSH0, 0xFF) + Op.RETURN(Op.PUSH0, 1)\npre[addr_1] = Account(code=code_1)\npre[addr_2] = Account(code=code_2)\npost[addr_1] = Account(storage={0x00: 0x01, 0x01: 0xFF})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"during_staticcall\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_fill_stack","title":"<code>test_push0_fill_stack(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Fill stack with PUSH0, then OR all values and save using SSTORE.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_fill_stack(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Fill stack with PUSH0, then OR all values and save using SSTORE.\n    \"\"\"\ncode = Op.PUSH0 * 1024\ncode += Op.OR * 1023\ncode += Op.SSTORE(Op.SWAP1, 1)\npre[addr_1] = Account(code=code)\npost[addr_1] = Account(storage={0x00: 0x01})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"fill_stack\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_gas_cost","title":"<code>test_push0_gas_cost(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Test PUSH0 gas cost.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_gas_cost(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Test PUSH0 gas cost.\n    \"\"\"\ncode = CodeGasMeasure(\ncode=Op.PUSH0,\nextra_stack_items=1,\n)\npre[addr_1] = Account(code=code)\npost[addr_1] = Account(storage={0x00: 0x02})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"gas_cost\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_key_sstore","title":"<code>test_push0_key_sstore(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Use PUSH0 to set a key for SSTORE.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_key_sstore(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Use PUSH0 to set a key for SSTORE.\n    \"\"\"\ncode = Op.SSTORE(Op.PUSH0, 1)\npre[addr_1] = Account(code=code)\npost[addr_1] = Account(storage={0x00: 0x01})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"key_sstore\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_stack_overflow","title":"<code>test_push0_stack_overflow(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Stack overflow by using PUSH0 1025 times.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_stack_overflow(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Stack overflow by using PUSH0 1025 times.\n    \"\"\"\ncode = Op.SSTORE(Op.PUSH0, 1)\ncode += Op.PUSH0 * 1025\npre[addr_1] = Account(code=code)\npost[addr_1] = Account(storage={0x00: 0x00})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"stack_overflow\")\n</code></pre>"},{"location":"fillers/eips/eip3855/#fillers.eips.eip3855.test_push0_storage_overwrite","title":"<code>test_push0_storage_overwrite(state_test, fork, env, pre, post, tx, addr_1)</code>","text":"<p>Update an already existing storage value.</p> Source code in <code>fillers/eips/eip3855.py</code> <pre><code>def test_push0_storage_overwrite(\nstate_test: StateTestFiller,\nfork: Fork,\nenv: Environment,\npre: dict,\npost: dict,\ntx: Transaction,\naddr_1: str,\n):\n\"\"\"\n    Update an already existing storage value.\n    \"\"\"\ncode = Op.SSTORE(Op.PUSH0, 2) + Op.SSTORE(1, Op.PUSH0)\npre[addr_1] = Account(code=code, storage={0x00: 0x0A, 0x01: 0x0A})\npost[addr_1] = Account(storage={0x00: 0x02, 0x01: 0x00})\nstate_test(env=env, pre=pre, post=post, txs=[tx], tag=\"storage_overwrite\")\n</code></pre>"},{"location":"fillers/eips/eip3860/","title":"EIP-3860","text":""},{"location":"fillers/eips/eip3860/#eip-3860","title":"EIP-3860","text":"<p>Generate fixtures for this module with: <pre><code>pytest -v fillers/eips/eip3860.py\n</code></pre></p> <p>Test EIP-3860: Limit and meter initcode EIP: https://eips.ethereum.org/EIPS/eip-3860</p> https://github.com/ethereum/tests/pull/990 <p>https://github.com/ethereum/tests/pull/1012</p>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.CALLDATASIZE_OPCODE_GAS","title":"<code>CALLDATASIZE_OPCODE_GAS = 2</code>  <code>module-attribute</code>","text":"<p>Helper functions</p>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.pytestmark","title":"<code>pytestmark = pytest.mark.parametrize('fork', forks_from(Shanghai))</code>  <code>module-attribute</code>","text":"<p>General constants used for testing purposes</p>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage","title":"<code>TestContractCreationGasUsage</code>","text":"<p>Test EIP-3860 Limit Initcode Gas Usage for a contract creating transaction, using different initcode lengths.</p> <p>Generates 4 test cases that verify the gas cost behavior of a</p> contract creating transaction <p>1) Test with exact intrinsic gas minus one, contract create fails    and tx is invalid. 2) Test with exact intrinsic gas, contract create fails,    but tx is valid. 3) Test with exact execution gas minus one, contract create fails,    but tx is valid. 4) Test with exact execution gas, contract create succeeds.</p> <p>Initcode must be within valid EIP-3860 length.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n\"initcode\",\n[\nINITCODE_ZEROS_MAX_LIMIT,\nINITCODE_ONES_MAX_LIMIT,\nEMPTY_INITCODE,\nSINGLE_BYTE_INITCODE,\nINITCODE_ZEROS_32_BYTES,\nINITCODE_ZEROS_33_BYTES,\nINITCODE_ZEROS_49120_BYTES,\nINITCODE_ZEROS_49121_BYTES,\n],\nids=get_initcode_name,\n)\n@pytest.mark.parametrize(\n\"gas_test_case\",\n[\n\"too_little_intrinsic_gas\",\n\"exact_intrinsic_gas\",\n\"too_little_execution_gas\",\n\"exact_execution_gas\",\n],\nids=lambda x: x,\n)\nclass TestContractCreationGasUsage:\n\"\"\"\n    Test EIP-3860 Limit Initcode Gas Usage for a contract\n    creating transaction, using different initcode lengths.\n    Generates 4 test cases that verify the gas cost behavior of a\n    contract creating transaction:\n        1) Test with exact intrinsic gas minus one, contract create fails\n           and tx is invalid.\n        2) Test with exact intrinsic gas, contract create fails,\n           but tx is valid.\n        3) Test with exact execution gas minus one, contract create fails,\n           but tx is valid.\n        4) Test with exact execution gas, contract create succeeds.\n    Initcode must be within valid EIP-3860 length.\n    \"\"\"\n@pytest.fixture\ndef eip_3860_active(self):  # noqa: D102\nreturn True\n@pytest.fixture\ndef exact_intrinsic_gas(self, initcode, eip_3860_active):\n\"\"\"\n        Calculates the intrinsic tx gas cost.\n        \"\"\"\nreturn calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)\n@pytest.fixture\ndef exact_execution_gas(self, initcode, eip_3860_active):\n\"\"\"\n        Calculates the total execution gas cost.\n        \"\"\"\nreturn calculate_create_tx_execution_cost(\ninitcode,\neip_3860_active,\n)\n@pytest.fixture\ndef created_contract_address(self):\n\"\"\"\n        Calculates the address of the contract deployed via CREATE.\n        \"\"\"\nreturn compute_create_address(\naddress=TestAddress,\nnonce=0,\n)\n@pytest.fixture\ndef env(self) -&gt; Environment:  # noqa: D102\nreturn Environment()\n@pytest.fixture\ndef pre(self) -&gt; Dict[Any, Any]:  # noqa: D102\nreturn {\nTestAddress: Account(balance=1000000000000000000000),\n}\n@pytest.fixture\ndef tx_error(self, gas_test_case) -&gt; str | None:\n\"\"\"\n        Test that the transaction is invalid if too little intrinsic gas is\n        specified, otherwise the tx succeeds.\n        \"\"\"\nif gas_test_case == \"too_little_intrinsic_gas\":\nreturn \"intrinsic gas too low\"\nreturn None\n@pytest.fixture\ndef tx(\nself,\ngas_test_case,\ninitcode,\ntx_error,\nexact_intrinsic_gas,\nexact_execution_gas,\n) -&gt; Transaction:\n\"\"\"\n        Implement the gas_test_case by setting the gas_limit of the tx\n        appropriately and test whether the tx succeeds or fails with\n        appropriate error.\n        \"\"\"\nif gas_test_case == \"too_little_intrinsic_gas\":\ngas_limit = exact_intrinsic_gas - 1\nelif gas_test_case == \"exact_intrinsic_gas\":\ngas_limit = exact_intrinsic_gas\nelif gas_test_case == \"too_little_execution_gas\":\ngas_limit = exact_execution_gas - 1\nelif gas_test_case == \"exact_execution_gas\":\ngas_limit = exact_execution_gas\nelse:\npytest.fail(\"Invalid gas test case provided.\")\nreturn Transaction(\nnonce=0,\nto=None,\ndata=initcode,\ngas_limit=gas_limit,\ngas_price=10,\nerror=tx_error,\n)\n@pytest.fixture\ndef block(self, tx, tx_error) -&gt; Block:\n\"\"\"\n        Test that the tx_error is also propagated on the Block for the case of\n        too little intrinsic gas.\n        \"\"\"\nreturn Block(txs=[tx], exception=tx_error)\n@pytest.fixture\ndef post(\nself,\ngas_test_case,\ninitcode,\ncreated_contract_address,\nexact_intrinsic_gas,\nexact_execution_gas,\n) -&gt; Dict[Any, Any]:\n\"\"\"\n        Test that contract creation fails unless enough execution gas is\n        provided.\n        \"\"\"\nif (\ngas_test_case == \"exact_intrinsic_gas\"\nand exact_intrinsic_gas == exact_execution_gas\n):\n# Special scenario where the execution of the initcode and\n# gas cost to deploy are zero\nreturn {\ncreated_contract_address: Account(code=initcode.deploy_code)\n}\nelif gas_test_case == \"exact_execution_gas\":\nreturn {\ncreated_contract_address: Account(code=initcode.deploy_code)\n}\nreturn {created_contract_address: Account.NONEXISTENT}\ndef test_gas_usage(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ngas_test_case: str,\ninitcode: Initcode,\nexact_intrinsic_gas,\nexact_execution_gas,\nenv,\npre,\nblock,\npost,\n):\n\"\"\"\n        Test transaction and contract creation behavior for different gas\n        limits.\n        \"\"\"\nif (gas_test_case == \"too_little_execution_gas\") and (\nexact_execution_gas == exact_intrinsic_gas\n):\npytest.skip(\n\"Special case, the execution of the initcode and gas \"\n\"cost to deploy are zero: Then this test case is \"\n\"equivalent to that of 'test_exact_intrinsic_gas'.\"\n)\nblockchain_test(\npre=pre,\npost=post,\nblocks=[block],\ngenesis_environment=env,\ntag=f\"{initcode.name}_{gas_test_case}\",\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.block","title":"<code>block(tx, tx_error)</code>","text":"<p>Test that the tx_error is also propagated on the Block for the case of too little intrinsic gas.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef block(self, tx, tx_error) -&gt; Block:\n\"\"\"\n    Test that the tx_error is also propagated on the Block for the case of\n    too little intrinsic gas.\n    \"\"\"\nreturn Block(txs=[tx], exception=tx_error)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.created_contract_address","title":"<code>created_contract_address()</code>","text":"<p>Calculates the address of the contract deployed via CREATE.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef created_contract_address(self):\n\"\"\"\n    Calculates the address of the contract deployed via CREATE.\n    \"\"\"\nreturn compute_create_address(\naddress=TestAddress,\nnonce=0,\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.exact_execution_gas","title":"<code>exact_execution_gas(initcode, eip_3860_active)</code>","text":"<p>Calculates the total execution gas cost.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef exact_execution_gas(self, initcode, eip_3860_active):\n\"\"\"\n    Calculates the total execution gas cost.\n    \"\"\"\nreturn calculate_create_tx_execution_cost(\ninitcode,\neip_3860_active,\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.exact_intrinsic_gas","title":"<code>exact_intrinsic_gas(initcode, eip_3860_active)</code>","text":"<p>Calculates the intrinsic tx gas cost.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef exact_intrinsic_gas(self, initcode, eip_3860_active):\n\"\"\"\n    Calculates the intrinsic tx gas cost.\n    \"\"\"\nreturn calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.post","title":"<code>post(gas_test_case, initcode, created_contract_address, exact_intrinsic_gas, exact_execution_gas)</code>","text":"<p>Test that contract creation fails unless enough execution gas is provided.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef post(\nself,\ngas_test_case,\ninitcode,\ncreated_contract_address,\nexact_intrinsic_gas,\nexact_execution_gas,\n) -&gt; Dict[Any, Any]:\n\"\"\"\n    Test that contract creation fails unless enough execution gas is\n    provided.\n    \"\"\"\nif (\ngas_test_case == \"exact_intrinsic_gas\"\nand exact_intrinsic_gas == exact_execution_gas\n):\n# Special scenario where the execution of the initcode and\n# gas cost to deploy are zero\nreturn {\ncreated_contract_address: Account(code=initcode.deploy_code)\n}\nelif gas_test_case == \"exact_execution_gas\":\nreturn {\ncreated_contract_address: Account(code=initcode.deploy_code)\n}\nreturn {created_contract_address: Account.NONEXISTENT}\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.test_gas_usage","title":"<code>test_gas_usage(blockchain_test, fork, gas_test_case, initcode, exact_intrinsic_gas, exact_execution_gas, env, pre, block, post)</code>","text":"<p>Test transaction and contract creation behavior for different gas limits.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def test_gas_usage(\nself,\nblockchain_test: BlockchainTestFiller,\nfork: Fork,\ngas_test_case: str,\ninitcode: Initcode,\nexact_intrinsic_gas,\nexact_execution_gas,\nenv,\npre,\nblock,\npost,\n):\n\"\"\"\n    Test transaction and contract creation behavior for different gas\n    limits.\n    \"\"\"\nif (gas_test_case == \"too_little_execution_gas\") and (\nexact_execution_gas == exact_intrinsic_gas\n):\npytest.skip(\n\"Special case, the execution of the initcode and gas \"\n\"cost to deploy are zero: Then this test case is \"\n\"equivalent to that of 'test_exact_intrinsic_gas'.\"\n)\nblockchain_test(\npre=pre,\npost=post,\nblocks=[block],\ngenesis_environment=env,\ntag=f\"{initcode.name}_{gas_test_case}\",\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.tx","title":"<code>tx(gas_test_case, initcode, tx_error, exact_intrinsic_gas, exact_execution_gas)</code>","text":"<p>Implement the gas_test_case by setting the gas_limit of the tx appropriately and test whether the tx succeeds or fails with appropriate error.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef tx(\nself,\ngas_test_case,\ninitcode,\ntx_error,\nexact_intrinsic_gas,\nexact_execution_gas,\n) -&gt; Transaction:\n\"\"\"\n    Implement the gas_test_case by setting the gas_limit of the tx\n    appropriately and test whether the tx succeeds or fails with\n    appropriate error.\n    \"\"\"\nif gas_test_case == \"too_little_intrinsic_gas\":\ngas_limit = exact_intrinsic_gas - 1\nelif gas_test_case == \"exact_intrinsic_gas\":\ngas_limit = exact_intrinsic_gas\nelif gas_test_case == \"too_little_execution_gas\":\ngas_limit = exact_execution_gas - 1\nelif gas_test_case == \"exact_execution_gas\":\ngas_limit = exact_execution_gas\nelse:\npytest.fail(\"Invalid gas test case provided.\")\nreturn Transaction(\nnonce=0,\nto=None,\ndata=initcode,\ngas_limit=gas_limit,\ngas_price=10,\nerror=tx_error,\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestContractCreationGasUsage.tx_error","title":"<code>tx_error(gas_test_case)</code>","text":"<p>Test that the transaction is invalid if too little intrinsic gas is specified, otherwise the tx succeeds.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.fixture\ndef tx_error(self, gas_test_case) -&gt; str | None:\n\"\"\"\n    Test that the transaction is invalid if too little intrinsic gas is\n    specified, otherwise the tx succeeds.\n    \"\"\"\nif gas_test_case == \"too_little_intrinsic_gas\":\nreturn \"intrinsic gas too low\"\nreturn None\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestCreateInitcode","title":"<code>TestCreateInitcode</code>","text":"<p>Test contract creation via the CREATE/CREATE2 opcodes that have an initcode that is on/over the max allowed limit.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n\"initcode\",\n[\nINITCODE_ZEROS_MAX_LIMIT,\nINITCODE_ONES_MAX_LIMIT,\nINITCODE_ZEROS_OVER_LIMIT,\nINITCODE_ONES_OVER_LIMIT,\nEMPTY_INITCODE,\nSINGLE_BYTE_INITCODE,\nINITCODE_ZEROS_32_BYTES,\nINITCODE_ZEROS_33_BYTES,\nINITCODE_ZEROS_49120_BYTES,\nINITCODE_ZEROS_49121_BYTES,\n],\nids=get_initcode_name,\n)\n@pytest.mark.parametrize(\"opcode\", [Op.CREATE, Op.CREATE2], ids=get_create_id)\nclass TestCreateInitcode:\n\"\"\"\n    Test contract creation via the CREATE/CREATE2 opcodes that have an initcode\n    that is on/over the max allowed limit.\n    \"\"\"\n@pytest.fixture\ndef create_code(self, opcode: Op, initcode: Initcode):  # noqa: D102\nif opcode == Op.CREATE:\ncreate_call = Op.CREATE(0, 0, Op.CALLDATASIZE)\nelif opcode == Op.CREATE2:\ncreate_call = Op.CREATE2(0, 0, Op.CALLDATASIZE, 0xDEADBEEF)\nelse:\nraise Exception(\"Invalid opcode specified for test.\")\nreturn (\nOp.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\n+ Op.GAS\n+ create_call\n+ Op.GAS\n# stack: [Gas 2, Call Result, Gas 1]\n+ Op.SWAP1\n# stack: [Call Result, Gas 2, Gas 1]\n+ Op.SSTORE(0)\n# stack: [Gas 2, Gas 1]\n+ Op.SWAP1\n# stack: [Gas 1, Gas 2]\n+ Op.SUB\n# stack: [Gas 1 - Gas 2]\n+ Op.SSTORE(1)\n)\n@pytest.fixture\ndef created_contract_address(  # noqa: D102\nself, initcode: Initcode, opcode: Op\n):\nif opcode == Op.CREATE:\nreturn compute_create_address(\naddress=0x100,\nnonce=1,\n)\nif opcode == Op.CREATE2:\nreturn compute_create2_address(\naddress=0x100,\nsalt=0xDEADBEEF,\ninitcode=initcode.assemble(),\n)\nraise Exception(\"invalid opcode for generator\")\ndef test_create_opcode_initcode(\nself,\nstate_test: StateTestFiller,\nopcode: Op,\ninitcode: Initcode,\ncreate_code: Yul,\ncreated_contract_address: str,\n):\n\"\"\"\n        Test contract creation via the CREATE/CREATE2 opcodes that have an\n        initcode that is on/over the max allowed limit.\n        \"\"\"\neip_3860_active = True\nenv = Environment()\ncall_code = Op.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\ncall_code += Op.SSTORE(\nOp.CALL(5000000, 0x100, 0, 0, Op.CALLDATASIZE, 0, 0),\n1,\n)\npre = {\nTestAddress: Account(balance=1000000000000000000000),\nto_address(0x100): Account(\ncode=create_code,\nnonce=1,\n),\nto_address(0x200): Account(\ncode=call_code,\nnonce=1,\n),\n}\npost: Dict[Any, Any] = {}\ntx = Transaction(\nnonce=0,\nto=to_address(0x200),\ndata=initcode,\ngas_limit=10000000,\ngas_price=10,\n)\n# Calculate the expected gas of the contract creation operation\nexpected_gas_usage = (\nCREATE_CONTRACT_BASE_GAS\n+ GAS_OPCODE_GAS\n+ (2 * PUSH_DUP_OPCODE_GAS)\n+ CALLDATASIZE_OPCODE_GAS\n)\nif opcode == Op.CREATE2:\n# Extra PUSH operation\nexpected_gas_usage += PUSH_DUP_OPCODE_GAS\nif len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n# Call returns 0 as out of gas s[0]==1\npost[to_address(0x200)] = Account(\nnonce=1,\nstorage={\n0: 1,\n1: 0,\n},\n)\npost[created_contract_address] = Account.NONEXISTENT\npost[to_address(0x100)] = Account(\nnonce=1,\nstorage={\n0: 0,\n1: 0,\n},\n)\nelse:\n# The initcode is only executed if the length check succeeds\nexpected_gas_usage += initcode.execution_gas\n# The code is only deployed if the length check succeeds\nexpected_gas_usage += initcode.deployment_gas\nif opcode == Op.CREATE2:\n# CREATE2 hashing cost should only be deducted if the initcode\n# does not exceed the max length\nexpected_gas_usage += calculate_create2_word_cost(\nlen(initcode.assemble())\n)\nif eip_3860_active:\n# Initcode word cost is only deducted if the length check\n# succeeds\nexpected_gas_usage += calculate_initcode_word_cost(\nlen(initcode.assemble())\n)\n# Call returns 1 as valid initcode length s[0]==1 &amp;&amp; s[1]==1\npost[to_address(0x200)] = Account(\nnonce=1,\nstorage={\n0: 0,\n1: 1,\n},\n)\npost[created_contract_address] = Account(code=initcode.deploy_code)\npost[to_address(0x100)] = Account(\nnonce=2,\nstorage={\n0: created_contract_address,\n1: expected_gas_usage,\n},\n)\nstate_test(\nenv=env,\npre=pre,\npost=post,\ntxs=[tx],\ntag=f\"{initcode.name}_{opcode}\",\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.TestCreateInitcode.test_create_opcode_initcode","title":"<code>test_create_opcode_initcode(state_test, opcode, initcode, create_code, created_contract_address)</code>","text":"<p>Test contract creation via the CREATE/CREATE2 opcodes that have an initcode that is on/over the max allowed limit.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def test_create_opcode_initcode(\nself,\nstate_test: StateTestFiller,\nopcode: Op,\ninitcode: Initcode,\ncreate_code: Yul,\ncreated_contract_address: str,\n):\n\"\"\"\n    Test contract creation via the CREATE/CREATE2 opcodes that have an\n    initcode that is on/over the max allowed limit.\n    \"\"\"\neip_3860_active = True\nenv = Environment()\ncall_code = Op.CALLDATACOPY(0, 0, Op.CALLDATASIZE)\ncall_code += Op.SSTORE(\nOp.CALL(5000000, 0x100, 0, 0, Op.CALLDATASIZE, 0, 0),\n1,\n)\npre = {\nTestAddress: Account(balance=1000000000000000000000),\nto_address(0x100): Account(\ncode=create_code,\nnonce=1,\n),\nto_address(0x200): Account(\ncode=call_code,\nnonce=1,\n),\n}\npost: Dict[Any, Any] = {}\ntx = Transaction(\nnonce=0,\nto=to_address(0x200),\ndata=initcode,\ngas_limit=10000000,\ngas_price=10,\n)\n# Calculate the expected gas of the contract creation operation\nexpected_gas_usage = (\nCREATE_CONTRACT_BASE_GAS\n+ GAS_OPCODE_GAS\n+ (2 * PUSH_DUP_OPCODE_GAS)\n+ CALLDATASIZE_OPCODE_GAS\n)\nif opcode == Op.CREATE2:\n# Extra PUSH operation\nexpected_gas_usage += PUSH_DUP_OPCODE_GAS\nif len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n# Call returns 0 as out of gas s[0]==1\npost[to_address(0x200)] = Account(\nnonce=1,\nstorage={\n0: 1,\n1: 0,\n},\n)\npost[created_contract_address] = Account.NONEXISTENT\npost[to_address(0x100)] = Account(\nnonce=1,\nstorage={\n0: 0,\n1: 0,\n},\n)\nelse:\n# The initcode is only executed if the length check succeeds\nexpected_gas_usage += initcode.execution_gas\n# The code is only deployed if the length check succeeds\nexpected_gas_usage += initcode.deployment_gas\nif opcode == Op.CREATE2:\n# CREATE2 hashing cost should only be deducted if the initcode\n# does not exceed the max length\nexpected_gas_usage += calculate_create2_word_cost(\nlen(initcode.assemble())\n)\nif eip_3860_active:\n# Initcode word cost is only deducted if the length check\n# succeeds\nexpected_gas_usage += calculate_initcode_word_cost(\nlen(initcode.assemble())\n)\n# Call returns 1 as valid initcode length s[0]==1 &amp;&amp; s[1]==1\npost[to_address(0x200)] = Account(\nnonce=1,\nstorage={\n0: 0,\n1: 1,\n},\n)\npost[created_contract_address] = Account(code=initcode.deploy_code)\npost[to_address(0x100)] = Account(\nnonce=2,\nstorage={\n0: created_contract_address,\n1: expected_gas_usage,\n},\n)\nstate_test(\nenv=env,\npre=pre,\npost=post,\ntxs=[tx],\ntag=f\"{initcode.name}_{opcode}\",\n)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.calculate_create2_word_cost","title":"<code>calculate_create2_word_cost(length)</code>","text":"<p>Calculates the added word cost on contract creation added by the hashing of the initcode during create2 contract creation.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create2_word_cost(length: int) -&gt; int:\n\"\"\"\n    Calculates the added word cost on contract creation added by the\n    hashing of the initcode during create2 contract creation.\n    \"\"\"\nreturn KECCAK_WORD_COST * ceiling_division(length, 32)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.calculate_create_tx_execution_cost","title":"<code>calculate_create_tx_execution_cost(initcode, eip_3860_active)</code>","text":"<p>Calculates the total execution gas cost of a transaction that contains initcode and creates a contract</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create_tx_execution_cost(\ninitcode: Initcode,\neip_3860_active: bool,\n) -&gt; int:\n\"\"\"\n    Calculates the total execution gas cost of a transaction that\n    contains initcode and creates a contract\n    \"\"\"\ncost = calculate_create_tx_intrinsic_cost(\ninitcode=initcode, eip_3860_active=eip_3860_active\n)\ncost += initcode.deployment_gas\ncost += initcode.execution_gas\nreturn cost\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.calculate_create_tx_intrinsic_cost","title":"<code>calculate_create_tx_intrinsic_cost(initcode, eip_3860_active)</code>","text":"<p>Calculates the intrinsic gas cost of a transaction that contains initcode and creates a contract</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_create_tx_intrinsic_cost(\ninitcode: Initcode, eip_3860_active: bool\n) -&gt; int:\n\"\"\"\n    Calculates the intrinsic gas cost of a transaction that contains initcode\n    and creates a contract\n    \"\"\"\ncost = (\nBASE_TRANSACTION_GAS  # G_transaction\n+ CREATE_CONTRACT_BASE_GAS  # G_transaction_create\n+ eip_2028_transaction_data_cost(\ninitcode.assemble()\n)  # Transaction calldata cost\n)\nif eip_3860_active:\ncost += calculate_initcode_word_cost(len(initcode.assemble()))\nreturn cost\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.calculate_initcode_word_cost","title":"<code>calculate_initcode_word_cost(length)</code>","text":"<p>Calculates the added word cost on contract creation added by the length of the initcode based on the formula: INITCODE_WORD_COST * ceil(len(initcode) / 32)</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def calculate_initcode_word_cost(length: int) -&gt; int:\n\"\"\"\n    Calculates the added word cost on contract creation added by the\n    length of the initcode based on the formula:\n    INITCODE_WORD_COST * ceil(len(initcode) / 32)\n    \"\"\"\nreturn INITCODE_WORD_COST * ceiling_division(length, 32)\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.get_initcode_name","title":"<code>get_initcode_name(val)</code>","text":"<p>Helper function that returns an Initcode object's name to generate test ids.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>def get_initcode_name(val):\n\"\"\"\n    Helper function that returns an Initcode object's name to generate test\n    ids.\n    \"\"\"\nreturn val.name\n</code></pre>"},{"location":"fillers/eips/eip3860/#fillers.eips.eip3860.test_contract_creating_tx","title":"<code>test_contract_creating_tx(blockchain_test, fork, initcode)</code>","text":"<p>Test cases using a contract creating transaction</p> <p>Test creating a contract using a transaction using an initcode that is on/over the max allowed limit.</p> <p>Generates a BlockchainTest based on the provided <code>initcode</code> and its length.</p> Source code in <code>fillers/eips/eip3860.py</code> <pre><code>@pytest.mark.parametrize(\n\"initcode\",\n[\nINITCODE_ZEROS_MAX_LIMIT,\nINITCODE_ONES_MAX_LIMIT,\nINITCODE_ZEROS_OVER_LIMIT,\nINITCODE_ONES_OVER_LIMIT,\n],\nids=get_initcode_name,\n)\ndef test_contract_creating_tx(\nblockchain_test: BlockchainTestFiller, fork: Fork, initcode: Initcode\n):\n\"\"\"\n    Test cases using a contract creating transaction\n    Test creating a contract using a transaction using an initcode that is\n    on/over the max allowed limit.\n    Generates a BlockchainTest based on the provided `initcode` and its\n    length.\n    \"\"\"\neip_3860_active = True\nenv = Environment()\npre = {\nTestAddress: Account(balance=1000000000000000000000),\n}\npost: Dict[Any, Any] = {}\ncreated_contract_address = compute_create_address(\naddress=TestAddress,\nnonce=0,\n)\ntx = Transaction(\nnonce=0,\nto=None,\ndata=initcode,\ngas_limit=10000000,\ngas_price=10,\n)\nblock = Block(txs=[tx])\nif len(initcode.assemble()) &gt; MAX_INITCODE_SIZE and eip_3860_active:\n# Initcode is above the max size, tx inclusion in the block makes\n# it invalid.\npost[created_contract_address] = Account.NONEXISTENT\ntx.error = \"max initcode size exceeded\"\nblock.exception = \"max initcode size exceeded\"\nelse:\n# Initcode is at or below the max size, tx inclusion in the block\n# is ok and the contract is successfully created.\npost[created_contract_address] = Account(code=Op.STOP)\nblockchain_test(\npre=pre,\npost=post,\nblocks=[block],\ngenesis_environment=env,\ntag=f\"{initcode.name}\",\n)\n</code></pre>"},{"location":"getting_started/package_overview/","title":"Package Overview","text":""},{"location":"getting_started/package_overview/#ethereum_test_tools","title":"<code>ethereum_test_tools</code>","text":"<p>The <code>ethereum_test_tools</code> package provides primitives and helpers to allow developers to easily test the consensus logic of Ethereum clients. </p>"},{"location":"getting_started/package_overview/#ethereum_test_filling_tool","title":"<code>ethereum_test_filling_tool</code>","text":"<p>The <code>ethereum_test_filling_tool</code> package is a CLI application that recursively searches a given directory for Python modules that export test filler functions generated using <code>ethereum_test_tools</code>. It then processes the fillers using the transition tool and the block builder tool, and writes the resulting fixture to file.</p>"},{"location":"getting_started/package_overview/#evm_block_builder","title":"<code>evm_block_builder</code>","text":"<p>This is a wrapper around the block builder (b11r) tool.</p>"},{"location":"getting_started/package_overview/#evm_transition_tool","title":"<code>evm_transition_tool</code>","text":"<p>This is a wrapper around the transaction (t8n) tool.</p>"},{"location":"getting_started/package_overview/#fillers","title":"<code>fillers</code>","text":"<p>Contains all the Ethereum consensus tests available in this repository.</p>"},{"location":"getting_started/quick_start/","title":"Quick Start","text":""},{"location":"getting_started/quick_start/#prerequisites","title":"Prerequisites","text":"<p>The following are required to either generate or develop tests:</p> <ol> <li>Python &gt;= <code>3.10.0</code> &lt; <code>3.11</code>.</li> <li>For dists. with the <code>apt</code> package manager ensure you have python <code>-dev</code> &amp; <code>-venv</code> packages installed.</li> <li> <p><code>go-ethereum</code> <code>geth</code>'s <code>evm</code> utility must be accessible in the <code>PATH</code>, typically at the latest version. To get it:</p> <ol> <li>Install the Go programming language on your computer.</li> <li>Clone the Geth repository.</li> <li>Run <code>make all</code>.</li> <li>Copy <code>build/bin/evm</code> to a directory on the path.</li> </ol> <p>Note: To update to a different Geth branch (for example one that supports a specific EIP) all you need to do is to change the <code>evm</code> in the path.</p> </li> <li> <p><code>solc</code> &gt;= <code>v0.8.17</code>; <code>solc</code> must be in accessible in the <code>PATH</code>.</p> </li> </ol>"},{"location":"getting_started/quick_start/#installation","title":"Installation","text":"<p>To generate tests from the test \"fillers\", it's necessary to install the Python packages provided by <code>execution-spec-tests</code> (it's recommended to use a virtual environment for the installation):</p> <pre><code>git clone https://github.com/ethereum/execution-spec-tests\ncd execution-spec-tests\npython3.10 -m venv ./venv/\nsource ./venv/bin/activate\npip install -e .\n</code></pre> <p>After the installation, run this sanity check to ensure tests are generated. If everything is OK, you will see the beginning of the JSON format filled test.</p> <pre><code>tf --test-case yul\nhead fixtures/example/yul_example/yul.json\n</code></pre>"},{"location":"getting_started/quick_start/#generating-the-execution-spec-tests-for-use-with-clients","title":"Generating the Execution Spec Tests For Use With Clients","text":"<p>To generate all the tests defined in the <code>./fillers</code> sub-directory, run the <code>tf</code> command:</p> <pre><code>tf --filler-path=\"fillers\" --output=\"fixtures\" \n</code></pre> <p>This is equivalent to running <code>tf</code> with no arguments. The paths<code>fillers/</code> and <code>fixtures/</code> are both defaults for the respective command.</p> <p>Note</p> <p>The test <code>post</code> conditions are tested against the output of the <code>geth</code> <code>evm</code> utility during test generation.</p> <p>To generate all the tests in the <code>./fillers/vm</code> sub-directory (category), for example, run: <pre><code>tf --test-categories vm\n</code></pre></p> <p>This extends to sub-directories. As an example, to generate all specific tests within the <code>./fillers/vm/vm_arith/vm_add</code> sub-directory, run: <pre><code>tf --output=\"fixtures\" --test-categories vm.vm_arith.vm_add\n</code></pre></p> <p>To generate all the tests in the <code>./fillers/*/dup.py</code> modules, for example, run: <pre><code>tf --test-module dup\n</code></pre></p> <p>To generate specific tests, such as <code>./fillers/*/*.py::test_dup</code>, for example, run (remove the <code>test_</code> prefix from the test case's function name): <pre><code>tf --test-case dup\n</code></pre></p> <p>To overwrite the existing set of fixtures, make sure you run the test filler with the <code>--force-refill</code> flag: <pre><code>tf --force-refill\n</code></pre></p> <p>For upcoming forks that are not already upgraded within the Ethereum network, use the <code>--latest-fork</code> flag. For example, currently (03/05/23) the next fork being developed is <code>Cancun</code>: <pre><code>tf --latest-fork Cancun\n</code></pre></p>"},{"location":"getting_started/quick_start/#testing-the-execution-spec-tests-framework","title":"Testing the Execution Spec Tests Framework","text":"<p>The Python packages provided by the execution spec tests framework have their own test suite that can be ran via <code>tox</code>:</p> <pre><code>python -m venv ./venv/\nsource ./venv/bin/activate\npip install tox\ntox -e py3\n</code></pre>"},{"location":"getting_started/reference_specification/","title":"Referencing Specification Documents","text":""},{"location":"getting_started/reference_specification/#referencing-an-eip-in-a-test-file","title":"Referencing an EIP in a test file","text":"<p>An Ethereum Improvement Proposal can be directly referenced within a python test file.</p> <p>This is accomplished by adding two key variables anywhere in the file:</p> <ul> <li>REFERENCE_SPEC_GIT_PATH: Path within the https://github.com/ethereum/EIPs/ repository to the EIP markdown file.     E.g. <code>\"EIPS/eip-1234.md\"</code></li> <li>REFERENCE_SPEC_VERSION: <code>SHA</code> digest of the current version of the file</li> </ul> <p>The <code>SHA</code> digest can be obtained using the github api by using the following endpoint:</p> <pre><code>https://api.github.com/repos/ethereum/EIPs/contents/EIPS/eip-&lt;EIP Number&gt;.md\n</code></pre> <p>By adding this reference in the python test file, the <code>tf</code> command will automatically detect and warn when there have been changes to the referenced EIP markdown file.</p>"},{"location":"getting_started/writing_tests/","title":"Writing Tests","text":""},{"location":"getting_started/writing_tests/#purpose-of-test-specs-in-this-repository","title":"Purpose of test specs in this repository","text":"<p>The goal of the test specs included in this repository is to generate test vectors that can be consumed by any Execution client, and to verify that all of the clients agree on the same output after executing each test.</p> <p>Consensus is the most important aspect of any blockchain network, therefore, anything that modifies the state of the blockchain must be tested by at least one test in this repository.</p> <p>The tests focus on the EVM execution, therefore before being able to properly write a test, it is important to understand what the Ethereum Virtual Machine is and how it works.</p>"},{"location":"getting_started/writing_tests/#types-of-tests","title":"Types of tests","text":"<p>At the moment there are only two types of tests that can be produced by each test spec:</p> <ul> <li>State Tests</li> <li>Blockchain Tests</li> </ul> <p>The State tests span a single block and, ideally, a single transaction.</p> <p>Examples of State tests:</p> <ul> <li>Test a single opcode behavior</li> <li>Verify opcode gas costs</li> <li>Test interactions between multiple smart contracts</li> <li>Test creation of smart contracts</li> </ul> <p>The Blockchain tests span multiple blocks which may or may not contain transactions and mainly focus on the block to block effects to the Ethereum state.</p> <ul> <li>Verify system-level operations such as coinbase balance updates or withdrawals</li> <li>Verify fork transitions</li> <li>Verify blocks with invalid transactions/properties are rejected</li> </ul>"},{"location":"getting_started/writing_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>All currently implemented tests can be found in the <code>fillers</code> directory, which is composed of many subdirectories, and each one represents a different test category.</p> <p>Source files included in each category contain one or multiple test specs represented as python functions, and each can in turn produce one or many test vectors.</p> <p>A new test can be added by either:</p> <ul> <li>Adding a new <code>test_</code> python function to an existing file in any of the   existing category subdirectories within <code>fillers</code>.</li> <li>Creating a new source file in an existing category, and populating it with   the new test function(s).</li> <li>Creating an entirely new category by adding a subdirectory in   <code>fillers</code> with the appropriate source files and test functions.<ul> <li>Tests within multiple sub-directories must have a <code>__init__.py</code> file   within each directory above it (and it own), to ensure the test is found by the test filler <code>tf</code>.</li> </ul> </li> </ul>"},{"location":"getting_started/writing_tests/#test-spec-generator-functions","title":"Test Spec Generator Functions","text":"<p>Every test spec is a python generator function which can perform a single or multiple <code>yield</code> operations during its runtime to each time yield a single <code>StateTest</code>/<code>BlockchainTest</code> object.</p> <p>The test vector's generator function must be decorated by only one of the following decorators: - <code>test_from</code> - <code>test_from_until</code> - <code>test_only</code></p> <p>These decorators specify the forks on which the test vector is supposed to run.</p> <p>They also automatically append necessary information for the <code>ethereum_test_filling_tool</code> to process when the generator is being executed to fill the tests.</p> <p>The test vector function must take only one <code>str</code> parameter: the fork name.</p>"},{"location":"getting_started/writing_tests/#statetest-object","title":"<code>StateTest</code> Object","text":"<p>The <code>StateTest</code> object represents a single test vector, and contains the following attributes:</p> <ul> <li>env: Environment object which describes the global state of the blockchain     before the test starts.</li> <li>pre: Pre-State containing the information of all Ethereum accounts that exist     before any transaction is executed.</li> <li>post: Post-State containing the information of all Ethereum accounts that are     created or modified after all transactions are executed.</li> <li>txs: All transactions to be executed during the test vector runtime.</li> </ul>"},{"location":"getting_started/writing_tests/#blockchaintest-object","title":"<code>BlockchainTest</code> Object","text":"<p>The <code>BlockchainTest</code> object represents a single test vector that evaluates the Ethereum VM by attempting to append multiple blocks to the chain:</p> <ul> <li>pre: Pre-State containing the information of all Ethereum accounts that exist     before any block is executed.</li> <li>post: Post-State containing the information of all Ethereum accounts that are     created or modified after all blocks are executed.</li> <li>blocks: All blocks to be appended to the blockchain during the test.</li> </ul>"},{"location":"getting_started/writing_tests/#prepost-state-of-the-test","title":"Pre/Post State of the Test","text":"<p>The <code>pre</code> and <code>post</code> states are elemental to setup and then verify the outcome of the state test.</p> <p>Both <code>pre</code> and <code>post</code> are mappings of account addresses to <code>account</code> structures (see more info).</p> <p>A single test vector can contain as many accounts in the <code>pre</code> and <code>post</code> states as required, and they can be also filled dynamically.</p> <p><code>storage</code> of an account is a key/value dictionary, and its values are integers within range of <code>[0, 2**256 - 1]</code>.</p> <p><code>txs</code> are the steps which transform the pre-state into the post-state and must perform specific actions within the accounts (smart contracts) that result in verifiable changes to the balance, nonce, and/or storage in each of them.</p> <p><code>post</code> is compared against the outcome of the client after the execution of each transaction, and any differences are considered a failure</p> <p>When designing a test, all the changes must be ideally saved into the contract's storage to be able to verify them in the post-state.</p>"},{"location":"getting_started/writing_tests/#test-transactions","title":"Test Transactions","text":"<p>Transactions can be crafted by sending them with specific <code>data</code> or to a specific account, which contains the code to be executed</p> <p>Transactions can also create more accounts, by setting the <code>to</code> field to an  empty string.</p> <p>Transactions can be designed to fail, and a verification must be made that the transaction fails with the specific error that matches what is expected by the test.</p>"},{"location":"getting_started/writing_tests/#writing-code-for-the-accounts-in-the-test","title":"Writing code for the accounts in the test","text":"<p>Account bytecode can be embedded in the test accounts by adding it to the <code>code</code> field of the <code>account</code> object, or the <code>data</code> field of the <code>tx</code> object if the bytecode is meant to be treated as init code or call data.</p> <p>The code can be in either of the following formats: - <code>bytes</code> object, representing the raw opcodes in binary format - <code>str</code>, representing an hexadecimal format of the opcodes - <code>Code</code> compilable object</p> <p>Currently supported built-in compilable objects are:</p> <ul> <li><code>Yul</code> object containing Yul source code</li> </ul> <p><code>Code</code> objects can be concatenated together by using the <code>+</code> operator.</p>"},{"location":"getting_started/writing_tests/#verifying-the-accounts-post-state","title":"Verifying the Accounts' Post State","text":"<p>The state of the accounts after all blocks/transactions have been executed is the way of verifying that the execution client actually behaves like the test expects.</p> <p>During their filling process, all tests automatically verify that the accounts specified in their <code>post</code> property actually match what was returned by the transition tool.</p> <p>Within the <code>post</code> dictionary object, an account address can be: - <code>None</code>: The account will not be checked for absence or existence in the   result returned by the transition tool. - <code>Account</code> object: The test expects that this account exist and also has   properties equal to the properties specified by the <code>Account</code> object. - <code>Account.NONEXISTENT</code>: The test expects that this account does not exist in   the result returned by the transition tool, and if the account exists,   it results in error.   E.g. when the transaction creating a contract is expected to fail and the   test wants to verify that the address where the contract was supposed to be   created is indeed empty.</p>"},{"location":"getting_started/writing_tests/#the-account-object","title":"The <code>Account</code> object","text":"<p>The <code>Account</code> object is used to specify the properties of an account to be verified in the post state.</p> <p>The python representation can be found in src/ethereum_test_tools/common/types.py.</p> <p>It can verify the following properties of an account: - <code>nonce</code>: the scalar value equal to a) the number of transactions sent by   an Externally Owned Account, b) the amount of contracts created by a contract.</p> <ul> <li> <p><code>balance</code>: the amount of Wei (10-18 Eth) the account has.</p> </li> <li> <p><code>code</code>: Bytecode contained by the account. To verify that an account contains   no code, this property needs to be set to \"0x\" or \"\".</p> </li> </ul> <p>It is not recommended to verify Yul compiled code in the output account,   because the bytecode can change from version to version.</p> <ul> <li><code>storage</code>: Storage within the account represented as a <code>dict</code> object.   All storage keys that are expected to be set must be specified, and if a   key is skipped, it is implied that its expected value is zero.   Setting this property to <code>{}</code> (empty <code>dict</code>), means that all the keys in the   account must be unset (equal to zero).</li> </ul> <p>All account's properties are optional, and they can be skipped or set to <code>None</code>, which means that no check will be performed on that specific account property.</p>"},{"location":"getting_started/writing_tests/#verifying-correctness-of-the-new-test","title":"Verifying correctness of the new test","text":"<p>A well written test performs a single verification output at a time.</p> <p>A verification output can be a single storage slot, the balance of an account, or a newly created contract.</p> <p>It is not recommended to use balance changes to verify test correctness, as it can be easily affected by gas cost changes in future EIPs.</p> <p>The best way to verify a transaction/block execution outcome is to check its storage.</p> <p>A test can be written as a negative verification. E.g. a contract is not created, or a transaction fails to execute or runs out of gas.</p> <p>These verifications must be carefully crafted because it is possible to end up having a false positive result, which means that the test passed but the intended verification was never made.</p> <p>To avoid these scenarios, it is important to have a separate verification to check that test is effective. E.g. when a transaction is supposed to fail, it is necessary to check that the failure error is actually the one expected by the test.</p>"},{"location":"getting_started/writing_tests/#failing-or-invalid-transactions","title":"Failing or invalid transactions","text":"<p>Transactions included in a StateTest are expected to be intrinsically valid, i.e. the account sending the transaction must have enough funds to cover the gas costs, the max fee of the transaction must be equal or higher than the base fee of the block, etc.</p> <p>An intrinsically valid transaction can still revert during its execution.</p> <p>Blocks in a BlockchainTest can contain intrinsically invalid transactions but in this case the block is expected to be completely rejected, along with all transactions in it, including other valid transactions.</p>"},{"location":"library/ethereum_test_forks/","title":"EVM Test Forks package","text":"<p>Ethereum test fork definitions.</p>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ArrowGlacier","title":"<code>ArrowGlacier</code>","text":"<p>         Bases: <code>London</code></p> <p>Arrow Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ArrowGlacier(London):\n\"\"\"\n    Arrow Glacier fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Berlin","title":"<code>Berlin</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Berlin fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Berlin(Istanbul):\n\"\"\"\n    Berlin fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.BerlinToLondonAt5","title":"<code>BerlinToLondonAt5</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>Berlin to London transition at Block 5 fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=London)\nclass BerlinToLondonAt5(Berlin):\n\"\"\"\n    Berlin to London transition at Block 5 fork\n    \"\"\"\n@classmethod\ndef header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\nreturn block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.BerlinToLondonAt5.header_base_fee_required","title":"<code>header_base_fee_required(block_number, _)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_base_fee_required(cls, block_number: int, _: int) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\nreturn block_number &gt;= 5\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Byzantium","title":"<code>Byzantium</code>","text":"<p>         Bases: <code>Homestead</code></p> <p>Byzantium fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Byzantium(Homestead):\n\"\"\"\n    Byzantium fork\n    \"\"\"\n@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Byzantium, the block reward is reduced to\n        3_000_000_000_000_000_000 wei\n        \"\"\"\nreturn 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Byzantium.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Byzantium, the block reward is reduced to 3_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Byzantium, the block reward is reduced to\n    3_000_000_000_000_000_000 wei\n    \"\"\"\nreturn 3_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Cancun","title":"<code>Cancun</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Cancun fork</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>class Cancun(Shanghai):\n\"\"\"\n    Cancun fork\n    \"\"\"\n@classmethod\ndef header_excess_data_gas_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        Excess data gas is required starting from Cancun.\n        \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.upcoming.Cancun.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required starting from Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/upcoming.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Excess data gas is required starting from Cancun.\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Constantinople","title":"<code>Constantinople</code>","text":"<p>         Bases: <code>Byzantium</code></p> <p>Constantinople fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Constantinople(Byzantium):\n\"\"\"\n    Constantinople fork\n    \"\"\"\n@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Constantinople, the block reward is reduced to\n        2_000_000_000_000_000_000 wei\n        \"\"\"\nreturn 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Constantinople.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Constantinople, the block reward is reduced to 2_000_000_000_000_000_000 wei</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Constantinople, the block reward is reduced to\n    2_000_000_000_000_000_000 wei\n    \"\"\"\nreturn 2_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ConstantinopleFix","title":"<code>ConstantinopleFix</code>","text":"<p>         Bases: <code>Constantinople</code></p> <p>Constantinople Fix fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class ConstantinopleFix(Constantinople):\n\"\"\"\n    Constantinople Fix fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Frontier","title":"<code>Frontier</code>","text":"<p>         Bases: <code>BaseFork</code></p> <p>Frontier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Frontier(BaseFork):\n\"\"\"\n    Frontier fork\n    \"\"\"\n@classmethod\ndef header_base_fee_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain base fee\n        \"\"\"\nreturn False\n@classmethod\ndef header_prev_randao_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain Prev Randao value\n        \"\"\"\nreturn False\n@classmethod\ndef header_zero_difficulty_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        At genesis, header must not have difficulty zero\n        \"\"\"\nreturn False\n@classmethod\ndef header_withdrawals_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain withdrawals\n        \"\"\"\nreturn False\n@classmethod\ndef header_excess_data_gas_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        At genesis, header must not contain excess data gas\n        \"\"\"\nreturn False\n@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        At Genesis the expected reward amount in wei is\n        5_000_000_000_000_000_000\n        \"\"\"\nreturn 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At Genesis the expected reward amount in wei is 5_000_000_000_000_000_000</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    At Genesis the expected reward amount in wei is\n    5_000_000_000_000_000_000\n    \"\"\"\nreturn 5_000_000_000_000_000_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain base fee</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain base fee\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain excess data gas</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain excess data gas\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain Prev Randao value</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain Prev Randao value\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not contain withdrawals</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not contain withdrawals\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Frontier.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>At genesis, header must not have difficulty zero</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    At genesis, header must not have difficulty zero\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.GrayGlacier","title":"<code>GrayGlacier</code>","text":"<p>         Bases: <code>ArrowGlacier</code></p> <p>Gray Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class GrayGlacier(ArrowGlacier):\n\"\"\"\n    Gray Glacier fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Homestead","title":"<code>Homestead</code>","text":"<p>         Bases: <code>Frontier</code></p> <p>Homestead fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Homestead(Frontier):\n\"\"\"\n    Homestead fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.InvalidForkError","title":"<code>InvalidForkError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Invalid fork error raised when the fork specified by command-line option --latest-fork is not found.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>class InvalidForkError(Exception):\n\"\"\"\n    Invalid fork error raised when the fork specified by command-line option\n    --latest-fork is not found.\n    \"\"\"\ndef __init__(self, message):\nsuper().__init__(message)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Istanbul","title":"<code>Istanbul</code>","text":"<p>         Bases: <code>ConstantinopleFix</code></p> <p>Istanbul fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Istanbul(ConstantinopleFix):\n\"\"\"\n    Istanbul fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.London","title":"<code>London</code>","text":"<p>         Bases: <code>Berlin</code></p> <p>London fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class London(Berlin):\n\"\"\"\n    London fork\n    \"\"\"\n@classmethod\ndef header_base_fee_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        Base Fee is required starting from London.\n        \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.London.header_base_fee_required","title":"<code>header_base_fee_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Base Fee is required starting from London.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_base_fee_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Base Fee is required starting from London.\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Merge","title":"<code>Merge</code>","text":"<p>         Bases: <code>London</code></p> <p>Merge fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Merge(London):\n\"\"\"\n    Merge fork\n    \"\"\"\n@classmethod\ndef header_prev_randao_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        Prev Randao is required starting from Merge.\n        \"\"\"\nreturn True\n@classmethod\ndef header_zero_difficulty_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        Zero difficulty is required starting from Merge.\n        \"\"\"\nreturn True\n@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n        Merge updates the reward to 0.\n        \"\"\"\nreturn 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.get_reward","title":"<code>get_reward(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Merge updates the reward to 0.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef get_reward(cls, block_number: int, timestamp: int) -&gt; int:\n\"\"\"\n    Merge updates the reward to 0.\n    \"\"\"\nreturn 0\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_prev_randao_required","title":"<code>header_prev_randao_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Prev Randao is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_prev_randao_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Prev Randao is required starting from Merge.\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Merge.header_zero_difficulty_required","title":"<code>header_zero_difficulty_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Zero difficulty is required starting from Merge.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_zero_difficulty_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Zero difficulty is required starting from Merge.\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MergeToShanghaiAtTime15k","title":"<code>MergeToShanghaiAtTime15k</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Merge to Shanghai transition at Timestamp 15k fork</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Shanghai)\nclass MergeToShanghaiAtTime15k(Merge):\n\"\"\"\n    Merge to Shanghai transition at Timestamp 15k fork\n    \"\"\"\n@classmethod\ndef header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\nreturn timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.MergeToShanghaiAtTime15k.header_withdrawals_required","title":"<code>header_withdrawals_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\nreturn timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.MuirGlacier","title":"<code>MuirGlacier</code>","text":"<p>         Bases: <code>Istanbul</code></p> <p>Muir Glacier fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class MuirGlacier(Istanbul):\n\"\"\"\n    Muir Glacier fork\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.Shanghai","title":"<code>Shanghai</code>","text":"<p>         Bases: <code>Merge</code></p> <p>Shanghai fork</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>class Shanghai(Merge):\n\"\"\"\n    Shanghai fork\n    \"\"\"\n@classmethod\ndef header_withdrawals_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n        Withdrawals are required starting from Shanghai.\n        \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.forks.Shanghai.header_withdrawals_required","title":"<code>header_withdrawals_required(block_number, timestamp)</code>  <code>classmethod</code>","text":"<p>Withdrawals are required starting from Shanghai.</p> Source code in <code>src/ethereum_test_forks/forks/forks.py</code> <pre><code>@classmethod\ndef header_withdrawals_required(\ncls, block_number: int, timestamp: int\n) -&gt; bool:\n\"\"\"\n    Withdrawals are required starting from Shanghai.\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.ShanghaiToCancunAtTime15k","title":"<code>ShanghaiToCancunAtTime15k</code>","text":"<p>         Bases: <code>Shanghai</code></p> <p>Shanghai to Cancun transition at Timestamp 15k</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@transition_fork(to_fork=Cancun)\nclass ShanghaiToCancunAtTime15k(Shanghai):\n\"\"\"\n    Shanghai to Cancun transition at Timestamp 15k\n    \"\"\"\n@classmethod\ndef header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n        Excess data gas is required if transitioning to Cancun.\n        \"\"\"\nreturn timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks.transition.ShanghaiToCancunAtTime15k.header_excess_data_gas_required","title":"<code>header_excess_data_gas_required(_, timestamp)</code>  <code>classmethod</code>","text":"<p>Excess data gas is required if transitioning to Cancun.</p> Source code in <code>src/ethereum_test_forks/forks/transition.py</code> <pre><code>@classmethod\ndef header_excess_data_gas_required(cls, _: int, timestamp: int) -&gt; bool:\n\"\"\"\n    Excess data gas is required if transitioning to Cancun.\n    \"\"\"\nreturn timestamp &gt;= 15_000\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.fork_only","title":"<code>fork_only(fork)</code>","text":"<p>Returns the specified fork only if it's a fork that precedes the latest</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def fork_only(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork only if it's a fork that precedes the latest\n    \"\"\"\nif issubclass(fork, TransitionBaseClass):\nif fork.transitions_to() is not None:\nif is_fork(\nlatest_fork_resolver.latest_fork, fork.transitions_to()\n):\nreturn [fork]\nreturn []\nif is_fork(latest_fork_resolver.latest_fork, fork):\nreturn [fork]\nreturn []\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from","title":"<code>forks_from(fork)</code>","text":"<p>Returns the specified fork and all forks after it</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from(fork: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it\n    \"\"\"\nreturn forks_from_until(fork, latest_fork_resolver.latest_fork)\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.forks_from_until","title":"<code>forks_from_until(fork_from, fork_until)</code>","text":"<p>Returns the specified fork and all forks after it until and including the second specified fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def forks_from_until(fork_from: Fork, fork_until: Fork) -&gt; List[Fork]:\n\"\"\"\n    Returns the specified fork and all forks after it until and including the\n    second specified fork\n    \"\"\"\nprev_fork = fork_until\nforks: List[Fork] = []\nwhile prev_fork != BaseFork and prev_fork != fork_from:\nforks.insert(0, prev_fork)\nprev_fork = prev_fork.__base__\nif prev_fork == BaseFork:\nreturn []\nforks.insert(0, fork_from)\nreturn forks\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.is_fork","title":"<code>is_fork(fork, which)</code>","text":"<p>Returns <code>True</code> if <code>fork</code> is <code>which</code> or beyond, `False otherwise.</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def is_fork(fork: Fork, which: Fork) -&gt; bool:\n\"\"\"\n    Returns `True` if `fork` is `which` or beyond, `False otherwise.\n    \"\"\"\nprev_fork = fork\nwhile prev_fork != BaseFork:\nif prev_fork == which:\nreturn True\nprev_fork = prev_fork.__base__\nreturn False\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork","title":"<code>set_latest_fork(fork)</code>","text":"<p>Sets the latest fork</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork(fork: Fork) -&gt; None:\n\"\"\"\n    Sets the latest fork\n    \"\"\"\nlatest_fork_resolver.latest_fork = fork\n</code></pre>"},{"location":"library/ethereum_test_forks/#ethereum_test_forks.set_latest_fork_by_name","title":"<code>set_latest_fork_by_name(fork_name)</code>","text":"<p>Sets the latest fork by name</p> Source code in <code>src/ethereum_test_forks/helpers.py</code> <pre><code>def set_latest_fork_by_name(fork_name: str) -&gt; None:\n\"\"\"\n    Sets the latest fork by name\n    \"\"\"\nif fork_name in forks.__dict__:\nset_latest_fork(forks.__dict__[fork_name])\nelif fork_name in upcoming.__dict__:\nset_latest_fork(upcoming.__dict__[fork_name])\nelse:\nraise InvalidForkError(f'fork \"{fork_name}\" not found')\n</code></pre>"},{"location":"library/ethereum_test_tools/","title":"Ethereum Test Tools Package","text":"<p>Module containing tools for generating cross-client Ethereum execution layer tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.AccessList","title":"<code>AccessList</code>  <code>dataclass</code>","text":"<p>Access List for transactions.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass AccessList:\n\"\"\"\n    Access List for transactions.\n    \"\"\"\naddress: str\nstorage_keys: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Account","title":"<code>Account</code>  <code>dataclass</code>","text":"<p>State associated with an address.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Account:\n\"\"\"\n    State associated with an address.\n    \"\"\"\nnonce: int | None = None\n\"\"\"\n    The scalar value equal to a) the number of transactions sent by\n    an Externally Owned Account, b) the amount of contracts created by a\n    contract.\n    \"\"\"\nbalance: int | None = None\n\"\"\"\n    The amount of Wei (10&lt;sup&gt;-18&lt;/sup&gt; Eth) the account has.\n    \"\"\"\ncode: str | bytes | Code | None = None\n\"\"\"\n    Bytecode contained by the account.\n    \"\"\"\nstorage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None\n\"\"\"\n    Storage within a contract.\n    \"\"\"\nNONEXISTENT: ClassVar[object] = object()\n\"\"\"\n    Sentinel object used to specify when an account should not exist in the\n    state.\n    \"\"\"\nclass NonceMismatch(Exception):\n\"\"\"\n        Test expected a certain nonce value for an account but a different\n        value was found.\n        \"\"\"\naddress: str\nwant: int | None\ngot: int | None\ndef __init__(\nself, address: str, want: int | None, got: int | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected nonce for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\nclass BalanceMismatch(Exception):\n\"\"\"\n        Test expected a certain balance for an account but a different\n        value was found.\n        \"\"\"\naddress: str\nwant: int | None\ngot: int | None\ndef __init__(\nself, address: str, want: int | None, got: int | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected balance for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\nclass CodeMismatch(Exception):\n\"\"\"\n        Test expected a certain bytecode for an account but a different\n        one was found.\n        \"\"\"\naddress: str\nwant: str | None\ngot: str | None\ndef __init__(\nself, address: str, want: str | None, got: str | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected code for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\ndef __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\nif self.storage is not None and type(self.storage) is dict:\nself.storage = Storage(self.storage)\ndef check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n        Checks the returned alloc against an expected account in post state.\n        Raises exception on failure.\n        \"\"\"\nif self.nonce is not None:\nactual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\nif self.nonce != actual_nonce:\nraise Account.NonceMismatch(\naddress=address,\nwant=self.nonce,\ngot=actual_nonce,\n)\nif self.balance is not None:\nactual_balance = int_or_none(alloc.get(\"balance\"), 0)\nif self.balance != actual_balance:\nraise Account.BalanceMismatch(\naddress=address,\nwant=self.balance,\ngot=actual_balance,\n)\nif self.code is not None:\nexpected_code = code_to_hex(self.code)\nactual_code = str_or_none(alloc.get(\"code\"), \"0x\")\nif expected_code != actual_code:\nraise Account.CodeMismatch(\naddress=address,\nwant=expected_code,\ngot=actual_code,\n)\nif self.storage is not None:\nexpected_storage = (\nself.storage\nif isinstance(self.storage, Storage)\nelse Storage(self.storage)\n)\nactual_storage = (\nStorage(alloc[\"storage\"])\nif \"storage\" in alloc\nelse Storage({})\n)\nexpected_storage.must_be_equal(actual_storage)\n@classmethod\ndef with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n        Create account with provided `code` and nonce of `1`.\n        \"\"\"\nreturn Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NONEXISTENT","title":"<code>NONEXISTENT: object = object()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify when an account should not exist in the state.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.balance","title":"<code>balance: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of Wei (10-18 Eth) the account has.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.code","title":"<code>code: str | bytes | Code | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bytecode contained by the account.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.nonce","title":"<code>nonce: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scalar value equal to a) the number of transactions sent by an Externally Owned Account, b) the amount of contracts created by a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.storage","title":"<code>storage: Storage | Dict[str | int | bytes, str | int | bytes] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage within a contract.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch","title":"<code>BalanceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain balance for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class BalanceMismatch(Exception):\n\"\"\"\n    Test expected a certain balance for an account but a different\n    value was found.\n    \"\"\"\naddress: str\nwant: int | None\ngot: int | None\ndef __init__(\nself, address: str, want: int | None, got: int | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected balance for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.BalanceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected balance for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch","title":"<code>CodeMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain bytecode for an account but a different one was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class CodeMismatch(Exception):\n\"\"\"\n    Test expected a certain bytecode for an account but a different\n    one was found.\n    \"\"\"\naddress: str\nwant: str | None\ngot: str | None\ndef __init__(\nself, address: str, want: str | None, got: str | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected code for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.CodeMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected code for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch","title":"<code>NonceMismatch</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Test expected a certain nonce value for an account but a different value was found.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class NonceMismatch(Exception):\n\"\"\"\n    Test expected a certain nonce value for an account but a different\n    value was found.\n    \"\"\"\naddress: str\nwant: int | None\ngot: int | None\ndef __init__(\nself, address: str, want: int | None, got: int | None, *args\n):\nsuper().__init__(args)\nself.address = address\nself.want = want\nself.got = got\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected nonce for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.NonceMismatch.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\nf\"unexpected nonce for account {self.address}: \"\n+ f\"want {self.want}, got {self.got}\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Automatically init account members</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Automatically init account members\"\"\"\nif self.storage is not None and type(self.storage) is dict:\nself.storage = Storage(self.storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.check_alloc","title":"<code>check_alloc(address, alloc)</code>","text":"<p>Checks the returned alloc against an expected account in post state. Raises exception on failure.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def check_alloc(self: \"Account\", address: str, alloc: dict):\n\"\"\"\n    Checks the returned alloc against an expected account in post state.\n    Raises exception on failure.\n    \"\"\"\nif self.nonce is not None:\nactual_nonce = int_or_none(alloc.get(\"nonce\"), 0)\nif self.nonce != actual_nonce:\nraise Account.NonceMismatch(\naddress=address,\nwant=self.nonce,\ngot=actual_nonce,\n)\nif self.balance is not None:\nactual_balance = int_or_none(alloc.get(\"balance\"), 0)\nif self.balance != actual_balance:\nraise Account.BalanceMismatch(\naddress=address,\nwant=self.balance,\ngot=actual_balance,\n)\nif self.code is not None:\nexpected_code = code_to_hex(self.code)\nactual_code = str_or_none(alloc.get(\"code\"), \"0x\")\nif expected_code != actual_code:\nraise Account.CodeMismatch(\naddress=address,\nwant=expected_code,\ngot=actual_code,\n)\nif self.storage is not None:\nexpected_storage = (\nself.storage\nif isinstance(self.storage, Storage)\nelse Storage(self.storage)\n)\nactual_storage = (\nStorage(alloc[\"storage\"])\nif \"storage\" in alloc\nelse Storage({})\n)\nexpected_storage.must_be_equal(actual_storage)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Account.with_code","title":"<code>with_code(code)</code>  <code>classmethod</code>","text":"<p>Create account with provided <code>code</code> and nonce of <code>1</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@classmethod\ndef with_code(cls: Type, code: bytes | str | Code) -&gt; \"Account\":\n\"\"\"\n    Create account with provided `code` and nonce of `1`.\n    \"\"\"\nreturn Account(nonce=1, code=code)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BaseTest","title":"<code>BaseTest</code>","text":"<p>Represents a base Ethereum test which must return a genesis and a blockchain.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>class BaseTest:\n\"\"\"\n    Represents a base Ethereum test which must return a genesis and a\n    blockchain.\n    \"\"\"\npre: Mapping[str, Account]\ntag: str = \"\"\n@abstractmethod\ndef make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the test definition.\n        \"\"\"\npass\n@abstractmethod\ndef make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id: int = 1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Generate the blockchain that must be executed sequentially during test.\n        \"\"\"\npass\n@classmethod\n@abstractmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Must return the name of the parameter used in pytest to select this\n        spec type as filler for the test.\n        \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Generate the blockchain that must be executed sequentially during test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id: int = 1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Generate the blockchain that must be executed sequentially during test.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>  <code>abstractmethod</code>","text":"<p>Create a genesis block from the test definition.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@abstractmethod\ndef make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the test definition.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.base_test.BaseTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Must return the name of the parameter used in pytest to select this spec type as filler for the test.</p> Source code in <code>src/ethereum_test_tools/spec/base_test.py</code> <pre><code>@classmethod\n@abstractmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Must return the name of the parameter used in pytest to select this\n    spec type as filler for the test.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Header</code></p> <p>Block type used to describe block properties in test specs</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Block(Header):\n\"\"\"\n    Block type used to describe block properties in test specs\n    \"\"\"\nrlp: Optional[str] = None\n\"\"\"\n    If set, blockchain test will skip generating the block using\n    `evm_block_builder`, and will pass this value directly to the Fixture.\n    Only meant to be used to simulate blocks with bad formats, and therefore\n    requires the block to produce an exception.\n    \"\"\"\nrlp_modifier: Optional[Header] = None\n\"\"\"\n    An RLP modifying header which values would be used to override the ones\n    returned by the  `evm_transition_tool`.\n    \"\"\"\nexception: Optional[str] = None\n\"\"\"\n    If set, the block is expected to be rejected by the client.\n    \"\"\"\ntxs: Optional[List[Transaction]] = None\n\"\"\"\n    List of transactions included in the block.\n    \"\"\"\nommers: Optional[List[Header]] = None\n\"\"\"\n    List of ommer headers included in the block.\n    \"\"\"\nwithdrawals: Optional[List[Withdrawal]] = None\n\"\"\"\n    List of withdrawals to perform for this block.\n    \"\"\"\ndef set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n        Creates a copy of the environment with the characteristics of this\n        specific block.\n        \"\"\"\nnew_env = copy(env)\n\"\"\"\n        Values that need to be set in the environment and are `None` for\n        this block need to be set to their defaults.\n        \"\"\"\nenvironment_default = Environment()\nnew_env.difficulty = self.difficulty\nnew_env.coinbase = (\nself.coinbase\nif self.coinbase is not None\nelse environment_default.coinbase\n)\nnew_env.gas_limit = (\nself.gas_limit\nif self.gas_limit is not None\nelse environment_default.gas_limit\n)\nif not isinstance(self.base_fee, REMOVABLE):\nnew_env.base_fee = self.base_fee\nnew_env.withdrawals = self.withdrawals\nif not isinstance(self.excess_data_gas, REMOVABLE):\nnew_env.excess_data_gas = self.excess_data_gas\n\"\"\"\n        These values are required, but they depend on the previous environment,\n        so they can be calculated here.\n        \"\"\"\nif self.number is not None:\nnew_env.number = self.number\nelse:\n# calculate the next block number for the environment\nif len(new_env.block_hashes) == 0:\nnew_env.number = 0\nelse:\nnew_env.number = max(new_env.block_hashes.keys()) + 1\nif self.timestamp is not None:\nnew_env.timestamp = self.timestamp\nelse:\nassert new_env.parent_timestamp is not None\nnew_env.timestamp = new_env.parent_timestamp + 12\nreturn new_env\ndef copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n        Creates a copy of the block and adds the specified RLP.\n        \"\"\"\nnew_block = deepcopy(self)\nnew_block.rlp = rlp\nreturn new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.exception","title":"<code>exception: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, the block is expected to be rejected by the client.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.ommers","title":"<code>ommers: Optional[List[Header]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of ommer headers included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp","title":"<code>rlp: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, blockchain test will skip generating the block using <code>evm_block_builder</code>, and will pass this value directly to the Fixture.</p> <p>Only meant to be used to simulate blocks with bad formats, and therefore requires the block to produce an exception.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.rlp_modifier","title":"<code>rlp_modifier: Optional[Header] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An RLP modifying header which values would be used to override the ones returned by the  <code>evm_transition_tool</code>.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.txs","title":"<code>txs: Optional[List[Transaction]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of transactions included in the block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.withdrawals","title":"<code>withdrawals: Optional[List[Withdrawal]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of withdrawals to perform for this block.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.copy_with_rlp","title":"<code>copy_with_rlp(rlp)</code>","text":"<p>Creates a copy of the block and adds the specified RLP.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def copy_with_rlp(self, rlp) -&gt; \"Block\":\n\"\"\"\n    Creates a copy of the block and adds the specified RLP.\n    \"\"\"\nnew_block = deepcopy(self)\nnew_block.rlp = rlp\nreturn new_block\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Block.set_environment","title":"<code>set_environment(env)</code>","text":"<p>Creates a copy of the environment with the characteristics of this specific block.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_environment(self, env: Environment) -&gt; Environment:\n\"\"\"\n    Creates a copy of the environment with the characteristics of this\n    specific block.\n    \"\"\"\nnew_env = copy(env)\n\"\"\"\n    Values that need to be set in the environment and are `None` for\n    this block need to be set to their defaults.\n    \"\"\"\nenvironment_default = Environment()\nnew_env.difficulty = self.difficulty\nnew_env.coinbase = (\nself.coinbase\nif self.coinbase is not None\nelse environment_default.coinbase\n)\nnew_env.gas_limit = (\nself.gas_limit\nif self.gas_limit is not None\nelse environment_default.gas_limit\n)\nif not isinstance(self.base_fee, REMOVABLE):\nnew_env.base_fee = self.base_fee\nnew_env.withdrawals = self.withdrawals\nif not isinstance(self.excess_data_gas, REMOVABLE):\nnew_env.excess_data_gas = self.excess_data_gas\n\"\"\"\n    These values are required, but they depend on the previous environment,\n    so they can be calculated here.\n    \"\"\"\nif self.number is not None:\nnew_env.number = self.number\nelse:\n# calculate the next block number for the environment\nif len(new_env.block_hashes) == 0:\nnew_env.number = 0\nelse:\nnew_env.number = max(new_env.block_hashes.keys()) + 1\nif self.timestamp is not None:\nnew_env.timestamp = self.timestamp\nelse:\nassert new_env.parent_timestamp is not None\nnew_env.timestamp = new_env.parent_timestamp + 12\nreturn new_env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.BlockchainTest","title":"<code>BlockchainTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests multiple blocks (valid or invalid) in a chain.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass BlockchainTest(BaseTest):\n\"\"\"\n    Filler type that tests multiple blocks (valid or invalid) in a chain.\n    \"\"\"\npre: Mapping[str, Account]\npost: Mapping[str, Account]\nblocks: List[Block]\ngenesis_environment: Environment = Environment()\ntag: str = \"\"\n@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\nreturn \"blockchain_test\"\ndef make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\nenv = self.genesis_environment.set_fork_requirements(fork)\ngenesis = FixtureHeader(\nparent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\ncoinbase=\"0x0000000000000000000000000000000000000000\",\nstate_root=t8n.calc_state_root(\nto_json(self.pre),\nfork,\n),\ntransactions_root=EmptyTrieRoot,\nreceipt_root=EmptyTrieRoot,\nbloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\ndifficulty=0x20000 if env.difficulty is None else env.difficulty,\nnumber=0,\ngas_limit=env.gas_limit,\ngas_used=0,\ntimestamp=0,\nextra_data=\"0x00\",\nmix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nnonce=\"0x0000000000000000\",\nbase_fee=env.base_fee,\nexcess_data_gas=env.excess_data_gas,\nwithdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\nif env.withdrawals is not None\nelse None,\n)\n(genesis_rlp, genesis.hash) = b11r.build(\nheader=genesis.to_geth_dict(),\ntxs=\"\",\nommers=[],\nwithdrawals=env.withdrawals,\n)\nreturn genesis_rlp, genesis\ndef make_block(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\nblock: Block,\nprevious_env: Environment,\nprevious_alloc: Dict[str, Any],\nprevious_head: str,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n        Produces a block based on the previous environment and allocation.\n        If the block is an invalid block, the environment and allocation\n        returned are the same as passed as parameters.\n        Raises exception on invalid test behavior.\n        Returns\n        -------\n            FixtureBlock: Block to be appended to the fixture.\n            Environment: Environment for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                environment as the one passed as parameter.\n            Dict[str, Any]: Allocation for the next block to produce.\n                If the produced block is invalid, this is exactly the same\n                allocation as the one passed as parameter.\n            str: Hash of the head of the chain, only updated if the produced\n                block is not invalid.\n        \"\"\"\nif block.rlp and block.exception is not None:\nraise Exception(\n\"test correctness: post-state cannot be verified if the \"\n+ \"block's rlp is supplied and the block is not supposed \"\n+ \"to produce an exception\"\n)\nif block.rlp is None:\n# This is the most common case, the RLP needs to be constructed\n# based on the transactions to be included in the block.\n# Set the environment according to the block to execute.\nenv = block.set_environment(previous_env)\nenv = env.set_fork_requirements(fork)\n(next_alloc, result, txs_rlp) = t8n.evaluate(\nalloc=previous_alloc,\ntxs=to_json_or_none(block.txs),\nenv=to_json(env),\nfork=fork,\nchain_id=chain_id,\nreward=fork.get_reward(env.number, env.timestamp),\neips=eips,\n)\ntry:\nrejected_txs = verify_transactions(block.txs, result)\nexcept Exception as e:\nprint_traces(t8n.get_traces())\npprint(result)\npprint(previous_alloc)\npprint(next_alloc)\nraise e\nif len(rejected_txs) &gt; 0 and block.exception is None:\nprint_traces(t8n.get_traces())\nraise Exception(\n\"one or more transactions in `BlockchainTest` are \"\n+ \"intrinsically invalid, but the block was not expected \"\n+ \"to be invalid. Please verify whether the transaction \"\n+ \"was indeed expected to fail and add the proper \"\n+ \"`block.exception`\"\n)\nheader = FixtureHeader.from_dict(\nresult\n| {\n\"parentHash\": env.parent_hash(),\n\"miner\": env.coinbase,\n\"transactionsRoot\": result.get(\"txRoot\"),\n\"difficulty\": str_or_none(\nresult.get(\"currentDifficulty\"), \"0\"\n),\n\"number\": str(env.number),\n\"gasLimit\": str(env.gas_limit),\n\"timestamp\": str(env.timestamp),\n\"extraData\": block.extra_data\nif block.extra_data is not None\nand len(block.extra_data) != 0\nelse \"0x\",\n\"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n\"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n\"nonce\": \"0x0000000000000000\",\n\"baseFeePerGas\": result.get(\"currentBaseFee\"),\n\"excessDataGas\": result.get(\"currentExcessDataGas\"),\n}\n)\nassert len(header.state_root) == 66\nif block.rlp_modifier is not None:\n# Modify any parameter specified in the `rlp_modifier` after\n# transition tool processing.\nheader = header.join(block.rlp_modifier)\nrlp, header.hash = b11r.build(\nheader=header.to_geth_dict(),\ntxs=txs_rlp,\nommers=[],\nwithdrawals=to_json_or_none(env.withdrawals),\n)\nif block.exception is None:\n# Return environment and allocation of the following block\nreturn (\nFixtureBlock(\nrlp=rlp,\nblock_header=header,\nblock_number=header.number,\ntxs=block.txs if block.txs is not None else [],\nommers=[],\nwithdrawals=env.withdrawals,\n),\nenv.apply_new_parent(header),\nnext_alloc,\nheader.hash,\n)\nelse:\nreturn (\nFixtureBlock(\nrlp=rlp,\nexpected_exception=block.exception,\nblock_number=header.number,\n),\nprevious_env,\nprevious_alloc,\nprevious_head,\n)\nelse:\nreturn (\nFixtureBlock(\nrlp=block.rlp,\nexpected_exception=block.exception,\n),\nprevious_env,\nprevious_alloc,\nprevious_head,\n)\ndef make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block list from the blockchain test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\nalloc = to_json(self.pre)\nenv = Environment.from_parent_header(genesis)\nblocks: List[FixtureBlock] = []\nhead = (\ngenesis.hash\nif genesis.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n)\nfor block in self.blocks:\nfixture_block, env, alloc, head = self.make_block(\nb11r=b11r,\nt8n=t8n,\nfork=fork,\nblock=block,\nprevious_env=env,\nprevious_alloc=alloc,\nprevious_head=head,\nchain_id=chain_id,\neips=eips,\n)\nblocks.append(fixture_block)\ntry:\nverify_post_alloc(self.post, alloc)\nexcept Exception as e:\nprint_traces(t8n.get_traces())\nraise e\nreturn (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block","title":"<code>make_block(b11r, t8n, fork, block, previous_env, previous_alloc, previous_head, chain_id=1, eips=None)</code>","text":"<p>Produces a block based on the previous environment and allocation. If the block is an invalid block, the environment and allocation returned are the same as passed as parameters. Raises exception on invalid test behavior.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_block--returns","title":"Returns","text":"<pre><code>FixtureBlock: Block to be appended to the fixture.\nEnvironment: Environment for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    environment as the one passed as parameter.\nDict[str, Any]: Allocation for the next block to produce.\n    If the produced block is invalid, this is exactly the same\n    allocation as the one passed as parameter.\nstr: Hash of the head of the chain, only updated if the produced\n    block is not invalid.\n</code></pre> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_block(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\nblock: Block,\nprevious_env: Environment,\nprevious_alloc: Dict[str, Any],\nprevious_head: str,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[FixtureBlock, Environment, Dict[str, Any], str]:\n\"\"\"\n    Produces a block based on the previous environment and allocation.\n    If the block is an invalid block, the environment and allocation\n    returned are the same as passed as parameters.\n    Raises exception on invalid test behavior.\n    Returns\n    -------\n        FixtureBlock: Block to be appended to the fixture.\n        Environment: Environment for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            environment as the one passed as parameter.\n        Dict[str, Any]: Allocation for the next block to produce.\n            If the produced block is invalid, this is exactly the same\n            allocation as the one passed as parameter.\n        str: Hash of the head of the chain, only updated if the produced\n            block is not invalid.\n    \"\"\"\nif block.rlp and block.exception is not None:\nraise Exception(\n\"test correctness: post-state cannot be verified if the \"\n+ \"block's rlp is supplied and the block is not supposed \"\n+ \"to produce an exception\"\n)\nif block.rlp is None:\n# This is the most common case, the RLP needs to be constructed\n# based on the transactions to be included in the block.\n# Set the environment according to the block to execute.\nenv = block.set_environment(previous_env)\nenv = env.set_fork_requirements(fork)\n(next_alloc, result, txs_rlp) = t8n.evaluate(\nalloc=previous_alloc,\ntxs=to_json_or_none(block.txs),\nenv=to_json(env),\nfork=fork,\nchain_id=chain_id,\nreward=fork.get_reward(env.number, env.timestamp),\neips=eips,\n)\ntry:\nrejected_txs = verify_transactions(block.txs, result)\nexcept Exception as e:\nprint_traces(t8n.get_traces())\npprint(result)\npprint(previous_alloc)\npprint(next_alloc)\nraise e\nif len(rejected_txs) &gt; 0 and block.exception is None:\nprint_traces(t8n.get_traces())\nraise Exception(\n\"one or more transactions in `BlockchainTest` are \"\n+ \"intrinsically invalid, but the block was not expected \"\n+ \"to be invalid. Please verify whether the transaction \"\n+ \"was indeed expected to fail and add the proper \"\n+ \"`block.exception`\"\n)\nheader = FixtureHeader.from_dict(\nresult\n| {\n\"parentHash\": env.parent_hash(),\n\"miner\": env.coinbase,\n\"transactionsRoot\": result.get(\"txRoot\"),\n\"difficulty\": str_or_none(\nresult.get(\"currentDifficulty\"), \"0\"\n),\n\"number\": str(env.number),\n\"gasLimit\": str(env.gas_limit),\n\"timestamp\": str(env.timestamp),\n\"extraData\": block.extra_data\nif block.extra_data is not None\nand len(block.extra_data) != 0\nelse \"0x\",\n\"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n\"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n\"nonce\": \"0x0000000000000000\",\n\"baseFeePerGas\": result.get(\"currentBaseFee\"),\n\"excessDataGas\": result.get(\"currentExcessDataGas\"),\n}\n)\nassert len(header.state_root) == 66\nif block.rlp_modifier is not None:\n# Modify any parameter specified in the `rlp_modifier` after\n# transition tool processing.\nheader = header.join(block.rlp_modifier)\nrlp, header.hash = b11r.build(\nheader=header.to_geth_dict(),\ntxs=txs_rlp,\nommers=[],\nwithdrawals=to_json_or_none(env.withdrawals),\n)\nif block.exception is None:\n# Return environment and allocation of the following block\nreturn (\nFixtureBlock(\nrlp=rlp,\nblock_header=header,\nblock_number=header.number,\ntxs=block.txs if block.txs is not None else [],\nommers=[],\nwithdrawals=env.withdrawals,\n),\nenv.apply_new_parent(header),\nnext_alloc,\nheader.hash,\n)\nelse:\nreturn (\nFixtureBlock(\nrlp=rlp,\nexpected_exception=block.exception,\nblock_number=header.number,\n),\nprevious_env,\nprevious_alloc,\nprevious_head,\n)\nelse:\nreturn (\nFixtureBlock(\nrlp=block.rlp,\nexpected_exception=block.exception,\n),\nprevious_env,\nprevious_alloc,\nprevious_head,\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block list from the blockchain test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block list from the blockchain test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\nalloc = to_json(self.pre)\nenv = Environment.from_parent_header(genesis)\nblocks: List[FixtureBlock] = []\nhead = (\ngenesis.hash\nif genesis.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n)\nfor block in self.blocks:\nfixture_block, env, alloc, head = self.make_block(\nb11r=b11r,\nt8n=t8n,\nfork=fork,\nblock=block,\nprevious_env=env,\nprevious_alloc=alloc,\nprevious_head=head,\nchain_id=chain_id,\neips=eips,\n)\nblocks.append(fixture_block)\ntry:\nverify_post_alloc(self.post, alloc)\nexcept Exception as e:\nprint_traces(t8n.get_traces())\nraise e\nreturn (blocks, head, alloc)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>def make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\nenv = self.genesis_environment.set_fork_requirements(fork)\ngenesis = FixtureHeader(\nparent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\ncoinbase=\"0x0000000000000000000000000000000000000000\",\nstate_root=t8n.calc_state_root(\nto_json(self.pre),\nfork,\n),\ntransactions_root=EmptyTrieRoot,\nreceipt_root=EmptyTrieRoot,\nbloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\ndifficulty=0x20000 if env.difficulty is None else env.difficulty,\nnumber=0,\ngas_limit=env.gas_limit,\ngas_used=0,\ntimestamp=0,\nextra_data=\"0x00\",\nmix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nnonce=\"0x0000000000000000\",\nbase_fee=env.base_fee,\nexcess_data_gas=env.excess_data_gas,\nwithdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\nif env.withdrawals is not None\nelse None,\n)\n(genesis_rlp, genesis.hash) = b11r.build(\nheader=genesis.to_geth_dict(),\ntxs=\"\",\nommers=[],\nwithdrawals=env.withdrawals,\n)\nreturn genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.blockchain_test.BlockchainTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/blockchain_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\nreturn \"blockchain_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Code","title":"<code>Code</code>  <code>dataclass</code>","text":"<p>Generic code object.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>@dataclass(kw_only=True)\nclass Code:\n\"\"\"\n    Generic code object.\n    \"\"\"\nbytecode: Optional[bytes] = None\n\"\"\"\n    bytes array that represents the bytecode of this object.\n    \"\"\"\nname: Optional[str] = None\n\"\"\"\n    Name used to describe this code.\n    Usually used to add extra information to a test case.\n    \"\"\"\ndef assemble(self) -&gt; bytes:\n\"\"\"\n        Transform the Code object into bytes.\n        Normally will be overriden by the classes that inherit this class.\n        \"\"\"\nif self.bytecode is None:\nreturn bytes()\nelse:\nreturn self.bytecode\ndef __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\nreturn Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\ndef __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n        Adds two code objects together, by converting both to bytes first.\n        \"\"\"\nreturn Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.bytecode","title":"<code>bytecode: Optional[bytes] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>bytes array that represents the bytecode of this object.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name used to describe this code. Usually used to add extra information to a test case.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __add__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\nreturn Code(bytecode=(code_to_bytes(self) + code_to_bytes(other)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Adds two code objects together, by converting both to bytes first.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def __radd__(self, other: Union[str, bytes, \"Code\"]) -&gt; \"Code\":\n\"\"\"\n    Adds two code objects together, by converting both to bytes first.\n    \"\"\"\nreturn Code(bytecode=(code_to_bytes(other) + code_to_bytes(self)))\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.code.Code.assemble","title":"<code>assemble()</code>","text":"<p>Transform the Code object into bytes. Normally will be overriden by the classes that inherit this class.</p> Source code in <code>src/ethereum_test_tools/code/code.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Transform the Code object into bytes.\n    Normally will be overriden by the classes that inherit this class.\n    \"\"\"\nif self.bytecode is None:\nreturn bytes()\nelse:\nreturn self.bytecode\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.CodeGasMeasure","title":"<code>CodeGasMeasure</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate bytecode that measures gas usage of a bytecode, taking into account and subtracting any extra overhead gas costs required to execute. By default, the result gas calculation is saved to storage key 0.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>@dataclass(kw_only=True)\nclass CodeGasMeasure(Code):\n\"\"\"\n    Helper class used to generate bytecode that measures gas usage of a\n    bytecode, taking into account and subtracting any extra overhead gas costs\n    required to execute.\n    By default, the result gas calculation is saved to storage key 0.\n    \"\"\"\ncode: bytes | str | Code\n\"\"\"\n    Bytecode to be executed to measure the gas usage.\n    \"\"\"\noverhead_cost: int = 0\n\"\"\"\n    Extra gas cost to be subtracted from extra operations.\n    \"\"\"\nextra_stack_items: int = 0\n\"\"\"\n    Extra stack items that remain at the end of the execution.\n    To be considered when subtracting the value of the previous GAS operation,\n    and to be popped at the end of the execution.\n    \"\"\"\nsstore_key: int = 0\n\"\"\"\n    Storage key to save the gas used.\n    \"\"\"\ndef assemble(self) -&gt; bytes:\n\"\"\"\n        Assemble the bytecode that measures gas usage.\n        \"\"\"\nres = bytes()\nres += bytes(\n[\n0x5A,  # GAS\n]\n)\nres += code_to_bytes(self.code)  # Execute code to measure its gas cost\nres += bytes(\n[\n0x5A,  # GAS\n]\n)\n# We need to swap and pop for each extra stack item that remained from\n# the execution of the code\nres += (\nbytes(\n[\n0x90,  # SWAP1\n0x50,  # POP\n]\n)\n* self.extra_stack_items\n)\nres += bytes(\n[\n0x90,  # SWAP1\n0x03,  # SUB\n0x60,  # PUSH1\nself.overhead_cost + 2,  # Overhead cost + GAS opcode price\n0x90,  # SWAP1\n0x03,  # SUB\n0x60,  # PUSH1\nself.sstore_key,  # -&gt; SSTORE key\n0x55,  # SSTORE\n0x00,  # STOP\n]\n)\nreturn res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.code","title":"<code>code: bytes | str | Code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be executed to measure the gas usage.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.extra_stack_items","title":"<code>extra_stack_items: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extra stack items that remain at the end of the execution. To be considered when subtracting the value of the previous GAS operation, and to be popped at the end of the execution.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.overhead_cost","title":"<code>overhead_cost: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extra gas cost to be subtracted from extra operations.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.sstore_key","title":"<code>sstore_key: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Storage key to save the gas used.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.CodeGasMeasure.assemble","title":"<code>assemble()</code>","text":"<p>Assemble the bytecode that measures gas usage.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assemble the bytecode that measures gas usage.\n    \"\"\"\nres = bytes()\nres += bytes(\n[\n0x5A,  # GAS\n]\n)\nres += code_to_bytes(self.code)  # Execute code to measure its gas cost\nres += bytes(\n[\n0x5A,  # GAS\n]\n)\n# We need to swap and pop for each extra stack item that remained from\n# the execution of the code\nres += (\nbytes(\n[\n0x90,  # SWAP1\n0x50,  # POP\n]\n)\n* self.extra_stack_items\n)\nres += bytes(\n[\n0x90,  # SWAP1\n0x03,  # SUB\n0x60,  # PUSH1\nself.overhead_cost + 2,  # Overhead cost + GAS opcode price\n0x90,  # SWAP1\n0x03,  # SUB\n0x60,  # PUSH1\nself.sstore_key,  # -&gt; SSTORE key\n0x55,  # SSTORE\n0x00,  # STOP\n]\n)\nreturn res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Environment","title":"<code>Environment</code>  <code>dataclass</code>","text":"<p>Structure used to keep track of the context in which a block must be executed.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Environment:\n\"\"\"\n    Structure used to keep track of the context in which a block\n    must be executed.\n    \"\"\"\ncoinbase: str = \"0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba\"\ngas_limit: int = 100000000000000000\nnumber: int = 1\ntimestamp: int = 1000\ndifficulty: Optional[int] = None\nprev_randao: Optional[int] = None\nblock_hashes: Dict[int, str] = field(default_factory=dict)\nbase_fee: Optional[int] = None\nparent_difficulty: Optional[int] = None\nparent_timestamp: Optional[int] = None\nparent_base_fee: Optional[int] = None\nparent_gas_used: Optional[int] = None\nparent_gas_limit: Optional[int] = None\nparent_ommers_hash: Optional[str] = None\nwithdrawals: Optional[List[Withdrawal]] = None\nexcess_data_gas: Optional[int] = None\nparent_excess_data_gas: Optional[int] = None\n@staticmethod\ndef from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Instantiates a new environment with the provided header as parent.\n        \"\"\"\nreturn Environment(\nparent_difficulty=parent.difficulty,\nparent_timestamp=parent.timestamp,\nparent_base_fee=parent.base_fee,\nparent_excess_data_gas=parent.excess_data_gas,\nparent_gas_used=parent.gas_used,\nparent_gas_limit=parent.gas_limit,\nparent_ommers_hash=parent.ommers_hash,\nblock_hashes={\nparent.number: parent.hash\nif parent.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n},\n)\ndef parent_hash(self) -&gt; str:\n\"\"\"\n        Obtjains the latest hash according to the highest block number in\n        `block_hashes`.\n        \"\"\"\nif len(self.block_hashes) == 0:\nreturn \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\nlast_index = max(self.block_hashes.keys())\nreturn self.block_hashes[last_index]\ndef apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n        Applies a header as parent to a copy of this environment.\n        \"\"\"\nenv = copy(self)\nenv.parent_difficulty = new_parent.difficulty\nenv.parent_timestamp = new_parent.timestamp\nenv.parent_base_fee = new_parent.base_fee\nenv.parent_excess_data_gas = new_parent.excess_data_gas\nenv.parent_gas_used = new_parent.gas_used\nenv.parent_gas_limit = new_parent.gas_limit\nenv.parent_ommers_hash = new_parent.ommers_hash\nenv.block_hashes[new_parent.number] = (\nnew_parent.hash\nif new_parent.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n)\nreturn env\ndef set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n        Fills the required fields in an environment depending on the fork.\n        \"\"\"\nres = copy(self)\nif (\nfork.header_prev_randao_required(self.number, self.timestamp)\nand res.prev_randao is None\n):\nres.prev_randao = 0\nif (\nfork.header_withdrawals_required(self.number, self.timestamp)\nand res.withdrawals is None\n):\nres.withdrawals = []\nif (\nfork.header_base_fee_required(self.number, self.timestamp)\nand res.base_fee is None\nand res.parent_base_fee is None\n):\nres.base_fee = DEFAULT_BASE_FEE\nif fork.header_zero_difficulty_required(self.number, self.timestamp):\nres.difficulty = 0\nif (\nfork.header_excess_data_gas_required(self.number, self.timestamp)\nand res.excess_data_gas is None\n):\nres.excess_data_gas = 0\nreturn res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.apply_new_parent","title":"<code>apply_new_parent(new_parent)</code>","text":"<p>Applies a header as parent to a copy of this environment.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def apply_new_parent(self, new_parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Applies a header as parent to a copy of this environment.\n    \"\"\"\nenv = copy(self)\nenv.parent_difficulty = new_parent.difficulty\nenv.parent_timestamp = new_parent.timestamp\nenv.parent_base_fee = new_parent.base_fee\nenv.parent_excess_data_gas = new_parent.excess_data_gas\nenv.parent_gas_used = new_parent.gas_used\nenv.parent_gas_limit = new_parent.gas_limit\nenv.parent_ommers_hash = new_parent.ommers_hash\nenv.block_hashes[new_parent.number] = (\nnew_parent.hash\nif new_parent.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n)\nreturn env\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.from_parent_header","title":"<code>from_parent_header(parent)</code>  <code>staticmethod</code>","text":"<p>Instantiates a new environment with the provided header as parent.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@staticmethod\ndef from_parent_header(parent: \"FixtureHeader\") -&gt; \"Environment\":\n\"\"\"\n    Instantiates a new environment with the provided header as parent.\n    \"\"\"\nreturn Environment(\nparent_difficulty=parent.difficulty,\nparent_timestamp=parent.timestamp,\nparent_base_fee=parent.base_fee,\nparent_excess_data_gas=parent.excess_data_gas,\nparent_gas_used=parent.gas_used,\nparent_gas_limit=parent.gas_limit,\nparent_ommers_hash=parent.ommers_hash,\nblock_hashes={\nparent.number: parent.hash\nif parent.hash is not None\nelse \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\n},\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.parent_hash","title":"<code>parent_hash()</code>","text":"<p>Obtjains the latest hash according to the highest block number in <code>block_hashes</code>.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def parent_hash(self) -&gt; str:\n\"\"\"\n    Obtjains the latest hash according to the highest block number in\n    `block_hashes`.\n    \"\"\"\nif len(self.block_hashes) == 0:\nreturn \"0x0000000000000000000000000000000000000000000000000000000000000000\"  # noqa: E501\nlast_index = max(self.block_hashes.keys())\nreturn self.block_hashes[last_index]\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Environment.set_fork_requirements","title":"<code>set_fork_requirements(fork)</code>","text":"<p>Fills the required fields in an environment depending on the fork.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def set_fork_requirements(self, fork: Fork) -&gt; \"Environment\":\n\"\"\"\n    Fills the required fields in an environment depending on the fork.\n    \"\"\"\nres = copy(self)\nif (\nfork.header_prev_randao_required(self.number, self.timestamp)\nand res.prev_randao is None\n):\nres.prev_randao = 0\nif (\nfork.header_withdrawals_required(self.number, self.timestamp)\nand res.withdrawals is None\n):\nres.withdrawals = []\nif (\nfork.header_base_fee_required(self.number, self.timestamp)\nand res.base_fee is None\nand res.parent_base_fee is None\n):\nres.base_fee = DEFAULT_BASE_FEE\nif fork.header_zero_difficulty_required(self.number, self.timestamp):\nres.difficulty = 0\nif (\nfork.header_excess_data_gas_required(self.number, self.timestamp)\nand res.excess_data_gas is None\n):\nres.excess_data_gas = 0\nreturn res\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Fixture","title":"<code>Fixture</code>  <code>dataclass</code>","text":"<p>Cross-client compatible Ethereum test fixture.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Fixture:\n\"\"\"\n    Cross-client compatible Ethereum test fixture.\n    \"\"\"\nblocks: List[FixtureBlock]\ngenesis: FixtureHeader\ngenesis_rlp: str\nhead: str\nfork: str\npre_state: Mapping[str, Account]\npost_state: Optional[Mapping[str, Account]]\nseal_engine: str\ninfo: Dict[str, str] = field(default_factory=dict)\nname: str = \"\"\nindex: int = 0\n_json: Dict[str, Any] | None = None\ndef __post_init__(self):\n\"\"\"\n        Post init hook to convert to JSON after instantiation.\n        \"\"\"\nself._json = to_json(self)\ndef fill_info(\nself,\nt8n: TransitionTool,\nb11r: BlockBuilder,\nref_spec: ReferenceSpec | None,\n):\n\"\"\"\n        Fill the info field for this fixture\n        \"\"\"\nself.info[\"filling-transition-tool\"] = t8n.version()\nself.info[\"filling-block-build-tool\"] = b11r.version()\nif ref_spec is not None:\nref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init hook to convert to JSON after instantiation.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self):\n\"\"\"\n    Post init hook to convert to JSON after instantiation.\n    \"\"\"\nself._json = to_json(self)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Fixture.fill_info","title":"<code>fill_info(t8n, b11r, ref_spec)</code>","text":"<p>Fill the info field for this fixture</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def fill_info(\nself,\nt8n: TransitionTool,\nb11r: BlockBuilder,\nref_spec: ReferenceSpec | None,\n):\n\"\"\"\n    Fill the info field for this fixture\n    \"\"\"\nself.info[\"filling-transition-tool\"] = t8n.version()\nself.info[\"filling-block-build-tool\"] = b11r.version()\nif ref_spec is not None:\nref_spec.write_info(self.info)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Header","title":"<code>Header</code>  <code>dataclass</code>","text":"<p>Header type used to describe block header properties in test specs.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Header:\n\"\"\"\n    Header type used to describe block header properties in test specs.\n    \"\"\"\nparent_hash: Optional[str] = None\nommers_hash: Optional[str] = None\ncoinbase: Optional[str] = None\nstate_root: Optional[str] = None\ntransactions_root: Optional[str] = None\nreceipt_root: Optional[str] = None\nbloom: Optional[str] = None\ndifficulty: Optional[int] = None\nnumber: Optional[int] = None\ngas_limit: Optional[int] = None\ngas_used: Optional[int] = None\ntimestamp: Optional[int] = None\nextra_data: Optional[str] = None\nmix_digest: Optional[str] = None\nnonce: Optional[str] = None\nbase_fee: Optional[int | REMOVABLE] = None\nwithdrawals_root: Optional[str | REMOVABLE] = None\nexcess_data_gas: Optional[int | REMOVABLE] = None\nhash: Optional[str] = None\nREMOVE_FIELD: ClassVar[REMOVABLE] = REMOVABLE()\n\"\"\"\n    Sentinel object used to specify that a header field should be removed.\n    \"\"\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Header.REMOVE_FIELD","title":"<code>REMOVE_FIELD: REMOVABLE = REMOVABLE()</code>  <code>class-attribute</code>","text":"<p>Sentinel object used to specify that a header field should be removed.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Initcode","title":"<code>Initcode</code>","text":"<p>         Bases: <code>Code</code></p> <p>Helper class used to generate initcode for the specified deployment code.</p> <p>The execution gas cost of the initcode is calculated, and also the deployment gas costs for the deployed code.</p> <p>The initcode can be padded to a certain length if necessary, which does not affect the deployed code.</p> <p>Other costs such as the CREATE2 hashing costs or the initcode_word_cost of EIP-3860 are not taken into account by any of these calculated costs.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>class Initcode(Code):\n\"\"\"\n    Helper class used to generate initcode for the specified deployment code.\n    The execution gas cost of the initcode is calculated, and also the\n    deployment gas costs for the deployed code.\n    The initcode can be padded to a certain length if necessary, which\n    does not affect the deployed code.\n    Other costs such as the CREATE2 hashing costs or the initcode_word_cost\n    of EIP-3860 are *not* taken into account by any of these calculated\n    costs.\n    \"\"\"\ndeploy_code: bytes | str | Code\n\"\"\"\n    Bytecode to be deployed by the initcode.\n    \"\"\"\nexecution_gas: int\n\"\"\"\n    Gas cost of executing the initcode, without considering deployment gas\n    costs.\n    \"\"\"\ndeployment_gas: int\n\"\"\"\n    Gas cost of deploying the cost, subtracted after initcode execution,\n    \"\"\"\ndef __init__(\nself,\n*,\ndeploy_code: str | bytes | Code,\ninitcode_length: Optional[int] = None,\npadding_byte: int = 0x00,\nname: Optional[str] = None,\n):\n\"\"\"\n        Generate legacy initcode that inits a contract with the specified code.\n        The initcode can be padded to a specified length for testing purposes.\n        \"\"\"\nself.execution_gas = 0\nself.deploy_code = deploy_code\ndeploy_code_bytes = code_to_bytes(self.deploy_code)\ncode_length = len(deploy_code_bytes)\ninitcode = bytearray()\n# PUSH2: length=&lt;bytecode length&gt;\ninitcode.append(0x61)\ninitcode += code_length.to_bytes(length=2, byteorder=\"big\")\nself.execution_gas += 3\n# PUSH1: offset=0\ninitcode.append(0x60)\ninitcode.append(0x00)\nself.execution_gas += 3\n# DUP2\ninitcode.append(0x81)\nself.execution_gas += 3\n# PUSH1: initcode_length=11 (constant)\ninitcode.append(0x60)\ninitcode.append(0x0B)\nself.execution_gas += 3\n# DUP3\ninitcode.append(0x82)\nself.execution_gas += 3\n# CODECOPY: destinationOffset=0, offset=0, length\ninitcode.append(0x39)\nself.execution_gas += (\n3\n+ (3 * ceiling_division(code_length, 32))\n+ (3 * code_length)\n+ ((code_length * code_length) // 512)\n)\n# RETURN: offset=0, length\ninitcode.append(0xF3)\nself.execution_gas += 0\npre_padding_bytes = bytes(initcode) + deploy_code_bytes\nif initcode_length is not None:\nif len(pre_padding_bytes) &gt; initcode_length:\nraise Exception(\"Invalid specified length for initcode\")\npadding_bytes = bytes(\n[padding_byte] * (initcode_length - len(pre_padding_bytes))\n)\nelse:\npadding_bytes = bytes()\nself.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\ndeploy_code_bytes\n)\nsuper().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deploy_code","title":"<code>deploy_code: bytes | str | Code = deploy_code</code>  <code>instance-attribute</code>","text":"<p>Bytecode to be deployed by the initcode.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.deployment_gas","title":"<code>deployment_gas: int = GAS_PER_DEPLOYED_CODE_BYTE * len(deploy_code_bytes)</code>  <code>instance-attribute</code>","text":"<p>Gas cost of deploying the cost, subtracted after initcode execution,</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.execution_gas","title":"<code>execution_gas: int = 0</code>  <code>instance-attribute</code>","text":"<p>Gas cost of executing the initcode, without considering deployment gas costs.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.generators.Initcode.__init__","title":"<code>__init__(*, deploy_code, initcode_length=None, padding_byte=0, name=None)</code>","text":"<p>Generate legacy initcode that inits a contract with the specified code. The initcode can be padded to a specified length for testing purposes.</p> Source code in <code>src/ethereum_test_tools/code/generators.py</code> <pre><code>def __init__(\nself,\n*,\ndeploy_code: str | bytes | Code,\ninitcode_length: Optional[int] = None,\npadding_byte: int = 0x00,\nname: Optional[str] = None,\n):\n\"\"\"\n    Generate legacy initcode that inits a contract with the specified code.\n    The initcode can be padded to a specified length for testing purposes.\n    \"\"\"\nself.execution_gas = 0\nself.deploy_code = deploy_code\ndeploy_code_bytes = code_to_bytes(self.deploy_code)\ncode_length = len(deploy_code_bytes)\ninitcode = bytearray()\n# PUSH2: length=&lt;bytecode length&gt;\ninitcode.append(0x61)\ninitcode += code_length.to_bytes(length=2, byteorder=\"big\")\nself.execution_gas += 3\n# PUSH1: offset=0\ninitcode.append(0x60)\ninitcode.append(0x00)\nself.execution_gas += 3\n# DUP2\ninitcode.append(0x81)\nself.execution_gas += 3\n# PUSH1: initcode_length=11 (constant)\ninitcode.append(0x60)\ninitcode.append(0x0B)\nself.execution_gas += 3\n# DUP3\ninitcode.append(0x82)\nself.execution_gas += 3\n# CODECOPY: destinationOffset=0, offset=0, length\ninitcode.append(0x39)\nself.execution_gas += (\n3\n+ (3 * ceiling_division(code_length, 32))\n+ (3 * code_length)\n+ ((code_length * code_length) // 512)\n)\n# RETURN: offset=0, length\ninitcode.append(0xF3)\nself.execution_gas += 0\npre_padding_bytes = bytes(initcode) + deploy_code_bytes\nif initcode_length is not None:\nif len(pre_padding_bytes) &gt; initcode_length:\nraise Exception(\"Invalid specified length for initcode\")\npadding_bytes = bytes(\n[padding_byte] * (initcode_length - len(pre_padding_bytes))\n)\nelse:\npadding_bytes = bytes()\nself.deployment_gas = GAS_PER_DEPLOYED_CODE_BYTE * len(\ndeploy_code_bytes\n)\nsuper().__init__(bytecode=pre_padding_bytes + padding_bytes, name=name)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.JSONEncoder","title":"<code>JSONEncoder</code>","text":"<p>         Bases: <code>json.JSONEncoder</code></p> <p>Custom JSON encoder for <code>ethereum_test</code> types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class JSONEncoder(json.JSONEncoder):\n\"\"\"\n    Custom JSON encoder for `ethereum_test` types.\n    \"\"\"\ndef default(self, obj):\n\"\"\"\n        Enocdes types defined in this module using basic python facilities.\n        \"\"\"\nif isinstance(obj, Storage):\nreturn obj.to_dict()\nelif isinstance(obj, Account):\naccount = {\n\"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n\"balance\": hex_or_none(\nobj.balance, hex(ACCOUNT_DEFAULTS.balance)\n),\n\"code\": code_or_none(obj.code, \"0x\"),\n\"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n}\nreturn even_padding(account, excluded=[\"storage\"])\nelif isinstance(obj, AccessList):\naccess_list = {\"address\": obj.address}\nif obj.storage_keys is not None:\naccess_list[\"storageKeys\"] = obj.storage_keys\nreturn access_list\nelif isinstance(obj, Transaction):\ntx = {\n\"type\": hex(obj.ty),\n\"chainId\": hex(obj.chain_id),\n\"nonce\": hex(obj.nonce),\n\"gasPrice\": hex_or_none(obj.gas_price),\n\"maxPriorityFeePerGas\": hex_or_none(\nobj.max_priority_fee_per_gas\n),\n\"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n\"gas\": hex(obj.gas_limit),\n\"value\": hex(obj.value),\n\"input\": code_to_hex(obj.data),\n\"to\": obj.to,\n\"accessList\": obj.access_list,\n\"protected\": obj.protected,\n\"secretKey\": obj.secret_key,\n\"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n}\nif obj.blob_versioned_hashes is not None:\nhashes: List[str] = []\nfor h in obj.blob_versioned_hashes:\nif type(h) is str:\nhashes.append(h)\nelif type(h) is bytes:\nif len(h) != 32:\nraise TypeError(\n\"improper byte size for blob_versioned_hashes\"\n)\nhashes.append(\"0x\" + h.hex())\nelse:\nraise TypeError(\n\"improper type for blob_versioned_hashes\"\n)\ntx[\"blobVersionedHashes\"] = hashes\nif obj.secret_key is None:\nassert obj.signature is not None\nassert len(obj.signature) == 3\ntx[\"v\"] = obj.signature[0]\ntx[\"r\"] = obj.signature[1]\ntx[\"s\"] = obj.signature[2]\nelse:\ntx[\"v\"] = \"\"\ntx[\"r\"] = \"\"\ntx[\"s\"] = \"\"\nreturn {k: v for (k, v) in tx.items() if v is not None}\nelif isinstance(obj, Withdrawal):\nwithdrawal = {\n\"index\": hex(obj.index),\n\"validatorIndex\": hex(obj.validator),\n\"address\": obj.address,\n\"amount\": hex(obj.amount),\n}\nreturn withdrawal\nelif isinstance(obj, Environment):\nenv = {\n\"currentCoinbase\": obj.coinbase,\n\"currentGasLimit\": str_or_none(obj.gas_limit),\n\"currentNumber\": str_or_none(obj.number),\n\"currentTimestamp\": str_or_none(obj.timestamp),\n\"currentRandom\": str_or_none(obj.prev_randao),\n\"currentDifficulty\": str_or_none(obj.difficulty),\n\"parentDifficulty\": str_or_none(obj.parent_difficulty),\n\"parentBaseFee\": str_or_none(obj.parent_base_fee),\n\"parentGasUsed\": str_or_none(obj.parent_gas_used),\n\"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n\"parentTimstamp\": str_or_none(obj.parent_timestamp),\n\"blockHashes\": {\nstr(k): v for (k, v) in obj.block_hashes.items()\n},\n\"ommers\": [],\n\"withdrawals\": to_json_or_none(obj.withdrawals),\n\"parentUncleHash\": obj.parent_ommers_hash,\n\"currentBaseFee\": str_or_none(obj.base_fee),\n\"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n\"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n}\nreturn {k: v for (k, v) in env.items() if v is not None}\nelif isinstance(obj, FixtureHeader):\nheader = {\n\"parentHash\": obj.parent_hash,\n\"uncleHash\": obj.ommers_hash,\n\"coinbase\": obj.coinbase,\n\"stateRoot\": obj.state_root,\n\"transactionsTrie\": obj.transactions_root,\n\"receiptTrie\": obj.receipt_root,\n\"bloom\": obj.bloom,\n\"difficulty\": hex(obj.difficulty),\n\"number\": hex(obj.number),\n\"gasLimit\": hex(obj.gas_limit),\n\"gasUsed\": hex(obj.gas_used),\n\"timestamp\": hex(obj.timestamp),\n\"extraData\": obj.extra_data\nif len(obj.extra_data) != 0\nelse \"0x\",  # noqa: E501\n\"mixHash\": obj.mix_digest,\n\"nonce\": obj.nonce,\n}\nif obj.base_fee is not None:\nheader[\"baseFeePerGas\"] = hex(obj.base_fee)\nif obj.hash is not None:\nheader[\"hash\"] = obj.hash\nif obj.withdrawals_root is not None:\nheader[\"withdrawalsRoot\"] = obj.withdrawals_root\nif obj.excess_data_gas is not None:\nheader[\"excessDataGas\"] = hex(obj.excess_data_gas)\nreturn even_padding(\nheader,\nexcluded=[\n\"parentHash\",\n\"uncleHash\",\n\"stateRoot\",\n\"coinbase\",\n\"transactionsTrie\",\n\"receiptTrie\",\n\"bloom\",\n\"nonce\",\n\"mixHash\",\n\"hash\",\n\"withdrawalsRoot\",\n\"extraData\",\n],\n)\nelif isinstance(obj, FixtureTransaction):\njson_tx = to_json(obj.tx)\nif json_tx[\"v\"] == \"\":\ndel json_tx[\"v\"]\ndel json_tx[\"r\"]\ndel json_tx[\"s\"]\nif \"input\" in json_tx:\njson_tx[\"data\"] = json_tx[\"input\"]\ndel json_tx[\"input\"]\nif \"gas\" in json_tx:\njson_tx[\"gasLimit\"] = json_tx[\"gas\"]\ndel json_tx[\"gas\"]\nif \"protected\" in json_tx:\ndel json_tx[\"protected\"]\nif \"to\" not in json_tx:\njson_tx[\"to\"] = \"\"\nreturn even_padding(\njson_tx,\nexcluded=[\"to\", \"accessList\"],\n)\nelif isinstance(obj, FixtureBlock):\nb = {\"rlp\": obj.rlp}\nif obj.block_header is not None:\nb[\"blockHeader\"] = json.loads(\njson.dumps(obj.block_header, cls=JSONEncoder)\n)\nif obj.expected_exception is not None:\nb[\"expectException\"] = obj.expected_exception\nif obj.block_number is not None:\nb[\"blocknumber\"] = str(obj.block_number)\nif obj.txs is not None:\nb[\"transactions\"] = [\nFixtureTransaction(tx=tx) for tx in obj.txs\n]\nif obj.ommers is not None:\nb[\"uncleHeaders\"] = obj.ommers\nif obj.withdrawals is not None:\nb[\"withdrawals\"] = [\neven_padding(to_json(wd), excluded=[\"address\"])\nfor wd in obj.withdrawals\n]\nreturn b\nelif isinstance(obj, Fixture):\nif obj._json is not None:\nobj._json[\"_info\"] = obj.info\nreturn obj._json\nf = {\n\"_info\": obj.info,\n\"blocks\": [\njson.loads(json.dumps(b, cls=JSONEncoder))\nfor b in obj.blocks\n],\n\"genesisBlockHeader\": self.default(obj.genesis),\n\"genesisRLP\": obj.genesis_rlp,\n\"lastblockhash\": obj.head,\n\"network\": obj.fork,\n\"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n\"postState\": json.loads(\njson.dumps(obj.post_state, cls=JSONEncoder)\n),\n\"sealEngine\": obj.seal_engine,\n}\nif f[\"postState\"] is None:\ndel f[\"postState\"]\nreturn f\nelse:\nreturn super().default(obj)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.JSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Enocdes types defined in this module using basic python facilities.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def default(self, obj):\n\"\"\"\n    Enocdes types defined in this module using basic python facilities.\n    \"\"\"\nif isinstance(obj, Storage):\nreturn obj.to_dict()\nelif isinstance(obj, Account):\naccount = {\n\"nonce\": hex_or_none(obj.nonce, hex(ACCOUNT_DEFAULTS.nonce)),\n\"balance\": hex_or_none(\nobj.balance, hex(ACCOUNT_DEFAULTS.balance)\n),\n\"code\": code_or_none(obj.code, \"0x\"),\n\"storage\": storage_padding(to_json_or_none(obj.storage, {})),\n}\nreturn even_padding(account, excluded=[\"storage\"])\nelif isinstance(obj, AccessList):\naccess_list = {\"address\": obj.address}\nif obj.storage_keys is not None:\naccess_list[\"storageKeys\"] = obj.storage_keys\nreturn access_list\nelif isinstance(obj, Transaction):\ntx = {\n\"type\": hex(obj.ty),\n\"chainId\": hex(obj.chain_id),\n\"nonce\": hex(obj.nonce),\n\"gasPrice\": hex_or_none(obj.gas_price),\n\"maxPriorityFeePerGas\": hex_or_none(\nobj.max_priority_fee_per_gas\n),\n\"maxFeePerGas\": hex_or_none(obj.max_fee_per_gas),\n\"gas\": hex(obj.gas_limit),\n\"value\": hex(obj.value),\n\"input\": code_to_hex(obj.data),\n\"to\": obj.to,\n\"accessList\": obj.access_list,\n\"protected\": obj.protected,\n\"secretKey\": obj.secret_key,\n\"maxFeePerDataGas\": hex_or_none(obj.max_fee_per_data_gas),\n}\nif obj.blob_versioned_hashes is not None:\nhashes: List[str] = []\nfor h in obj.blob_versioned_hashes:\nif type(h) is str:\nhashes.append(h)\nelif type(h) is bytes:\nif len(h) != 32:\nraise TypeError(\n\"improper byte size for blob_versioned_hashes\"\n)\nhashes.append(\"0x\" + h.hex())\nelse:\nraise TypeError(\n\"improper type for blob_versioned_hashes\"\n)\ntx[\"blobVersionedHashes\"] = hashes\nif obj.secret_key is None:\nassert obj.signature is not None\nassert len(obj.signature) == 3\ntx[\"v\"] = obj.signature[0]\ntx[\"r\"] = obj.signature[1]\ntx[\"s\"] = obj.signature[2]\nelse:\ntx[\"v\"] = \"\"\ntx[\"r\"] = \"\"\ntx[\"s\"] = \"\"\nreturn {k: v for (k, v) in tx.items() if v is not None}\nelif isinstance(obj, Withdrawal):\nwithdrawal = {\n\"index\": hex(obj.index),\n\"validatorIndex\": hex(obj.validator),\n\"address\": obj.address,\n\"amount\": hex(obj.amount),\n}\nreturn withdrawal\nelif isinstance(obj, Environment):\nenv = {\n\"currentCoinbase\": obj.coinbase,\n\"currentGasLimit\": str_or_none(obj.gas_limit),\n\"currentNumber\": str_or_none(obj.number),\n\"currentTimestamp\": str_or_none(obj.timestamp),\n\"currentRandom\": str_or_none(obj.prev_randao),\n\"currentDifficulty\": str_or_none(obj.difficulty),\n\"parentDifficulty\": str_or_none(obj.parent_difficulty),\n\"parentBaseFee\": str_or_none(obj.parent_base_fee),\n\"parentGasUsed\": str_or_none(obj.parent_gas_used),\n\"parentGasLimit\": str_or_none(obj.parent_gas_limit),\n\"parentTimstamp\": str_or_none(obj.parent_timestamp),\n\"blockHashes\": {\nstr(k): v for (k, v) in obj.block_hashes.items()\n},\n\"ommers\": [],\n\"withdrawals\": to_json_or_none(obj.withdrawals),\n\"parentUncleHash\": obj.parent_ommers_hash,\n\"currentBaseFee\": str_or_none(obj.base_fee),\n\"parentExcessDataGas\": str_or_none(obj.parent_excess_data_gas),\n\"currentExcessDataGas\": str_or_none(obj.excess_data_gas),\n}\nreturn {k: v for (k, v) in env.items() if v is not None}\nelif isinstance(obj, FixtureHeader):\nheader = {\n\"parentHash\": obj.parent_hash,\n\"uncleHash\": obj.ommers_hash,\n\"coinbase\": obj.coinbase,\n\"stateRoot\": obj.state_root,\n\"transactionsTrie\": obj.transactions_root,\n\"receiptTrie\": obj.receipt_root,\n\"bloom\": obj.bloom,\n\"difficulty\": hex(obj.difficulty),\n\"number\": hex(obj.number),\n\"gasLimit\": hex(obj.gas_limit),\n\"gasUsed\": hex(obj.gas_used),\n\"timestamp\": hex(obj.timestamp),\n\"extraData\": obj.extra_data\nif len(obj.extra_data) != 0\nelse \"0x\",  # noqa: E501\n\"mixHash\": obj.mix_digest,\n\"nonce\": obj.nonce,\n}\nif obj.base_fee is not None:\nheader[\"baseFeePerGas\"] = hex(obj.base_fee)\nif obj.hash is not None:\nheader[\"hash\"] = obj.hash\nif obj.withdrawals_root is not None:\nheader[\"withdrawalsRoot\"] = obj.withdrawals_root\nif obj.excess_data_gas is not None:\nheader[\"excessDataGas\"] = hex(obj.excess_data_gas)\nreturn even_padding(\nheader,\nexcluded=[\n\"parentHash\",\n\"uncleHash\",\n\"stateRoot\",\n\"coinbase\",\n\"transactionsTrie\",\n\"receiptTrie\",\n\"bloom\",\n\"nonce\",\n\"mixHash\",\n\"hash\",\n\"withdrawalsRoot\",\n\"extraData\",\n],\n)\nelif isinstance(obj, FixtureTransaction):\njson_tx = to_json(obj.tx)\nif json_tx[\"v\"] == \"\":\ndel json_tx[\"v\"]\ndel json_tx[\"r\"]\ndel json_tx[\"s\"]\nif \"input\" in json_tx:\njson_tx[\"data\"] = json_tx[\"input\"]\ndel json_tx[\"input\"]\nif \"gas\" in json_tx:\njson_tx[\"gasLimit\"] = json_tx[\"gas\"]\ndel json_tx[\"gas\"]\nif \"protected\" in json_tx:\ndel json_tx[\"protected\"]\nif \"to\" not in json_tx:\njson_tx[\"to\"] = \"\"\nreturn even_padding(\njson_tx,\nexcluded=[\"to\", \"accessList\"],\n)\nelif isinstance(obj, FixtureBlock):\nb = {\"rlp\": obj.rlp}\nif obj.block_header is not None:\nb[\"blockHeader\"] = json.loads(\njson.dumps(obj.block_header, cls=JSONEncoder)\n)\nif obj.expected_exception is not None:\nb[\"expectException\"] = obj.expected_exception\nif obj.block_number is not None:\nb[\"blocknumber\"] = str(obj.block_number)\nif obj.txs is not None:\nb[\"transactions\"] = [\nFixtureTransaction(tx=tx) for tx in obj.txs\n]\nif obj.ommers is not None:\nb[\"uncleHeaders\"] = obj.ommers\nif obj.withdrawals is not None:\nb[\"withdrawals\"] = [\neven_padding(to_json(wd), excluded=[\"address\"])\nfor wd in obj.withdrawals\n]\nreturn b\nelif isinstance(obj, Fixture):\nif obj._json is not None:\nobj._json[\"_info\"] = obj.info\nreturn obj._json\nf = {\n\"_info\": obj.info,\n\"blocks\": [\njson.loads(json.dumps(b, cls=JSONEncoder))\nfor b in obj.blocks\n],\n\"genesisBlockHeader\": self.default(obj.genesis),\n\"genesisRLP\": obj.genesis_rlp,\n\"lastblockhash\": obj.head,\n\"network\": obj.fork,\n\"pre\": json.loads(json.dumps(obj.pre_state, cls=JSONEncoder)),\n\"postState\": json.loads(\njson.dumps(obj.post_state, cls=JSONEncoder)\n),\n\"sealEngine\": obj.seal_engine,\n}\nif f[\"postState\"] is None:\ndel f[\"postState\"]\nreturn f\nelse:\nreturn super().default(obj)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode","title":"<code>Opcode</code>","text":"<p>         Bases: <code>bytes</code></p> <p>Represents a single Opcode instruction in the EVM, with extra metadata useful to parametrize tests.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcode--parameters","title":"Parameters","text":"<ul> <li>popped_stack_items: number of items the opcode pops from the stack</li> <li>pushed_stack_items: number of items the opcode pushes to the stack</li> <li>min_stack_height: minimum stack height required by the opcode</li> <li>data_portion_length: number of bytes after the opcode in the bytecode     that represent data</li> </ul> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcode(bytes):\n\"\"\"\n    Represents a single Opcode instruction in the EVM, with extra\n    metadata useful to parametrize tests.\n    Parameters\n    ----------\n    - popped_stack_items: number of items the opcode pops from the stack\n    - pushed_stack_items: number of items the opcode pushes to the stack\n    - min_stack_height: minimum stack height required by the opcode\n    - data_portion_length: number of bytes after the opcode in the bytecode\n        that represent data\n    \"\"\"\npopped_stack_items: int\npushed_stack_items: int\nmin_stack_height: int\ndata_portion_length: int\ndef __new__(\ncls,\nopcode_or_byte: Union[int, \"Opcode\"],\n*,\npopped_stack_items: int = 0,\npushed_stack_items: int = 0,\nmin_stack_height: int = 0,\ndata_portion_length: int = 0\n):\n\"\"\"\n        Creates a new opcode instance.\n        \"\"\"\nif type(opcode_or_byte) is Opcode:\n# Required because Enum class calls the base class with the\n# instantiated object as parameter.\nreturn opcode_or_byte\nelif isinstance(opcode_or_byte, int):\nobj = super().__new__(cls, [opcode_or_byte])\nobj.popped_stack_items = popped_stack_items\nobj.pushed_stack_items = pushed_stack_items\nobj.min_stack_height = min_stack_height\nobj.data_portion_length = data_portion_length\nreturn obj\ndef __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n        Makes all opcode instances callable to return formatted bytecode,\n        which constitutes a data portion, that is located after the opcode\n        byte, and pre-opcode bytecode, which is normally used to set up the\n        stack.\n        This useful to automatically format, e.g., push opcodes and their\n        data sections as `Opcodes.PUSH1(0x00)`.\n        Data sign is automatically detected but for this reason the range\n        of the input must be:\n        `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n        where:\n        `data_portion_bits == data_portion_length * 8`\n        For the stack, the arguments are set up in the opposite order they are\n        given, so the first argument is the last item pushed to the stack.\n        The resulting stack arrangement does not take into account opcode stack\n        element consumption, so the stack height is not guaranteed to be\n        correct and the user must take this into consideration.\n        Integers can also be used as stack elements, in which case they are\n        automatically converted to PUSH operations, and negative numbers always\n        use a PUSH32 operation.\n        \"\"\"\nargs: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\npre_opcode_bytecode = bytes()\ndata_portion = bytes()\nif self.data_portion_length &gt; 0:\n# For opcodes with a data portion, the first argument is the data\n# and the rest of the arguments form the stack.\nif len(args) == 0:\nraise ValueError(\n\"Opcode with data portion requires at least one argument\"\n)\ndata = args.pop(0)\nif isinstance(data, bytes):\ndata_portion = data\nelif isinstance(data, int):\nsigned = data &lt; 0\ndata_portion = data.to_bytes(\nlength=self.data_portion_length,\nbyteorder=\"big\",\nsigned=signed,\n)\nelse:\nraise TypeError(\n\"Opcode data portion must be either an int or a bytes\"\n)\n# The rest of the arguments conform the stack.\nwhile len(args) &gt; 0:\ndata = args.pop()\nif isinstance(data, bytes):\npre_opcode_bytecode += data\nelif isinstance(data, int):\n# We are going to push a constant to the stack.\nsigned = data &lt; 0\ndata_size = _get_int_size(data)\nif data_size &gt; 32:\nraise ValueError(\n\"Opcode stack data must be less than 32 bytes\"\n)\nelif data_size == 0:\n# Pushing 0 is done with the PUSH1 opcode for compatibility\n# reasons.\ndata_size = 1\npre_opcode_bytecode += _push_opcodes_byte_list[data_size]\npre_opcode_bytecode += data.to_bytes(\nlength=data_size,\nbyteorder=\"big\",\nsigned=signed,\n)\nelse:\nraise TypeError(\n\"Opcode stack data must be either an int or a bytes\"\n)\nreturn pre_opcode_bytecode + self + data_portion\ndef __len__(self) -&gt; int:\n\"\"\"\n        Returns the total bytecode length of the opcode, taking into account\n        its data portion.\n        \"\"\"\nreturn self.data_portion_length + 1\ndef int(self) -&gt; int:\n\"\"\"\n        Returns the integer representation of the opcode.\n        \"\"\"\nreturn int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__call__","title":"<code>__call__(*args_t)</code>","text":"<p>Makes all opcode instances callable to return formatted bytecode, which constitutes a data portion, that is located after the opcode byte, and pre-opcode bytecode, which is normally used to set up the stack.</p> <p>This useful to automatically format, e.g., push opcodes and their data sections as <code>Opcodes.PUSH1(0x00)</code>.</p> <p>Data sign is automatically detected but for this reason the range of the input must be: <code>[-2^(data_portion_bits-1), 2^(data_portion_bits)]</code> where: <code>data_portion_bits == data_portion_length * 8</code></p> <p>For the stack, the arguments are set up in the opposite order they are given, so the first argument is the last item pushed to the stack.</p> <p>The resulting stack arrangement does not take into account opcode stack element consumption, so the stack height is not guaranteed to be correct and the user must take this into consideration.</p> <p>Integers can also be used as stack elements, in which case they are automatically converted to PUSH operations, and negative numbers always use a PUSH32 operation.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __call__(self, *args_t: Union[int, bytes, \"Opcode\"]) -&gt; bytes:\n\"\"\"\n    Makes all opcode instances callable to return formatted bytecode,\n    which constitutes a data portion, that is located after the opcode\n    byte, and pre-opcode bytecode, which is normally used to set up the\n    stack.\n    This useful to automatically format, e.g., push opcodes and their\n    data sections as `Opcodes.PUSH1(0x00)`.\n    Data sign is automatically detected but for this reason the range\n    of the input must be:\n    `[-2^(data_portion_bits-1), 2^(data_portion_bits)]`\n    where:\n    `data_portion_bits == data_portion_length * 8`\n    For the stack, the arguments are set up in the opposite order they are\n    given, so the first argument is the last item pushed to the stack.\n    The resulting stack arrangement does not take into account opcode stack\n    element consumption, so the stack height is not guaranteed to be\n    correct and the user must take this into consideration.\n    Integers can also be used as stack elements, in which case they are\n    automatically converted to PUSH operations, and negative numbers always\n    use a PUSH32 operation.\n    \"\"\"\nargs: List[Union[int, bytes, \"Opcode\"]] = list(args_t)\npre_opcode_bytecode = bytes()\ndata_portion = bytes()\nif self.data_portion_length &gt; 0:\n# For opcodes with a data portion, the first argument is the data\n# and the rest of the arguments form the stack.\nif len(args) == 0:\nraise ValueError(\n\"Opcode with data portion requires at least one argument\"\n)\ndata = args.pop(0)\nif isinstance(data, bytes):\ndata_portion = data\nelif isinstance(data, int):\nsigned = data &lt; 0\ndata_portion = data.to_bytes(\nlength=self.data_portion_length,\nbyteorder=\"big\",\nsigned=signed,\n)\nelse:\nraise TypeError(\n\"Opcode data portion must be either an int or a bytes\"\n)\n# The rest of the arguments conform the stack.\nwhile len(args) &gt; 0:\ndata = args.pop()\nif isinstance(data, bytes):\npre_opcode_bytecode += data\nelif isinstance(data, int):\n# We are going to push a constant to the stack.\nsigned = data &lt; 0\ndata_size = _get_int_size(data)\nif data_size &gt; 32:\nraise ValueError(\n\"Opcode stack data must be less than 32 bytes\"\n)\nelif data_size == 0:\n# Pushing 0 is done with the PUSH1 opcode for compatibility\n# reasons.\ndata_size = 1\npre_opcode_bytecode += _push_opcodes_byte_list[data_size]\npre_opcode_bytecode += data.to_bytes(\nlength=data_size,\nbyteorder=\"big\",\nsigned=signed,\n)\nelse:\nraise TypeError(\n\"Opcode stack data must be either an int or a bytes\"\n)\nreturn pre_opcode_bytecode + self + data_portion\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total bytecode length of the opcode, taking into account its data portion.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Returns the total bytecode length of the opcode, taking into account\n    its data portion.\n    \"\"\"\nreturn self.data_portion_length + 1\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.__new__","title":"<code>__new__(opcode_or_byte, *, popped_stack_items=0, pushed_stack_items=0, min_stack_height=0, data_portion_length=0)</code>","text":"<p>Creates a new opcode instance.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def __new__(\ncls,\nopcode_or_byte: Union[int, \"Opcode\"],\n*,\npopped_stack_items: int = 0,\npushed_stack_items: int = 0,\nmin_stack_height: int = 0,\ndata_portion_length: int = 0\n):\n\"\"\"\n    Creates a new opcode instance.\n    \"\"\"\nif type(opcode_or_byte) is Opcode:\n# Required because Enum class calls the base class with the\n# instantiated object as parameter.\nreturn opcode_or_byte\nelif isinstance(opcode_or_byte, int):\nobj = super().__new__(cls, [opcode_or_byte])\nobj.popped_stack_items = popped_stack_items\nobj.pushed_stack_items = pushed_stack_items\nobj.min_stack_height = min_stack_height\nobj.data_portion_length = data_portion_length\nreturn obj\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.vm.opcode.Opcode.int","title":"<code>int()</code>","text":"<p>Returns the integer representation of the opcode.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>def int(self) -&gt; int:\n\"\"\"\n    Returns the integer representation of the opcode.\n    \"\"\"\nreturn int.from_bytes(bytes=self, byteorder=\"big\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Opcodes","title":"<code>Opcodes</code>","text":"<p>         Bases: <code>Opcode</code>, <code>Enum</code></p> <p>Enum containing all known opcodes.</p> <p>Contains deprecated and not yet implemented opcodes.</p> <p>This enum is !! NOT !! meant to be iterated over by the tests. Instead, create a list with cherry-picked opcodes from this Enum within the test if iteration is needed.</p> <p>Do !! NOT !! remove or modify existing opcodes from this list.</p> Source code in <code>src/ethereum_test_tools/vm/opcode.py</code> <pre><code>class Opcodes(Opcode, Enum):\n\"\"\"\n    Enum containing all known opcodes.\n    Contains deprecated and not yet implemented opcodes.\n    This enum is !! NOT !! meant to be iterated over by the tests. Instead,\n    create a list with cherry-picked opcodes from this Enum within the test\n    if iteration is needed.\n    Do !! NOT !! remove or modify existing opcodes from this list.\n    \"\"\"\nSTOP = Opcode(0x00)\nADD = Opcode(0x01, popped_stack_items=2, pushed_stack_items=1)\nMUL = Opcode(0x02, popped_stack_items=2, pushed_stack_items=1)\nSUB = Opcode(0x03, popped_stack_items=2, pushed_stack_items=1)\nDIV = Opcode(0x04, popped_stack_items=2, pushed_stack_items=1)\nSDIV = Opcode(0x05, popped_stack_items=2, pushed_stack_items=1)\nMOD = Opcode(0x06, popped_stack_items=2, pushed_stack_items=1)\nSMOD = Opcode(0x07, popped_stack_items=2, pushed_stack_items=1)\nADDMOD = Opcode(0x08, popped_stack_items=3, pushed_stack_items=1)\nMULMOD = Opcode(0x09, popped_stack_items=3, pushed_stack_items=1)\nEXP = Opcode(0x0A, popped_stack_items=2, pushed_stack_items=1)\nSIGNEXTEND = Opcode(0x0B, popped_stack_items=2, pushed_stack_items=1)\nLT = Opcode(0x10, popped_stack_items=2, pushed_stack_items=1)\nGT = Opcode(0x11, popped_stack_items=2, pushed_stack_items=1)\nSLT = Opcode(0x12, popped_stack_items=2, pushed_stack_items=1)\nSGT = Opcode(0x13, popped_stack_items=2, pushed_stack_items=1)\nEQ = Opcode(0x14, popped_stack_items=2, pushed_stack_items=1)\nISZERO = Opcode(0x15, popped_stack_items=1, pushed_stack_items=1)\nAND = Opcode(0x16, popped_stack_items=2, pushed_stack_items=1)\nOR = Opcode(0x17, popped_stack_items=2, pushed_stack_items=1)\nXOR = Opcode(0x18, popped_stack_items=2, pushed_stack_items=1)\nNOT = Opcode(0x19, popped_stack_items=1, pushed_stack_items=1)\nBYTE = Opcode(0x1A, popped_stack_items=2, pushed_stack_items=1)\nSHL = Opcode(0x1B, popped_stack_items=2, pushed_stack_items=1)\nSHR = Opcode(0x1C, popped_stack_items=2, pushed_stack_items=1)\nSAR = Opcode(0x1D, popped_stack_items=2, pushed_stack_items=1)\nSHA3 = Opcode(0x20, popped_stack_items=2, pushed_stack_items=1)\nADDRESS = Opcode(0x30, pushed_stack_items=1)\nBALANCE = Opcode(0x31, popped_stack_items=1, pushed_stack_items=1)\nORIGIN = Opcode(0x32, pushed_stack_items=1)\nCALLER = Opcode(0x33, pushed_stack_items=1)\nCALLVALUE = Opcode(0x34, pushed_stack_items=1)\nCALLDATALOAD = Opcode(0x35, popped_stack_items=1, pushed_stack_items=1)\nCALLDATASIZE = Opcode(0x36, pushed_stack_items=1)\nCALLDATACOPY = Opcode(0x37, popped_stack_items=3)\nCODESIZE = Opcode(0x38, pushed_stack_items=1)\nCODECOPY = Opcode(0x39, popped_stack_items=3)\nGASPRICE = Opcode(0x3A, pushed_stack_items=1)\nEXTCODESIZE = Opcode(0x3B, popped_stack_items=1, pushed_stack_items=1)\nEXTCODECOPY = Opcode(0x3C, popped_stack_items=4)\nRETURNDATASIZE = Opcode(0x3D, pushed_stack_items=1)\nRETURNDATACOPY = Opcode(0x3E, popped_stack_items=3)\nEXTCODEHASH = Opcode(0x3F, popped_stack_items=1, pushed_stack_items=1)\nBLOCKHASH = Opcode(0x40, popped_stack_items=1, pushed_stack_items=1)\nCOINBASE = Opcode(0x41, pushed_stack_items=1)\nTIMESTAMP = Opcode(0x42, pushed_stack_items=1)\nNUMBER = Opcode(0x43, pushed_stack_items=1)\nPREVRANDAO = Opcode(0x44, pushed_stack_items=1)\nGASLIMIT = Opcode(0x45, pushed_stack_items=1)\nCHAINID = Opcode(0x46, pushed_stack_items=1)\nSELFBALANCE = Opcode(0x47, pushed_stack_items=1)\nBASEFEE = Opcode(0x48, pushed_stack_items=1)\nDATAHASH = Opcode(0x49, popped_stack_items=1, pushed_stack_items=1)\nPOP = Opcode(0x50, popped_stack_items=1)\nMLOAD = Opcode(0x51, popped_stack_items=1, pushed_stack_items=1)\nMSTORE = Opcode(0x52, popped_stack_items=2)\nMSTORE8 = Opcode(0x53, popped_stack_items=2)\nSLOAD = Opcode(0x54, popped_stack_items=1, pushed_stack_items=1)\nSSTORE = Opcode(0x55, popped_stack_items=2)\nJUMP = Opcode(0x56, popped_stack_items=1)\nJUMPI = Opcode(0x57, popped_stack_items=2)\nPC = Opcode(0x58, pushed_stack_items=1)\nMSIZE = Opcode(0x59, pushed_stack_items=1)\nGAS = Opcode(0x5A, pushed_stack_items=1)\nJUMPDEST = Opcode(0x5B)\nRJUMP = Opcode(0x5C, data_portion_length=2)\nRJUMPI = Opcode(0x5D, popped_stack_items=1, data_portion_length=2)\nCALLF = Opcode(0x5E, data_portion_length=2)\nRETF = Opcode(0x49)\nPUSH0 = Opcode(0x5F, pushed_stack_items=1)\nPUSH1 = Opcode(0x60, pushed_stack_items=1, data_portion_length=1)\nPUSH2 = Opcode(0x61, pushed_stack_items=1, data_portion_length=2)\nPUSH3 = Opcode(0x62, pushed_stack_items=1, data_portion_length=3)\nPUSH4 = Opcode(0x63, pushed_stack_items=1, data_portion_length=4)\nPUSH5 = Opcode(0x64, pushed_stack_items=1, data_portion_length=5)\nPUSH6 = Opcode(0x65, pushed_stack_items=1, data_portion_length=6)\nPUSH7 = Opcode(0x66, pushed_stack_items=1, data_portion_length=7)\nPUSH8 = Opcode(0x67, pushed_stack_items=1, data_portion_length=8)\nPUSH9 = Opcode(0x68, pushed_stack_items=1, data_portion_length=9)\nPUSH10 = Opcode(0x69, pushed_stack_items=1, data_portion_length=10)\nPUSH11 = Opcode(0x6A, pushed_stack_items=1, data_portion_length=11)\nPUSH12 = Opcode(0x6B, pushed_stack_items=1, data_portion_length=12)\nPUSH13 = Opcode(0x6C, pushed_stack_items=1, data_portion_length=13)\nPUSH14 = Opcode(0x6D, pushed_stack_items=1, data_portion_length=14)\nPUSH15 = Opcode(0x6E, pushed_stack_items=1, data_portion_length=15)\nPUSH16 = Opcode(0x6F, pushed_stack_items=1, data_portion_length=16)\nPUSH17 = Opcode(0x70, pushed_stack_items=1, data_portion_length=17)\nPUSH18 = Opcode(0x71, pushed_stack_items=1, data_portion_length=18)\nPUSH19 = Opcode(0x72, pushed_stack_items=1, data_portion_length=19)\nPUSH20 = Opcode(0x73, pushed_stack_items=1, data_portion_length=20)\nPUSH21 = Opcode(0x74, pushed_stack_items=1, data_portion_length=21)\nPUSH22 = Opcode(0x75, pushed_stack_items=1, data_portion_length=22)\nPUSH23 = Opcode(0x76, pushed_stack_items=1, data_portion_length=23)\nPUSH24 = Opcode(0x77, pushed_stack_items=1, data_portion_length=24)\nPUSH25 = Opcode(0x78, pushed_stack_items=1, data_portion_length=25)\nPUSH26 = Opcode(0x79, pushed_stack_items=1, data_portion_length=26)\nPUSH27 = Opcode(0x7A, pushed_stack_items=1, data_portion_length=27)\nPUSH28 = Opcode(0x7B, pushed_stack_items=1, data_portion_length=28)\nPUSH29 = Opcode(0x7C, pushed_stack_items=1, data_portion_length=29)\nPUSH30 = Opcode(0x7D, pushed_stack_items=1, data_portion_length=30)\nPUSH31 = Opcode(0x7E, pushed_stack_items=1, data_portion_length=31)\nPUSH32 = Opcode(0x7F, pushed_stack_items=1, data_portion_length=32)\nDUP1 = Opcode(0x80, pushed_stack_items=1, min_stack_height=1)\nDUP2 = Opcode(0x81, pushed_stack_items=1, min_stack_height=2)\nDUP3 = Opcode(0x82, pushed_stack_items=1, min_stack_height=3)\nDUP4 = Opcode(0x83, pushed_stack_items=1, min_stack_height=4)\nDUP5 = Opcode(0x84, pushed_stack_items=1, min_stack_height=5)\nDUP6 = Opcode(0x85, pushed_stack_items=1, min_stack_height=6)\nDUP7 = Opcode(0x86, pushed_stack_items=1, min_stack_height=7)\nDUP8 = Opcode(0x87, pushed_stack_items=1, min_stack_height=8)\nDUP9 = Opcode(0x88, pushed_stack_items=1, min_stack_height=9)\nDUP10 = Opcode(0x89, pushed_stack_items=1, min_stack_height=10)\nDUP11 = Opcode(0x8A, pushed_stack_items=1, min_stack_height=11)\nDUP12 = Opcode(0x8B, pushed_stack_items=1, min_stack_height=12)\nDUP13 = Opcode(0x8C, pushed_stack_items=1, min_stack_height=13)\nDUP14 = Opcode(0x8D, pushed_stack_items=1, min_stack_height=14)\nDUP15 = Opcode(0x8E, pushed_stack_items=1, min_stack_height=15)\nDUP16 = Opcode(0x8F, pushed_stack_items=1, min_stack_height=16)\nSWAP1 = Opcode(0x90, min_stack_height=2)\nSWAP2 = Opcode(0x91, min_stack_height=3)\nSWAP3 = Opcode(0x92, min_stack_height=4)\nSWAP4 = Opcode(0x93, min_stack_height=5)\nSWAP5 = Opcode(0x94, min_stack_height=6)\nSWAP6 = Opcode(0x95, min_stack_height=7)\nSWAP7 = Opcode(0x96, min_stack_height=8)\nSWAP8 = Opcode(0x97, min_stack_height=9)\nSWAP9 = Opcode(0x98, min_stack_height=10)\nSWAP10 = Opcode(0x99, min_stack_height=11)\nSWAP11 = Opcode(0x9A, min_stack_height=12)\nSWAP12 = Opcode(0x9B, min_stack_height=13)\nSWAP13 = Opcode(0x9C, min_stack_height=14)\nSWAP14 = Opcode(0x9D, min_stack_height=15)\nSWAP15 = Opcode(0x9E, min_stack_height=16)\nSWAP16 = Opcode(0x9F, min_stack_height=17)\nLOG0 = Opcode(0xA0, popped_stack_items=2)\nLOG1 = Opcode(0xA1, popped_stack_items=3)\nLOG2 = Opcode(0xA2, popped_stack_items=4)\nLOG3 = Opcode(0xA3, popped_stack_items=5)\nLOG4 = Opcode(0xA4, popped_stack_items=6)\nTLOAD = Opcode(0xB3, popped_stack_items=1, pushed_stack_items=1)\nTSTORE = Opcode(0xB4, popped_stack_items=2)\nCREATE = Opcode(0xF0, popped_stack_items=3, pushed_stack_items=1)\nCALL = Opcode(0xF1, popped_stack_items=7, pushed_stack_items=1)\nCALLCODE = Opcode(0xF2, popped_stack_items=7, pushed_stack_items=1)\nRETURN = Opcode(0xF3, popped_stack_items=2)\nDELEGATECALL = Opcode(0xF4, popped_stack_items=6, pushed_stack_items=1)\nCREATE2 = Opcode(0xF5, popped_stack_items=4, pushed_stack_items=1)\nSTATICCALL = Opcode(0xFA, popped_stack_items=6, pushed_stack_items=1)\nREVERT = Opcode(0xFD, popped_stack_items=2)\nINVALID = Opcode(0xFE)\nSELFDESTRUCT = Opcode(0xFF, popped_stack_items=1)\nSENDALL = Opcode(0xFF, popped_stack_items=1)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ReferenceSpec","title":"<code>ReferenceSpec</code>","text":"<p>Reference Specification Description Abstract Class.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>class ReferenceSpec:\n\"\"\"\n    Reference Specification Description Abstract Class.\n    \"\"\"\n@abstractmethod\ndef name(self) -&gt; str:\n\"\"\"\n        Returns the name of the spec.\n        \"\"\"\npass\n@abstractmethod\ndef has_known_version(self) -&gt; bool:\n\"\"\"\n        Returns true if the reference spec object is hard-coded with a latest\n        known version.\n        \"\"\"\npass\n@abstractmethod\ndef known_version(self) -&gt; str:\n\"\"\"\n        Returns the latest known version in the reference.\n        \"\"\"\npass\n@abstractmethod\ndef latest_version(self) -&gt; str:\n\"\"\"\n        Returns a digest that points to the latest version of the spec.\n        \"\"\"\npass\n@abstractmethod\ndef is_outdated(self) -&gt; bool:\n\"\"\"\n        Checks whether the reference specification has been updated since the\n        test was last updated.\n        \"\"\"\npass\n@abstractmethod\ndef write_info(self, info: Dict[str, str]):\n\"\"\"\n        Writes info about the reference specification used into the output\n        fixture.\n        \"\"\"\npass\n@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n        Checks whether the module's dict contains required reference spec\n        information.\n        \"\"\"\npass\n@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n        Parses the module's dict into a reference spec.\n        \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.has_known_version","title":"<code>has_known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns true if the reference spec object is hard-coded with a latest known version.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef has_known_version(self) -&gt; bool:\n\"\"\"\n    Returns true if the reference spec object is hard-coded with a latest\n    known version.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.is_outdated","title":"<code>is_outdated()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the reference specification has been updated since the test was last updated.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef is_outdated(self) -&gt; bool:\n\"\"\"\n    Checks whether the reference specification has been updated since the\n    test was last updated.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.known_version","title":"<code>known_version()</code>  <code>abstractmethod</code>","text":"<p>Returns the latest known version in the reference.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef known_version(self) -&gt; str:\n\"\"\"\n    Returns the latest known version in the reference.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.latest_version","title":"<code>latest_version()</code>  <code>abstractmethod</code>","text":"<p>Returns a digest that points to the latest version of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef latest_version(self) -&gt; str:\n\"\"\"\n    Returns a digest that points to the latest version of the spec.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Returns the name of the spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n\"\"\"\n    Returns the name of the spec.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parse_from_module","title":"<code>parse_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Parses the module's dict into a reference spec.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_from_module(module_dict: Dict[str, Any]) -&gt; \"ReferenceSpec\":\n\"\"\"\n    Parses the module's dict into a reference spec.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.parseable_from_module","title":"<code>parseable_from_module(module_dict)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Checks whether the module's dict contains required reference spec information.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parseable_from_module(module_dict: Dict[str, Any]) -&gt; bool:\n\"\"\"\n    Checks whether the module's dict contains required reference spec\n    information.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.reference_spec.reference_spec.ReferenceSpec.write_info","title":"<code>write_info(info)</code>  <code>abstractmethod</code>","text":"<p>Writes info about the reference specification used into the output fixture.</p> Source code in <code>src/ethereum_test_tools/reference_spec/reference_spec.py</code> <pre><code>@abstractmethod\ndef write_info(self, info: Dict[str, str]):\n\"\"\"\n    Writes info about the reference specification used into the output\n    fixture.\n    \"\"\"\npass\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.StateTest","title":"<code>StateTest</code>  <code>dataclass</code>","text":"<p>         Bases: <code>BaseTest</code></p> <p>Filler type that tests transactions over the period of a single block.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@dataclass(kw_only=True)\nclass StateTest(BaseTest):\n\"\"\"\n    Filler type that tests transactions over the period of a single block.\n    \"\"\"\nenv: Environment\npre: Mapping[str, Account]\npost: Mapping[str, Account]\ntxs: List[Transaction]\ntag: str = \"\"\n@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n        Returns the parameter name used to identify this filler in a test.\n        \"\"\"\nreturn \"state_test\"\ndef make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n        Create a genesis block from the state test definition.\n        \"\"\"\nenv = self.env.set_fork_requirements(fork)\ngenesis = FixtureHeader(\nparent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\ncoinbase=\"0x0000000000000000000000000000000000000000\",\nstate_root=t8n.calc_state_root(\nto_json(self.pre),\nfork,\n),\ntransactions_root=EmptyTrieRoot,\nreceipt_root=EmptyTrieRoot,\nbloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\ndifficulty=0x20000 if env.difficulty is None else env.difficulty,\nnumber=env.number - 1,\ngas_limit=env.gas_limit,\ngas_used=0,\ntimestamp=0,\nextra_data=\"0x00\",\nmix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nnonce=\"0x0000000000000000\",\nbase_fee=env.base_fee,\nexcess_data_gas=env.excess_data_gas,\nwithdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\nif env.withdrawals is not None\nelse None,\n)\n(genesis_rlp, genesis.hash) = b11r.build(\nheader=genesis.to_geth_dict(),\ntxs=\"\",\nommers=[],\nwithdrawals=env.withdrawals,\n)\nreturn genesis_rlp, genesis\ndef make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n        Create a block from the state test definition.\n        Performs checks against the expected behavior of the test.\n        Raises exception on invalid test behavior.\n        \"\"\"\nenv = self.env.apply_new_parent(genesis)\nenv = env.set_fork_requirements(fork)\n(alloc, result, txs_rlp) = t8n.evaluate(\nalloc=to_json(self.pre),\ntxs=to_json(self.txs),\nenv=to_json(env),\nfork=fork,\nchain_id=chain_id,\nreward=fork.get_reward(env.number, env.timestamp),\neips=eips,\n)\nrejected_txs = verify_transactions(self.txs, result)\nif len(rejected_txs) &gt; 0:\nraise Exception(\n\"one or more transactions in `StateTest` are \"\n+ \"intrinsically invalid, which are not allowed. \"\n+ \"Use `BlockchainTest` to verify rejection of blocks \"\n+ \"that include invalid transactions.\"\n)\ntry:\nverify_post_alloc(self.post, alloc)\nexcept Exception as e:\nprint_traces(traces=t8n.get_traces())\nraise e\nheader = FixtureHeader.from_dict(\nresult\n| {\n\"parentHash\": genesis.hash,\n\"miner\": env.coinbase,\n\"transactionsRoot\": result.get(\"txRoot\"),\n\"difficulty\": str_or_none(\nenv.difficulty, result.get(\"currentDifficulty\")\n),\n\"number\": str(env.number),\n\"gasLimit\": str(env.gas_limit),\n\"timestamp\": str(env.timestamp),\n\"extraData\": \"0x00\",\n\"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n\"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n\"nonce\": \"0x0000000000000000\",\n\"baseFeePerGas\": result.get(\"currentBaseFee\"),\n\"excessDataGas\": result.get(\"currentExcessDataGas\"),\n}\n)\nblock, head = b11r.build(\nheader=header.to_geth_dict(),\ntxs=txs_rlp,\nommers=[],\nwithdrawals=to_json_or_none(env.withdrawals),\n)\nheader.hash = head\nreturn (\n[\nFixtureBlock(\nrlp=block,\nblock_header=header,\ntxs=self.txs if self.txs is not None else [],\nommers=[],\nwithdrawals=env.withdrawals,\n)\n],\nhead,\nalloc,\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_blocks","title":"<code>make_blocks(b11r, t8n, genesis, fork, chain_id=1, eips=None)</code>","text":"<p>Create a block from the state test definition. Performs checks against the expected behavior of the test. Raises exception on invalid test behavior.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_blocks(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\ngenesis: FixtureHeader,\nfork: Fork,\nchain_id=1,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[List[FixtureBlock], str, Dict[str, Any]]:\n\"\"\"\n    Create a block from the state test definition.\n    Performs checks against the expected behavior of the test.\n    Raises exception on invalid test behavior.\n    \"\"\"\nenv = self.env.apply_new_parent(genesis)\nenv = env.set_fork_requirements(fork)\n(alloc, result, txs_rlp) = t8n.evaluate(\nalloc=to_json(self.pre),\ntxs=to_json(self.txs),\nenv=to_json(env),\nfork=fork,\nchain_id=chain_id,\nreward=fork.get_reward(env.number, env.timestamp),\neips=eips,\n)\nrejected_txs = verify_transactions(self.txs, result)\nif len(rejected_txs) &gt; 0:\nraise Exception(\n\"one or more transactions in `StateTest` are \"\n+ \"intrinsically invalid, which are not allowed. \"\n+ \"Use `BlockchainTest` to verify rejection of blocks \"\n+ \"that include invalid transactions.\"\n)\ntry:\nverify_post_alloc(self.post, alloc)\nexcept Exception as e:\nprint_traces(traces=t8n.get_traces())\nraise e\nheader = FixtureHeader.from_dict(\nresult\n| {\n\"parentHash\": genesis.hash,\n\"miner\": env.coinbase,\n\"transactionsRoot\": result.get(\"txRoot\"),\n\"difficulty\": str_or_none(\nenv.difficulty, result.get(\"currentDifficulty\")\n),\n\"number\": str(env.number),\n\"gasLimit\": str(env.gas_limit),\n\"timestamp\": str(env.timestamp),\n\"extraData\": \"0x00\",\n\"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\n\"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\n\"nonce\": \"0x0000000000000000\",\n\"baseFeePerGas\": result.get(\"currentBaseFee\"),\n\"excessDataGas\": result.get(\"currentExcessDataGas\"),\n}\n)\nblock, head = b11r.build(\nheader=header.to_geth_dict(),\ntxs=txs_rlp,\nommers=[],\nwithdrawals=to_json_or_none(env.withdrawals),\n)\nheader.hash = head\nreturn (\n[\nFixtureBlock(\nrlp=block,\nblock_header=header,\ntxs=self.txs if self.txs is not None else [],\nommers=[],\nwithdrawals=env.withdrawals,\n)\n],\nhead,\nalloc,\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.make_genesis","title":"<code>make_genesis(b11r, t8n, fork)</code>","text":"<p>Create a genesis block from the state test definition.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>def make_genesis(\nself,\nb11r: BlockBuilder,\nt8n: TransitionTool,\nfork: Fork,\n) -&gt; Tuple[str, FixtureHeader]:\n\"\"\"\n    Create a genesis block from the state test definition.\n    \"\"\"\nenv = self.env.set_fork_requirements(fork)\ngenesis = FixtureHeader(\nparent_hash=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nommers_hash=\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",  # noqa: E501\ncoinbase=\"0x0000000000000000000000000000000000000000\",\nstate_root=t8n.calc_state_root(\nto_json(self.pre),\nfork,\n),\ntransactions_root=EmptyTrieRoot,\nreceipt_root=EmptyTrieRoot,\nbloom=\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\ndifficulty=0x20000 if env.difficulty is None else env.difficulty,\nnumber=env.number - 1,\ngas_limit=env.gas_limit,\ngas_used=0,\ntimestamp=0,\nextra_data=\"0x00\",\nmix_digest=\"0x0000000000000000000000000000000000000000000000000000000000000000\",  # noqa: E501\nnonce=\"0x0000000000000000\",\nbase_fee=env.base_fee,\nexcess_data_gas=env.excess_data_gas,\nwithdrawals_root=t8n.calc_withdrawals_root(env.withdrawals, fork)\nif env.withdrawals is not None\nelse None,\n)\n(genesis_rlp, genesis.hash) = b11r.build(\nheader=genesis.to_geth_dict(),\ntxs=\"\",\nommers=[],\nwithdrawals=env.withdrawals,\n)\nreturn genesis_rlp, genesis\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.spec.state_test.StateTest.pytest_parameter_name","title":"<code>pytest_parameter_name()</code>  <code>classmethod</code>","text":"<p>Returns the parameter name used to identify this filler in a test.</p> Source code in <code>src/ethereum_test_tools/spec/state_test.py</code> <pre><code>@classmethod\ndef pytest_parameter_name(cls) -&gt; str:\n\"\"\"\n    Returns the parameter name used to identify this filler in a test.\n    \"\"\"\nreturn \"state_test\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Transaction","title":"<code>Transaction</code>  <code>dataclass</code>","text":"<p>Generic object that can represent all Ethereum transaction types.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Transaction:\n\"\"\"\n    Generic object that can represent all Ethereum transaction types.\n    \"\"\"\nty: Optional[int] = None\n\"\"\"\n    Transaction type value.\n    \"\"\"\nchain_id: int = 1\nnonce: int = 0\nto: Optional[str] = AddrAA\nvalue: int = 0\ndata: bytes | str | Code = bytes()\ngas_limit: int = 21000\naccess_list: Optional[List[AccessList]] = None\ngas_price: Optional[int] = None\nmax_fee_per_gas: Optional[int] = None\nmax_priority_fee_per_gas: Optional[int] = None\nmax_fee_per_data_gas: Optional[int] = None\nblob_versioned_hashes: Optional[Sequence[str | bytes]] = None\nblob_kzgs: Optional[Sequence[bytes]] = None\nblobs: Optional[Sequence[Sequence[int]]] = None\nkzg_aggregated_proof: Optional[str | bytes] = None\nsignature: Optional[Tuple[str, str, str]] = None\nsecret_key: Optional[str] = None\nprotected: bool = True\nerror: Optional[str] = None\nclass InvalidFeePayment(Exception):\n\"\"\"\n        Transaction described more than one fee payment type.\n        \"\"\"\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\n\"only one type of fee payment field can be used in a single tx\"\n)\nclass InvalidSignaturePrivateKey(Exception):\n\"\"\"\n        Transaction describes both the signature and private key of\n        source account.\n        \"\"\"\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn \"can't define both 'signature' and 'private_key'\"\ndef __post_init__(self) -&gt; None:\n\"\"\"\n        Ensures the transaction has no conflicting properties.\n        \"\"\"\nif (\nself.gas_price is not None\nand self.max_fee_per_gas is not None\nand self.max_priority_fee_per_gas is not None\n):\nraise Transaction.InvalidFeePayment()\nif (\nself.gas_price is None\nand self.max_fee_per_gas is None\nand self.max_priority_fee_per_gas is None\n):\nself.gas_price = 10\nif self.signature is not None and self.secret_key is not None:\nraise Transaction.InvalidSignaturePrivateKey()\nif self.signature is None and self.secret_key is None:\nself.secret_key = TestPrivateKey\nif self.ty is None:\n# Try to deduce transaction type from included fields\nif self.max_fee_per_data_gas is not None:\nself.ty = 5\nelif self.max_fee_per_gas is not None:\nself.ty = 2\nelif self.access_list is not None:\nself.ty = 1\nelse:\nself.ty = 0\ndef with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with an added error.\n        \"\"\"\ntx = copy(self)\ntx.error = error\nreturn tx\ndef with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n        Create a copy of the transaction with a modified nonce.\n        \"\"\"\ntx = copy(self)\ntx.nonce = nonce\nreturn tx\ndef with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n        Create a deepcopy of the transaction with modified fields.\n        \"\"\"\ntx = deepcopy(self)\nfor key, value in kwargs.items():\nif hasattr(tx, key):\nsetattr(tx, key, value)\nelse:\nraise ValueError(f\"Invalid field '{key}' for Transaction\")\nreturn tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.ty","title":"<code>ty: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transaction type value.</p>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment","title":"<code>InvalidFeePayment</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction described more than one fee payment type.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidFeePayment(Exception):\n\"\"\"\n    Transaction described more than one fee payment type.\n    \"\"\"\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\n\"only one type of fee payment field can be used in a single tx\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidFeePayment.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn (\n\"only one type of fee payment field can be used in a single tx\"\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey","title":"<code>InvalidSignaturePrivateKey</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Transaction describes both the signature and private key of source account.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>class InvalidSignaturePrivateKey(Exception):\n\"\"\"\n    Transaction describes both the signature and private key of\n    source account.\n    \"\"\"\ndef __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.InvalidSignaturePrivateKey.__str__","title":"<code>__str__()</code>","text":"<p>Print exception string</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __str__(self):\n\"\"\"Print exception string\"\"\"\nreturn \"can't define both 'signature' and 'private_key'\"\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures the transaction has no conflicting properties.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"\n    Ensures the transaction has no conflicting properties.\n    \"\"\"\nif (\nself.gas_price is not None\nand self.max_fee_per_gas is not None\nand self.max_priority_fee_per_gas is not None\n):\nraise Transaction.InvalidFeePayment()\nif (\nself.gas_price is None\nand self.max_fee_per_gas is None\nand self.max_priority_fee_per_gas is None\n):\nself.gas_price = 10\nif self.signature is not None and self.secret_key is not None:\nraise Transaction.InvalidSignaturePrivateKey()\nif self.signature is None and self.secret_key is None:\nself.secret_key = TestPrivateKey\nif self.ty is None:\n# Try to deduce transaction type from included fields\nif self.max_fee_per_data_gas is not None:\nself.ty = 5\nelif self.max_fee_per_gas is not None:\nself.ty = 2\nelif self.access_list is not None:\nself.ty = 1\nelse:\nself.ty = 0\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_error","title":"<code>with_error(error)</code>","text":"<p>Create a copy of the transaction with an added error.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_error(self, error: str) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with an added error.\n    \"\"\"\ntx = copy(self)\ntx.error = error\nreturn tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_fields","title":"<code>with_fields(**kwargs)</code>","text":"<p>Create a deepcopy of the transaction with modified fields.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_fields(self, **kwargs) -&gt; \"Transaction\":\n\"\"\"\n    Create a deepcopy of the transaction with modified fields.\n    \"\"\"\ntx = deepcopy(self)\nfor key, value in kwargs.items():\nif hasattr(tx, key):\nsetattr(tx, key, value)\nelse:\nraise ValueError(f\"Invalid field '{key}' for Transaction\")\nreturn tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.common.types.Transaction.with_nonce","title":"<code>with_nonce(nonce)</code>","text":"<p>Create a copy of the transaction with a modified nonce.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>def with_nonce(self, nonce: int) -&gt; \"Transaction\":\n\"\"\"\n    Create a copy of the transaction with a modified nonce.\n    \"\"\"\ntx = copy(self)\ntx.nonce = nonce\nreturn tx\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Withdrawal","title":"<code>Withdrawal</code>  <code>dataclass</code>","text":"<p>Structure to represent a single withdrawal of a validator's balance from the beacon chain.</p> Source code in <code>src/ethereum_test_tools/common/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass Withdrawal:\n\"\"\"\n    Structure to represent a single withdrawal of a validator's balance from\n    the beacon chain.\n    \"\"\"\nindex: int\nvalidator: int\naddress: str\namount: int\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.Yul","title":"<code>Yul</code>","text":"<p>         Bases: <code>Code</code></p> <p>Yul compiler. Compiles Yul source code into bytecode.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>class Yul(Code):\n\"\"\"\n    Yul compiler.\n    Compiles Yul source code into bytecode.\n    \"\"\"\nsource: str\ncompiled: Optional[bytes] = None\ndef __init__(self, source: str):\nself.source = source\ndef assemble(self) -&gt; bytes:\n\"\"\"\n        Assembles using `solc --assemble`.\n        \"\"\"\nif not self.compiled:\nresult = run(\nSOLC_ARGS,\ninput=str.encode(self.source),\nstdout=PIPE,\nstderr=PIPE,\n)\nif result.returncode != 0:\nstderr_lines = result.stderr.decode().split(\"\\n\")\nstderr_message = \"\\n\".join(\nline.strip() for line in stderr_lines\n)\nraise Exception(\nf\"failed to compile yul source:\\n{stderr_message[7:]}\"\n)\nlines = result.stdout.decode().split(\"\\n\")\nhex_str = lines[lines.index(\"Binary representation:\") + 1]\nself.compiled = bytes.fromhex(hex_str)\nreturn self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.code.yul.Yul.assemble","title":"<code>assemble()</code>","text":"<p>Assembles using <code>solc --assemble</code>.</p> Source code in <code>src/ethereum_test_tools/code/yul.py</code> <pre><code>def assemble(self) -&gt; bytes:\n\"\"\"\n    Assembles using `solc --assemble`.\n    \"\"\"\nif not self.compiled:\nresult = run(\nSOLC_ARGS,\ninput=str.encode(self.source),\nstdout=PIPE,\nstderr=PIPE,\n)\nif result.returncode != 0:\nstderr_lines = result.stderr.decode().split(\"\\n\")\nstderr_message = \"\\n\".join(\nline.strip() for line in stderr_lines\n)\nraise Exception(\nf\"failed to compile yul source:\\n{stderr_message[7:]}\"\n)\nlines = result.stdout.decode().split(\"\\n\")\nhex_str = lines[lines.index(\"Binary representation:\") + 1]\nself.compiled = bytes.fromhex(hex_str)\nreturn self.compiled\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.ceiling_division","title":"<code>ceiling_division(a, b)</code>","text":"<p>Calculates the ceil without using floating point. Used by many of the EVM's formulas</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def ceiling_division(a: int, b: int) -&gt; int:\n\"\"\"\n    Calculates the ceil without using floating point.\n    Used by many of the EVM's formulas\n    \"\"\"\nreturn -(a // -b)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create2_address","title":"<code>compute_create2_address(address, salt, initcode)</code>","text":"<p>Compute address of the resulting contract created using the <code>CREATE2</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create2_address(\naddress: str | int, salt: int, initcode: bytes\n) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using the `CREATE2`\n    opcode.\n    \"\"\"\nff = bytes([0xFF])\nif type(address) is str:\nif address.startswith(\"0x\"):\naddress = address[2:]\naddress_bytes = bytes.fromhex(address)\nelif type(address) is int:\naddress_bytes = address.to_bytes(length=20, byteorder=\"big\")\nsalt_bytes = salt.to_bytes(length=32, byteorder=\"big\")\ninitcode_hash = keccak256(initcode)\nhash = keccak256(ff + address_bytes + salt_bytes + initcode_hash)\nreturn \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.compute_create_address","title":"<code>compute_create_address(address, nonce)</code>","text":"<p>Compute address of the resulting contract created using a transaction or the <code>CREATE</code> opcode.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def compute_create_address(address: str | int, nonce: int) -&gt; str:\n\"\"\"\n    Compute address of the resulting contract created using a transaction\n    or the `CREATE` opcode.\n    \"\"\"\nif type(address) is str:\nif address.startswith(\"0x\"):\naddress = address[2:]\naddress_bytes = bytes.fromhex(address)\nelif type(address) is int:\naddress_bytes = address.to_bytes(length=20, byteorder=\"big\")\nif nonce == 0:\nnonce_bytes = bytes()\nelse:\nnonce_bytes = nonce.to_bytes(length=1, byteorder=\"big\")\nhash = keccak256(encode([address_bytes, nonce_bytes]))\nreturn \"0x\" + hash[-20:].hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.eip_2028_transaction_data_cost","title":"<code>eip_2028_transaction_data_cost(data)</code>","text":"<p>Calculates the cost of a given data as part of a transaction, based on the costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def eip_2028_transaction_data_cost(data: bytes | str) -&gt; int:\n\"\"\"\n    Calculates the cost of a given data as part of a transaction, based on the\n    costs specified in EIP-2028: https://eips.ethereum.org/EIPS/eip-2028\n    \"\"\"\nif type(data) is str:\nif data.startswith(\"0x\"):\ndata = data[2:]\ndata = bytes.fromhex(data)\ncost = 0\nfor b in data:\nif b == 0:\ncost += 4\nelse:\ncost += 16\nreturn cost\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.fill_test","title":"<code>fill_test(t8n, b11r, test_spec, fork, engine, spec, eips=None)</code>","text":"<p>Fills fixtures for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/fill.py</code> <pre><code>def fill_test(\nt8n: TransitionTool,\nb11r: BlockBuilder,\ntest_spec: BaseTest,\nfork: Fork,\nengine: str,\nspec: ReferenceSpec | None,\neips: Optional[List[int]] = None,\n) -&gt; Fixture:\n\"\"\"\n    Fills fixtures for the specified fork.\n    \"\"\"\nt8n.reset_traces()\ngenesis_rlp, genesis = test_spec.make_genesis(b11r, t8n, fork)\n(blocks, head, alloc) = test_spec.make_blocks(\nb11r,\nt8n,\ngenesis,\nfork,\neips=eips,\n)\nfork_name = fork.name()\nfixture = Fixture(\nblocks=blocks,\ngenesis=genesis,\ngenesis_rlp=genesis_rlp,\nhead=head,\nfork=\"+\".join([fork_name] + [str(eip) for eip in eips])\nif eips is not None\nelse fork_name,\npre_state=copy(test_spec.pre),\npost_state=alloc_to_accounts(alloc),\nseal_engine=engine,\nname=test_spec.tag,\n)\nfixture.fill_info(t8n, b11r, spec)\nreturn fixture\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from","title":"<code>test_from(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from(\nfork: Fork,\neips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\nreturn _filler_decorator(forks=forks_from(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_from_until","title":"<code>test_from_until(fork_from, fork_until, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it for all forks after the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_from_until(\nfork_from: Fork,\nfork_until: Fork,\neips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it for all forks after the\n    specified fork.\n    \"\"\"\nreturn _filler_decorator(\nforks=forks_from_until(fork_from, fork_until), eips=eips\n)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.test_only","title":"<code>test_only(fork, eips=None)</code>","text":"<p>Decorator that takes a test generator and fills it only for the specified fork.</p> Source code in <code>src/ethereum_test_tools/filling/decorators.py</code> <pre><code>def test_only(\nfork: Fork,\neips: Optional[List[int]] = None,\n) -&gt; Callable[[TestSpec], DecoratedFillerType]:\n\"\"\"\n    Decorator that takes a test generator and fills it only for the specified\n    fork.\n    \"\"\"\nreturn _filler_decorator(forks=fork_only(fork), eips=eips)\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_address","title":"<code>to_address(input)</code>","text":"<p>Converts an int or str into proper address 20-byte hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_address(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper address 20-byte hex string.\n    \"\"\"\nif type(input) is str:\n# Convert to int\ninput = int(input, 0)\nif type(input) is int:\nreturn \"0x\" + input.to_bytes(20, \"big\").hex()\nraise Exception(\"invalid type to convert to account address\")\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash","title":"<code>to_hash(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash hex string.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash(input: int | str) -&gt; str:\n\"\"\"\n    Converts an int or str into proper 32-byte hash hex string.\n    \"\"\"\nreturn \"0x\" + to_hash_bytes(input).hex()\n</code></pre>"},{"location":"library/ethereum_test_tools/#ethereum_test_tools.to_hash_bytes","title":"<code>to_hash_bytes(input)</code>","text":"<p>Converts an int or str into proper 32-byte hash.</p> Source code in <code>src/ethereum_test_tools/common/helpers.py</code> <pre><code>def to_hash_bytes(input: int | str) -&gt; bytes:\n\"\"\"\n    Converts an int or str into proper 32-byte hash.\n    \"\"\"\nif type(input) is str:\n# Convert to int\ninput = int(input, 0)\nif type(input) is int:\nreturn input.to_bytes(32, \"big\")\nraise Exception(\"invalid type to convert to hash\")\n</code></pre>"},{"location":"library/evm_block_builder/","title":"EVM Block Builder Package","text":"<p>Python wrapper for the <code>evm b11r</code> tool.</p>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder","title":"<code>BlockBuilder</code>","text":"<p>Generic Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class BlockBuilder:\n\"\"\"\n    Generic Block builder frontend.\n    \"\"\"\n@abstractmethod\ndef build(\nself,\nheader: Any,\ntxs: Any,\nommers: Any,\nwithdrawals: Optional[Any] = None,\nclique: Optional[Any] = None,\nethash: bool = False,\nethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n        Build a block with specified parameters and return RLP and hash\n        \"\"\"\npass\n@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to build the block\n        \"\"\"\npass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>  <code>abstractmethod</code>","text":"<p>Build a block with specified parameters and return RLP and hash</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef build(\nself,\nheader: Any,\ntxs: Any,\nommers: Any,\nwithdrawals: Optional[Any] = None,\nclique: Optional[Any] = None,\nethash: bool = False,\nethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Build a block with specified parameters and return RLP and hash\n    \"\"\"\npass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.BlockBuilder.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to build the block</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to build the block\n    \"\"\"\npass\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder","title":"<code>EvmBlockBuilder</code>","text":"<p>         Bases: <code>BlockBuilder</code></p> <p>Go-ethereum <code>evm</code> Block builder frontend.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>class EvmBlockBuilder(BlockBuilder):\n\"\"\"\n    Go-ethereum `evm` Block builder frontend.\n    \"\"\"\nbinary: Path\ncached_version: Optional[str] = None\ndef __init__(self, binary: Optional[Path] = None):\nif binary is None:\nwhich_path = which(\"evm\")\nif which_path is not None:\nbinary = Path(which_path)\nif binary is None or not binary.exists():\nraise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n)\nself.binary = binary\ndef build(\nself,\nheader: Any,\ntxs: Any,\nommers: Any,\nwithdrawals: Optional[Any] = None,\nclique: Optional[Any] = None,\nethash: bool = False,\nethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n        Executes `evm b11r` with the specified arguments.\n        \"\"\"\nargs = [\nstr(self.binary),\n\"b11r\",\n\"--input.header=stdin\",\n\"--input.txs=stdin\",\n\"--input.ommers=stdin\",\n\"--seal.clique=stdin\",\n\"--output.block=stdout\",\n\"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n]\nif ethash:\nargs.append(\"--seal.ethash\")\nargs.append(\"--seal.ethash.mode=\" + ethash_mode)\nstdin = {\n\"header\": header,\n\"txs\": txs,\n\"uncles\": ommers,\n\"clique\": clique,\n}\nif withdrawals is not None:\nstdin[\"withdrawals\"] = withdrawals\nresult = subprocess.run(\nargs,\ninput=str.encode(json.dumps(stdin)),\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\"failed to build\")\noutput = json.loads(result.stdout)\nif \"rlp\" not in output or \"hash\" not in output:\nException(\"malformed result\")\nreturn (output[\"rlp\"], output[\"hash\"])\ndef version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\nif self.cached_version is None:\nresult = subprocess.run(\n[str(self.binary), \"-v\"],\nstdout=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\n\"failed to evaluate: \" + result.stderr.decode()\n)\nself.cached_version = result.stdout.decode().strip()\nreturn self.cached_version\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.build","title":"<code>build(header, txs, ommers, withdrawals=None, clique=None, ethash=False, ethash_mode='normal')</code>","text":"<p>Executes <code>evm b11r</code> with the specified arguments.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def build(\nself,\nheader: Any,\ntxs: Any,\nommers: Any,\nwithdrawals: Optional[Any] = None,\nclique: Optional[Any] = None,\nethash: bool = False,\nethash_mode: str = \"normal\",\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Executes `evm b11r` with the specified arguments.\n    \"\"\"\nargs = [\nstr(self.binary),\n\"b11r\",\n\"--input.header=stdin\",\n\"--input.txs=stdin\",\n\"--input.ommers=stdin\",\n\"--seal.clique=stdin\",\n\"--output.block=stdout\",\n\"--input.withdrawals=stdin\" if withdrawals is not None else \"\",\n]\nif ethash:\nargs.append(\"--seal.ethash\")\nargs.append(\"--seal.ethash.mode=\" + ethash_mode)\nstdin = {\n\"header\": header,\n\"txs\": txs,\n\"uncles\": ommers,\n\"clique\": clique,\n}\nif withdrawals is not None:\nstdin[\"withdrawals\"] = withdrawals\nresult = subprocess.run(\nargs,\ninput=str.encode(json.dumps(stdin)),\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\"failed to build\")\noutput = json.loads(result.stdout)\nif \"rlp\" not in output or \"hash\" not in output:\nException(\"malformed result\")\nreturn (output[\"rlp\"], output[\"hash\"])\n</code></pre>"},{"location":"library/evm_block_builder/#evm_block_builder.EvmBlockBuilder.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_block_builder/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\nif self.cached_version is None:\nresult = subprocess.run(\n[str(self.binary), \"-v\"],\nstdout=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\n\"failed to evaluate: \" + result.stderr.decode()\n)\nself.cached_version = result.stdout.decode().strip()\nreturn self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/","title":"EVM Transition Tool Package","text":"<p>Python wrapper for the <code>evm t8n</code> tool.</p>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool","title":"<code>EvmTransitionTool</code>","text":"<p>         Bases: <code>TransitionTool</code></p> <p>Go-ethereum <code>evm</code> Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class EvmTransitionTool(TransitionTool):\n\"\"\"\n    Go-ethereum `evm` Transition tool frontend.\n    \"\"\"\nbinary: Path\ncached_version: Optional[str] = None\ntrace: bool\ndef __init__(\nself,\nbinary: Optional[Path] = None,\ntrace: bool = False,\n):\nif binary is None:\nwhich_path = which(\"evm\")\nif which_path is not None:\nbinary = Path(which_path)\nif binary is None or not binary.exists():\nraise Exception(\n\"\"\"`evm` binary executable is not accessible, please refer to\n                https://github.com/ethereum/go-ethereum on how to compile and\n                install the full suite of utilities including the `evm` tool\"\"\"\n)\nself.binary = binary\nself.trace = trace\ndef evaluate(\nself,\nalloc: Any,\ntxs: Any,\nenv: Any,\nfork: Fork,\nchain_id: int = 1,\nreward: int = 0,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Executes `evm t8n` with the specified arguments.\n        \"\"\"\nfork_name = fork.name()\nif eips is not None:\nfork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\ntemp_dir = tempfile.TemporaryDirectory()\nargs = [\nstr(self.binary),\n\"t8n\",\n\"--input.alloc=stdin\",\n\"--input.txs=stdin\",\n\"--input.env=stdin\",\n\"--output.result=stdout\",\n\"--output.alloc=stdout\",\n\"--output.body=txs.rlp\",\nf\"--output.basedir={temp_dir.name}\",\nf\"--state.fork={fork_name}\",\nf\"--state.chainid={chain_id}\",\nf\"--state.reward={reward}\",\n]\nif self.trace:\nargs.append(\"--trace\")\nstdin = {\n\"alloc\": alloc,\n\"txs\": txs,\n\"env\": env,\n}\nencoded_input = str.encode(json.dumps(stdin))\nresult = subprocess.run(\nargs,\ninput=encoded_input,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\"failed to evaluate: \" + result.stderr.decode())\noutput = json.loads(result.stdout)\nif \"alloc\" not in output or \"result\" not in output:\nraise Exception(\"malformed result\")\nwith open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\ntxs_rlp = txs_rlp_file.read().strip('\"')\nif self.trace:\nreceipts: List[Any] = output[\"result\"][\"receipts\"]\ntraces: List[List[Dict]] = []\nfor i, r in enumerate(receipts):\nh = r[\"transactionHash\"]\ntrace_file_name = f\"trace-{i}-{h}.jsonl\"\nwith open(\nos.path.join(temp_dir.name, trace_file_name), \"r\"\n) as trace_file:\ntx_traces: List[Dict] = []\nfor trace_line in trace_file.readlines():\ntx_traces.append(json.loads(trace_line))\ntraces.append(tx_traces)\nself.append_traces(traces)\ntemp_dir.cleanup()\nreturn (output[\"alloc\"], output[\"result\"], txs_rlp)\ndef version(self) -&gt; str:\n\"\"\"\n        Gets `evm` binary version.\n        \"\"\"\nif self.cached_version is None:\nresult = subprocess.run(\n[str(self.binary), \"-v\"],\nstdout=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\n\"failed to evaluate: \" + result.stderr.decode()\n)\nself.cached_version = result.stdout.decode().strip()\nreturn self.cached_version\ndef is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\nreturn True\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>","text":"<p>Executes <code>evm t8n</code> with the specified arguments.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def evaluate(\nself,\nalloc: Any,\ntxs: Any,\nenv: Any,\nfork: Fork,\nchain_id: int = 1,\nreward: int = 0,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Executes `evm t8n` with the specified arguments.\n    \"\"\"\nfork_name = fork.name()\nif eips is not None:\nfork_name = \"+\".join([fork_name] + [str(eip) for eip in eips])\ntemp_dir = tempfile.TemporaryDirectory()\nargs = [\nstr(self.binary),\n\"t8n\",\n\"--input.alloc=stdin\",\n\"--input.txs=stdin\",\n\"--input.env=stdin\",\n\"--output.result=stdout\",\n\"--output.alloc=stdout\",\n\"--output.body=txs.rlp\",\nf\"--output.basedir={temp_dir.name}\",\nf\"--state.fork={fork_name}\",\nf\"--state.chainid={chain_id}\",\nf\"--state.reward={reward}\",\n]\nif self.trace:\nargs.append(\"--trace\")\nstdin = {\n\"alloc\": alloc,\n\"txs\": txs,\n\"env\": env,\n}\nencoded_input = str.encode(json.dumps(stdin))\nresult = subprocess.run(\nargs,\ninput=encoded_input,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\"failed to evaluate: \" + result.stderr.decode())\noutput = json.loads(result.stdout)\nif \"alloc\" not in output or \"result\" not in output:\nraise Exception(\"malformed result\")\nwith open(os.path.join(temp_dir.name, \"txs.rlp\"), \"r\") as txs_rlp_file:\ntxs_rlp = txs_rlp_file.read().strip('\"')\nif self.trace:\nreceipts: List[Any] = output[\"result\"][\"receipts\"]\ntraces: List[List[Dict]] = []\nfor i, r in enumerate(receipts):\nh = r[\"transactionHash\"]\ntrace_file_name = f\"trace-{i}-{h}.jsonl\"\nwith open(\nos.path.join(temp_dir.name, trace_file_name), \"r\"\n) as trace_file:\ntx_traces: List[Dict] = []\nfor trace_line in trace_file.readlines():\ntx_traces.append(json.loads(trace_line))\ntraces.append(tx_traces)\nself.append_traces(traces)\ntemp_dir.cleanup()\nreturn (output[\"alloc\"], output[\"result\"], txs_rlp)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.is_fork_supported","title":"<code>is_fork_supported(_)</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def is_fork_supported(self, _: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.EvmTransitionTool.version","title":"<code>version()</code>","text":"<p>Gets <code>evm</code> binary version.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def version(self) -&gt; str:\n\"\"\"\n    Gets `evm` binary version.\n    \"\"\"\nif self.cached_version is None:\nresult = subprocess.run(\n[str(self.binary), \"-v\"],\nstdout=subprocess.PIPE,\n)\nif result.returncode != 0:\nraise Exception(\n\"failed to evaluate: \" + result.stderr.decode()\n)\nself.cached_version = result.stdout.decode().strip()\nreturn self.cached_version\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool","title":"<code>TransitionTool</code>","text":"<p>Transition tool frontend.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>class TransitionTool:\n\"\"\"\n    Transition tool frontend.\n    \"\"\"\ntraces: List[List[List[Dict]]] | None = None\n@abstractmethod\ndef evaluate(\nself,\nalloc: Any,\ntxs: Any,\nenv: Any,\nfork: Fork,\nchain_id: int = 1,\nreward: int = 0,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n        Simulate a state transition with specified parameters\n        \"\"\"\npass\n@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n        Return name and version of tool used to state transition\n        \"\"\"\npass\n@abstractmethod\ndef is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n        Returns True if the fork is supported by the tool\n        \"\"\"\npass\ndef reset_traces(self):\n\"\"\"\n        Resets the internal trace storage for a new test to begin\n        \"\"\"\nself.traces = None\ndef append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n        Appends a list of traces of a state transition to the current list\n        \"\"\"\nif self.traces is None:\nself.traces = []\nself.traces.append(new_traces)\ndef get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n        Returns the accumulated traces\n        \"\"\"\nreturn self.traces\ndef calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\nenv: Dict[str, Any] = {\n\"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n\"currentDifficulty\": \"0x0\",\n\"currentGasLimit\": \"0x0\",\n\"currentNumber\": \"0\",\n\"currentTimestamp\": \"0\",\n}\nif fork.header_base_fee_required(0, 0):\nenv[\"currentBaseFee\"] = \"7\"\nif fork.header_prev_randao_required(0, 0):\nenv[\"currentRandom\"] = \"0\"\nif fork.header_withdrawals_required(0, 0):\nenv[\"withdrawals\"] = []\n(_, result, _) = self.evaluate(alloc, [], env, fork)\nstate_root = result.get(\"stateRoot\")\nif state_root is None or not isinstance(state_root, str):\nraise Exception(\"Unable to calculate state root\")\nreturn state_root\ndef calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n        Calculate the state root for the given `alloc`.\n        \"\"\"\nif type(withdrawals) is list and len(withdrawals) == 0:\n# Optimize returning the empty root immediately\nreturn \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\nenv: Dict[str, Any] = {\n\"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n\"currentDifficulty\": \"0x0\",\n\"currentGasLimit\": \"0x0\",\n\"currentNumber\": \"0\",\n\"currentTimestamp\": \"0\",\n\"withdrawals\": withdrawals,\n}\nif fork.header_base_fee_required(0, 0):\nenv[\"currentBaseFee\"] = \"7\"\nif fork.header_prev_randao_required(0, 0):\nenv[\"currentRandom\"] = \"0\"\nif fork.header_excess_data_gas_required(0, 0):\nenv[\"currentExcessDataGas\"] = \"0\"\n(_, result, _) = self.evaluate({}, [], env, fork)\nwithdrawals_root = result.get(\"withdrawalsRoot\")\nif withdrawals_root is None:\nraise Exception(\n\"Unable to calculate withdrawals root: \"\n+ \"no value returned from transition tool\"\n)\nif type(withdrawals_root) is not str:\nraise Exception(\n\"Unable to calculate withdrawals root: \"\n+ \"incorrect type returned from transition tool: \"\n+ f\"{withdrawals_root}\"\n)\nreturn withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.append_traces","title":"<code>append_traces(new_traces)</code>","text":"<p>Appends a list of traces of a state transition to the current list</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def append_traces(self, new_traces: List[List[Dict]]):\n\"\"\"\n    Appends a list of traces of a state transition to the current list\n    \"\"\"\nif self.traces is None:\nself.traces = []\nself.traces.append(new_traces)\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_state_root","title":"<code>calc_state_root(alloc, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_state_root(self, alloc: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\nenv: Dict[str, Any] = {\n\"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n\"currentDifficulty\": \"0x0\",\n\"currentGasLimit\": \"0x0\",\n\"currentNumber\": \"0\",\n\"currentTimestamp\": \"0\",\n}\nif fork.header_base_fee_required(0, 0):\nenv[\"currentBaseFee\"] = \"7\"\nif fork.header_prev_randao_required(0, 0):\nenv[\"currentRandom\"] = \"0\"\nif fork.header_withdrawals_required(0, 0):\nenv[\"withdrawals\"] = []\n(_, result, _) = self.evaluate(alloc, [], env, fork)\nstate_root = result.get(\"stateRoot\")\nif state_root is None or not isinstance(state_root, str):\nraise Exception(\"Unable to calculate state root\")\nreturn state_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.calc_withdrawals_root","title":"<code>calc_withdrawals_root(withdrawals, fork)</code>","text":"<p>Calculate the state root for the given <code>alloc</code>.</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def calc_withdrawals_root(self, withdrawals: Any, fork: Fork) -&gt; str:\n\"\"\"\n    Calculate the state root for the given `alloc`.\n    \"\"\"\nif type(withdrawals) is list and len(withdrawals) == 0:\n# Optimize returning the empty root immediately\nreturn \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\"  # noqa: E501\nenv: Dict[str, Any] = {\n\"currentCoinbase\": \"0x0000000000000000000000000000000000000000\",\n\"currentDifficulty\": \"0x0\",\n\"currentGasLimit\": \"0x0\",\n\"currentNumber\": \"0\",\n\"currentTimestamp\": \"0\",\n\"withdrawals\": withdrawals,\n}\nif fork.header_base_fee_required(0, 0):\nenv[\"currentBaseFee\"] = \"7\"\nif fork.header_prev_randao_required(0, 0):\nenv[\"currentRandom\"] = \"0\"\nif fork.header_excess_data_gas_required(0, 0):\nenv[\"currentExcessDataGas\"] = \"0\"\n(_, result, _) = self.evaluate({}, [], env, fork)\nwithdrawals_root = result.get(\"withdrawalsRoot\")\nif withdrawals_root is None:\nraise Exception(\n\"Unable to calculate withdrawals root: \"\n+ \"no value returned from transition tool\"\n)\nif type(withdrawals_root) is not str:\nraise Exception(\n\"Unable to calculate withdrawals root: \"\n+ \"incorrect type returned from transition tool: \"\n+ f\"{withdrawals_root}\"\n)\nreturn withdrawals_root\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.evaluate","title":"<code>evaluate(alloc, txs, env, fork, chain_id=1, reward=0, eips=None)</code>  <code>abstractmethod</code>","text":"<p>Simulate a state transition with specified parameters</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef evaluate(\nself,\nalloc: Any,\ntxs: Any,\nenv: Any,\nfork: Fork,\nchain_id: int = 1,\nreward: int = 0,\neips: Optional[List[int]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any], str]:\n\"\"\"\n    Simulate a state transition with specified parameters\n    \"\"\"\npass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.get_traces","title":"<code>get_traces()</code>","text":"<p>Returns the accumulated traces</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def get_traces(self) -&gt; List[List[List[Dict]]] | None:\n\"\"\"\n    Returns the accumulated traces\n    \"\"\"\nreturn self.traces\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.is_fork_supported","title":"<code>is_fork_supported(fork)</code>  <code>abstractmethod</code>","text":"<p>Returns True if the fork is supported by the tool</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef is_fork_supported(self, fork: Fork) -&gt; bool:\n\"\"\"\n    Returns True if the fork is supported by the tool\n    \"\"\"\npass\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.reset_traces","title":"<code>reset_traces()</code>","text":"<p>Resets the internal trace storage for a new test to begin</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>def reset_traces(self):\n\"\"\"\n    Resets the internal trace storage for a new test to begin\n    \"\"\"\nself.traces = None\n</code></pre>"},{"location":"library/evm_transition_tool/#evm_transition_tool.TransitionTool.version","title":"<code>version()</code>  <code>abstractmethod</code>","text":"<p>Return name and version of tool used to state transition</p> Source code in <code>src/evm_transition_tool/__init__.py</code> <pre><code>@abstractmethod\ndef version(self) -&gt; str:\n\"\"\"\n    Return name and version of tool used to state transition\n    \"\"\"\npass\n</code></pre>"},{"location":"library/library/","title":"Overview","text":""},{"location":"library/library/#library-tools-reference-documentation","title":"Library (Tools) Reference Documentation","text":"<p>Execution spec tests consists of several packages that implement helper classes and tools that enable and simplify filler implementation. This section contains their reference documentation:</p> <ul> <li><code>ethereum_test_forks</code></li> <li><code>ethereum_test_tools</code></li> <li><code>evm_block_builder</code></li> <li><code>evm_transition_tool</code></li> <li><code>pytest_plugins</code></li> </ul>"},{"location":"library/pytest_plugins/","title":"Pytest Plugins","text":""},{"location":"library/pytest_plugins/#pytest-framework-and-customizations","title":"Pytest Framework and Customizations","text":"<p>Package containing pytest plugins related to test filling.</p>"},{"location":"test_case_descriptions/eip4844/","title":"\ud83e\uddea Execution Specification Test Cases","text":"<p>Note: This is still a WIP but the tests can still be used by any client team. The priority levels (\ud83d\udd34, \ud83d\udfe0, \ud83d\udfe1, \ud83d\udfe2) represent very high, high, medium, low  priorities respectively.</p>"},{"location":"test_case_descriptions/eip4844/#datahash-opcode","title":"\ud83d\udcd6 Datahash Opcode","text":"<p>Test Module - <code>eip4844/datahash_opcode.py</code></p> <p>Verifies that the <code>DATAHASH</code> opcode, works as intended for a variety of contexts, retrieves the blob versioned hash correctly for a given index, returns the correct zeroed <code>bytes32</code> value for out-of-range indices, and consumes the correct amount of gas.</p> <p>1) \ud83d\udd34 test_datahash_opcode_contexts():</p> <p>Tests that the <code>DATAHASH</code> opcode functions correctly when called in different contexts including: - <code>DATAHASH</code> opcode on the top level of the call stack. - <code>DATAHASH</code> opcode on the max value. - <code>DATAHASH</code> opcode on <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, and <code>CALLCODE</code>. - <code>DATAHASH</code> opcode on Initcode. - <code>DATAHASH</code> opcode on <code>CREATE</code> and <code>CREATE2</code>. - <code>DATAHASH</code> opcode on transaction types 0, 1 and 2.</p> <p>2) \ud83d\udd34 test_datahash_blob_versioned_hash():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the correct versioned hash for various valid indexes. This test covers various scenarios with random <code>blob_versioned_hash</code> values within the valid range <code>[0, 2**256-1]</code>.</p> <p>3) \ud83d\udd34 test_datahash_invalid_blob_index():</p> <p>Tests that the <code>DATAHASH</code> opcode returns a zeroed <code>bytes32</code> value for invalid indexes. This test includes cases where the index is negative (<code>index &lt; 0</code>) or exceeds the maximum number of <code>blob_versioned_hash</code> values stored (<code>index &gt;= len(tx.message.blob_versioned_hashes)</code>). It confirms that the returned value is a zeroed <code>bytes32</code> value for these cases.</p> <p>4) \ud83d\udfe0 test_datahash_gas_cost():</p> <p>Asserts the gas consumption of the <code>DATAHASH</code> opcode is correct by ensuring it matches <code>HASH_OPCODE_GAS = 3</code>. It includes both valid and invalid random index sizes from the range <code>[0, 2**256-1]</code>, for tx types 2 and 3.</p> <p>5) \ud83d\udfe1 test_datahash_multiple_txs_in_block():</p> <p>Tests that the <code>DATAHASH</code> opcode returns the appropriate values when there is more than one blob tx type within a block (for tx types 2 and 3). Scenarios involve tx type 3 followed by tx type 2 running the same code within a block. In this case <code>DATAHASH</code> returns 0, but for the opposite scenario <code>DATAHASH</code> returns the correct <code>blob_versioned_hash</code>.</p>"},{"location":"test_case_descriptions/eip4844/#excess-data-gas","title":"\ud83d\udcbd\u26fd\ud83d\udcb8 Excess Data Gas","text":"<p>Test Module - <code>eip4844/excess_data_gas.py</code></p> <p>Predominantly verifies that <code>excess_data_gas</code> &amp; <code>data_gasprice</code> are calculated correctly ensuring both valid and invalid transactions are processed accordingly. Extra verification is added specifically for invalid blob transactions when the <code>max_fee_per_data_gas</code>, number of blobs or transaction type are errorneous. </p> <p>1) \ud83d\udd34 test_excess_data_gas_calculation():</p> <p>Tests that the <code>excess_data_gas</code> is calculated correctly within a single block for various contexts, where the <code>parent.excess_data_gas</code> and the proposed block <code>excess_data_gas</code> have a variety of values. The excess data gas is calculated using the following formula:</p> <pre><code>def calc_excess_data_gas(parent: Header, new_blobs: int) -&gt; int:\nconsumed_data_gas = new_blobs * DATA_GAS_PER_BLOB\nif parent.excess_data_gas + consumed_data_gas &lt; TARGET_DATA_GAS_PER_BLOCK:\nreturn 0\nelse:\nreturn parent.excess_data_gas + consumed_data_gas - TARGET_DATA_GAS_PER_BLOCK\n</code></pre> <p>For blocks to be valid in these contexts they must meet the following conditions of the EIP:   - Each block can only have a maximum of <code>MAX_BLOBS_PER_BLOCK</code>.   - A type 5 blob transaction must have at least one blob - <code>len(versioned_hashes) &gt; 0</code>.   - The user is open to paying the current data gasprice for the transaction -<code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code>   - The account used for the blob transaction must have enough balance - <code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> <p>2) \ud83d\udd34 test_invalid_excess_data_gas_in_header():</p> <p>Asserts that blocks with invalid <code>excess_data_gas</code> values in the header are ignored, ensuring the blob transaction is rejected and no state changes occur. The invalidity of <code>excess_data_gas</code> within a new block header is tested across the following scenarios:</p> <ul> <li> <p><code>excess_data_gas</code> decreases or increases by <code>TARGET_DATA_GAS_PER_BLOCK + 1</code> in a single block. Note that the EIP only allows <code>excess_data_gas</code> to decrease &amp; increase by a maximum of <code>TARGET_DATA_GAS_PER_BLOCK</code>.</p> </li> <li> <p><code>excess_data_gas</code> is unchanged when the number of blobs in the proposed block doesn't equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are different from the target, <code>excess_data_gas</code> must change. </p> </li> <li> <p><code>excess_data_gas</code> is changed when the number of blobs in the proposed block does equal the <code>TARGET_BLOBS_PER_BLOCK</code>. If the number of blobs are equal to the target,<code>excess_data_gas</code> must remain the same value - <code>parent_excess_data_gas</code>.</p> </li> <li> <p><code>excess_data_gas</code> is less than the <code>TARGET_DATA_GAS_PER_BLOCK</code> when the parent has 0 blobs (<code>parent.excess_data_gas</code> = 0), and the calculated excess is non-zero. This is invalid as the first condition in the excess data gas calculation must be met, and hence return zero for this case. </p> </li> <li> <p><code>excess_data_gas</code> is a value greater than <code>2**256-1</code>. It must be a value that fits within 256-bits.</p> </li> </ul> <p>3) \ud83d\udd34 test_fork_transition_excess_data_gas_in_header():</p> <p>Tests that the <code>excess_data_gas</code> calculation is correct when transitioning from the Shanghai fork to the Cancun fork, where appended blocks are valid and state changes occur. Each block has a single transaction with <code>MAX_BLOBS_PER_BLOCK</code> blobs. The first block during the transition period has a parent of zero <code>excess_data_gas</code> in the header. Each block afterwards calculates <code>excess_data_gas</code> using the following <code>calc_excess_data_gas</code> function such that it continuously increases.</p> <p>4) \ud83d\udd34 test_invalid_blob_txs():</p> <p>Asserts that blocks with invalid blob transactions are rejected and no state changes occur. This is tested across the following scenarios:</p> <ul> <li><code>max_fee_per_data_gas</code> is less than the required <code>data_gasprice</code> for a set number of excess blobs. This is invaild as a valid block must obey the following condition:</li> <li> <p><code>tx.message.max_fee_per_data_gas &gt;= get_data_gasprice(parent(block).header)</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> is greater than the required <code>data_gasprice</code> for a set number of excess blobs but the account doesn't have the required balance to cover the total cost of the transaction. A valid block must prove true for the following condition: </p> </li> <li> <p><code>signer(tx).balance &gt;= tx.message.gas * tx.message.max_fee_per_gas + get_total_data_gas(tx) * tx.message.max_fee_per_data_gas</code></p> </li> <li> <p><code>max_fee_per_data_gas</code> has an invalid value of zero. This value is invalid as it is less than <code>MIN_DATA_GASPRICE = 1</code>.</p> </li> <li> <p><code>len(blobs)</code> is greater than <code>MAX_BLOBS_PER_BLOCK =  MAX_DATA_GAS_PER_BLOCK // DATA_GAS_PER_BLOB</code> in a single transaction within one block. There cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(wrapper.tx.message)</code> is greater that <code>MAX_BLOBS_PER_BLOCK</code> but with <code>len(blobs) = 1</code> for each transaction. As before there cannot be more than <code>MAX_BLOBS_PER_BLOCK</code> blobs in a block.</p> </li> <li> <p><code>len(blobs)</code> is zero within a transaction. Valid blob txs (type 3) must have at least one blob within it, obeying the following condition:</p> </li> <li> <p><code>len(tx.message.blob_versioned_hashes) &gt; 0</code></p> </li> <li> <p>Blob transaction type 3 is used in a pre-Cancun fork. This transcation type can only be used in a post-Cancun fork.</p> </li> </ul>"},{"location":"tutorials/blockchain/","title":"Blockchain Tests","text":"<p>This tutorial teaches you to create a blockchain execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will process given blocks and arrive at a defined post-state.</p>"},{"location":"tutorials/blockchain/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a blockchain test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> <li>Understand how to write an execution spec state transition test.</li> </ul>"},{"location":"tutorials/blockchain/#example-tests","title":"Example Tests","text":"<p>In this tutorial we will go over [test_block_number] in <code>block_example.py</code>(https://github.com/ethereum/execution-spec-tests/tree/main/fillers/example/block_example.py#L19).</p> <p>It is assumed you have already gone through the state transition test tutorial. Only new concepts will be discussed.</p>"},{"location":"tutorials/blockchain/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is defined that is called by each transaction in the test. It stores a pointer to storage at <code>storage[0]</code>. When it is called storage cell <code>0</code> gets the current block number, and the pointer is incremented to the next value.</p> <pre><code>contract_addr: Account(\nbalance=1000000000000000000000,\ncode=Yul(\n\"\"\"\n        {\n            let next_slot := sload(0)\n            sstore(next_slot, number())\n            sstore(0, add(next_slot, 1))\n        }\n        \"\"\"\n),\nstorage={\n0x00: 0x01,\n},\n),\n</code></pre>"},{"location":"tutorials/blockchain/#transaction-generator","title":"Transaction Generator","text":"<p>The transactions used in this test are nearly identical. Their only different is the <code>nonce</code> value which needs to be incremented. </p> <pre><code>def tx_generator():\nnonce = 0  # Initial value\nwhile True:\ntx = Transaction(\nty=0x0,\nchain_id=0x0,\nnonce=nonce,\nto=contractAddr,\ngas_limit=500000,\ngas_price=10,\n)\nnonce = nonce + 1\nyield tx\ntx_generator = tx_generator()\n</code></pre> <p>This looks like an infinite loop but it isn't because this is a generator function. When generator encounters the <code>yield</code> keyword it returns the value and stops execution, keeping a copy of all the local variables, until it is called again. Hence infinite loops inside a generator are not a problem as long as they include <code>yield</code>. This code section is responsible for creating the <code>Transaction</code> object and incrementing the <code>nonce</code>.</p> <p>Every time the function <code>tx_generator()</code> is called, it returns a new generator with a <code>nonce</code> of zero. To increment the <code>nonce</code> we need to use the same generator. We assign this generator to <code>tx_generator</code>.</p>"},{"location":"tutorials/blockchain/#blocks","title":"Blocks","text":"<p>Each integer in the <code>tx_per_block</code> array is the number of transactions in a block. The genesis block is block 0 (no transactions). It follows that we have 2 transactions in block 1, 0 in block two, 4 in block 3, ..., and 50 in block 9.</p> <pre><code>tx_per_block = [2, 0, 4, 8, 0, 0, 20, 1, 50]\n</code></pre> <p>The code section that creates the blocks is a bit complex in this test. For some simpler definitions of Block creation you can browse tests within <code>withdrawals.py</code>.</p> <pre><code>blocks = map(\nlambda len: Block(\ntxs=list(map(lambda x: next(tx_generator), range(len)))\n),\ntx_per_block,\n)\n</code></pre> <p>We use <code>lambda</code> notation to specify short functions. In this case, the function doesn't actually care about its input, it just returns the next transaction from the generator.</p> <pre><code>lambda x: next(tx_generator)\n</code></pre> <p>Python uses <code>range(n)</code> to create a list of numbers from <code>0</code> to <code>n-1</code>. Among other things, it's a simple way to create a list of <code>n</code> values.</p> <pre><code>range(len)\n</code></pre> <p>The <code>map</code> function runs the function (the first parameter) on every element of the list (the second parameter). Putting together what we know, it means that it runs <code>next(tx_generator)</code> <code>len</code> times, giving us <code>len</code> transactions. We then use <code>list</code> to turn the transactions into a list that we can provide as the <code>txs</code> parameter to the <code>Block</code> constructor.</p> <pre><code>list(map(lambda x: next(tx_generator), range(len)))\n</code></pre> <p>The outer <code>lambda</code> function takes an integer, <code>len</code>, and creates a <code>Block</code> object with <code>len</code> transactions. This function is then run on every value of <code>tx_per_block</code> to generate the blocks.</p> <pre><code>blocks = map(\nlambda len: Block(\ntxs=list of len transactions\n),\ntx_per_block,\n)\n</code></pre> <p>For example, if we had <code>tx_per_block = [0,2,4]</code>, we'd get this result:</p> <pre><code>blocks = [\nBlocks(txs=[]),\nBlocks(txs=[next(tx_generator), next(tx_generator)]),\nBlocks(txs=[next(tx_generator), next(tx_generator), next(tx_generator), next(tx_generator)])        \n]\n</code></pre>"},{"location":"tutorials/blockchain/#post-state","title":"Post State","text":"<p>Recall that storage slot 0 retains the value of the next slot that the block number is written into. It starts at one and is incremented after each transaction. Hence it's the total number of transactions plus 1.</p> <pre><code>storage = {0: sum(tx_per_block) + 1}\n</code></pre> <p>For every block and transaction within the block, we write the block number and increment the next slot number in storage slot 0. As Python lists are 0 indexed, we must increment the block number by 1.</p> <pre><code>next_slot = 1\nfor blocknum in range(len(tx_per_block)):\nfor _ in range(tx_per_block[blocknum]):\nstorage[next_slot] = blocknum + 1\nnext_slot = next_slot + 1\n</code></pre> <p>Now that the expeced storage values are calculated, the post state can be defined and yielded within the <code>BlockchainTest</code>, synonymous to the state test example.</p> <pre><code>post = {contract_addr: Account(storage=storage)}\nyield BlockchainTest(\ngenesis_environment=env,\npre=pre,\nblocks=blocks,\npost=post,\n)\n</code></pre> <p>Note that because of the <code>yield</code> we could have multiple tests under the same name.</p>"},{"location":"tutorials/blockchain/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to write blockchain tests.</p>"},{"location":"tutorials/state_transition/","title":"State Transition Tests","text":"<p>This tutorial teaches you to create a state transition execution specification test. These tests verify that a blockchain, starting from a defined pre-state, will reach a specified post-state after executing a set of specific transactions.</p>"},{"location":"tutorials/state_transition/#pre-requisites","title":"Pre-requisites","text":"<p>Before proceeding with this tutorial, it is assumed that you have prior knowledge and experience with the following:</p> <ul> <li>Set up and run an execution specification test as outlined in the quick start guide.</li> <li>Understand how to read a static state transition test.</li> <li>Know the basics of Yul, which is an EVM assembly language.</li> <li>Familiarity with Python.</li> </ul>"},{"location":"tutorials/state_transition/#example-tests","title":"Example Tests","text":"<p>The most effective method of learning how to write tests is to study a couple of straightforward examples. In this tutorial we will go over the Yul and Bad Opcode state tests.</p>"},{"location":"tutorials/state_transition/#yul-test","title":"Yul Test","text":"<p>You can find the source code for the Yul test here. It is the spec test equivalent of this static test. </p> <p>Lets examine each section.</p> <pre><code>\"\"\"\nTest Yul Source Code Examples\n\"\"\"\n</code></pre> <p>In Python, multi-line strings are denoted using <code>\"\"\"</code>. As a convention, a file's purpose is often described in the opening string of the file.</p> <pre><code>from ethereum_test_tools import (\nAccount,\nEnvironment,\nStateTest,\nTestAddress,\nTransaction,\nYul,\ntest_from,\n)\n</code></pre> <p>Next the following constants, types and helper functions are imported from <code>ethereum_test_tools</code> and <code>ethereum_test_forks</code>. We will go over these as we come across them.</p> <pre><code>@test_from(Berlin)\n</code></pre> <p>In Python this kind of definition is called a decorator. It modifies the action of the function after it. In this case, it specifies to the test running code that the following function is only a valid test for the Berlin fork and the forks after it.</p> <pre><code>def test_yul(fork):\n\"\"\"\n    Test YUL compiled bytecode.\n    \"\"\"\n</code></pre> <p>This is the format of a Python function. It starts with <code>def &lt;function name&gt;(&lt;parameters&gt;):</code>, and then has indented code for the function. The function definition ends when there is a line that is no longer indented. As with files, by convention functions start with a string that explains what the function does.</p> <p>Note</p> <p>Recall from quick start that to solely run the test case <code>test_yul</code> we ommit <code>test_</code> from the test filler: <code>tf --test-case yul --output fixtures</code>.</p> <pre><code>    env = Environment()\n</code></pre> <p>This line specifies that <code>env</code> is an <code>Environment</code> object, and that we just use the default parameters. If necessary we can modify the environment to have different block gas limits, block numbers, etc. In most tests the defaults are good enough.</p> <p>For more information, see the static test documentation.</p>"},{"location":"tutorials/state_transition/#pre-state","title":"Pre State","text":"<pre><code>    pre = {\n</code></pre> <p>Here we define the pre-state section, the one that tells us what is on the \"blockchain\" before the test. It is a dictionary, which is the Python term for an associative array.</p> <pre><code>        \"0x1000000000000000000000000000000000000000\": Account(\n</code></pre> <p>The keys of the dictionary are addresses (as strings), and the values are <code>Account</code> objects. You can read more about address fields in the static test documentation. </p> <pre><code>            balance=0x0BA1A9CE0BA1A9CE,\n</code></pre> <p>This field is the balance: the amount of Wei that the account has. It usually doesn't matter what its value is in the case of state test contracts.</p> <pre><code>            code=Yul(\n</code></pre> <p>Here we define the Yul code for the contract. It is defined as a multi-line string and starts and ends with curly braces (<code>{ &lt;yul&gt; }</code>).</p> <p>When running the test filler <code>tf</code> the solidity compiler <code>solc</code> will automatically translate the Yul to EVM opcode at runtime. </p> <p>Note</p> <p>Currently Yul and direct EVM opcode are supported in execution spec tests. LLL and Solidity may be supported in the future.</p> <pre><code>                \"\"\"\n                {\n                    function f(a, b) -&gt; c {\n                        c := add(a, b)\n                    }\n                    sstore(0, f(1, 2))\n                    return(0, 32)\n                }\n                \"\"\"\n),\n),\n</code></pre> <p>Within this example test Yul code we have a function definition, and inside it we are using the Yul <code>add</code> instruction. When compiled with <code>solc</code> it translates the instruction directly to the<code>ADD</code> opcode. For further Yul instructions see here. Notice that function is utilised with the Yul <code>sstore</code> instruction, which stores the result of <code>add(1, 2)</code> to the storage address <code>0x00</code>.</p> <p>Generally for execution spec tests the <code>sstore</code> instruction acts as a high-level assertion method to check pre to post-state changes. The test filler achieves this by verifying that the correct value is held within post-state storage, hence we can validate that the Yul code has run successfully.</p> <pre><code>        TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n}\n</code></pre> <p><code>TestAddress</code> is an address for which the test filler has the private key. This means that the test runner can issue a transaction as that contract. Of course, this address also needs a balance to be able to issue transactions.</p>"},{"location":"tutorials/state_transition/#transactions","title":"Transactions","text":"<pre><code>    tx = Transaction(\nty=0x0,\nchain_id=0x0,\nnonce=0,\nto=\"0x1000000000000000000000000000000000000000\",\ngas_limit=500000,\ngas_price=10,\nprotected=False,\n)\n</code></pre> <p>With the pre-state specified, we can add a description for the <code>Transaction</code>. For more information, see the static test documentation</p>"},{"location":"tutorials/state_transition/#post-state","title":"Post State","text":"<pre><code>    post = {\n\"0x1000000000000000000000000000000000000000\": Account(\nstorage={\n0x00: 0x03,\n},\n),\n}\n</code></pre> <p>This is the post-state which is equivalent to <code>expect</code> in static tests, but without the indexes. It is similar to the pre-state, except that we do not need to specify everything, only those accounts and fields we wish to test.</p> <p>In this case, we look at the storage of the contract we called and add to it what we expect to see. In this example storage cell <code>0x00</code> should be <code>0x03</code> as in the pre-state we essentially stored the result of the Yul instruction <code>add(1, 2)</code>.</p>"},{"location":"tutorials/state_transition/#state-test","title":"State Test","text":"<pre><code>    yield StateTest(env=env, pre=pre, post=post, txs=[tx])\n</code></pre> <p>This line produces the actual state test using the <code>ethereum_test_tools</code>  spec package, when running the test filler. It is <code>yield</code>, rather than <code>return</code>, because a single function can return multiple test cases as you'll see in the next example.</p>"},{"location":"tutorials/state_transition/#bad-opcode-test","title":"Bad Opcode Test","text":"<p>The source code for this test is here. We will only go over the parts that are new.</p> <p>We use Python string templates, so we need to import that library.</p> <pre><code>from string import Template\n</code></pre> <p>In this test we need a couple of addresses, so we create them here. Python lets us specify <code>&lt;string&gt;*&lt;number&gt;</code> when we need a string repeated multiple times, which makes for more readable code than <code>0x00...000C0DE</code>.</p> <pre><code>    code_addr = \"0x\" + \"0\"*(40-4) + \"C0DE\"\ngoat_addr = \"0x\" + \"0\"*(40-4) + \"60A7\"\n</code></pre> <p>We create <code>env</code> and <code>tx</code> first because they are constant. This function will <code>yield</code> multiple tests, but always with the same <code>env</code> and <code>tx</code> values.</p> <pre><code>    env = Environment()\ntx = Transaction(\n.\n.\n.\n)\n</code></pre> <p>Here we create two post states. We will use whichever one is appropriate to the test we create.</p> <pre><code>    post_valid = {\ncode_addr: Account(\nstorage={0x00: 1},\n),\n}\npost_invalid = {\ncode_addr: Account(\nstorage={0x00: 0},\n),\n}\n</code></pre> <p>Here we define a function (<code>opc_valid</code>) inside another function. Python supports this, and it has two advantages:</p> <ul> <li>Avoid namespace pollution by restricting the function to where it is needed.</li> <li>Functions defined inside other functions can use the parameters and local variables of those functions.   In this case, we need to use <code>fork</code>.</li> </ul> <pre><code>    # Check if an Opcode is valid\ndef opc_valid(opc):\n\"\"\"\n        Return whether opc will be evaluated as valid by the test or not.\n        Note that some opcodes are evaluated as invalid because the way they act\n        \"\"\"\n</code></pre> <p>This is the syntax for Python comments, <code># &lt;rest of the line&gt;</code>. </p> <pre><code>        # PUSH0 is only valid Shanghai and later\n</code></pre> <p>Opcode 0x5F (<code>PUSH0</code>) is only valid starting with the Shangai fork. We don't know what will be the fork names after Shanghai, so it is easiest to specify that prior to Shanghai it is invalid. We don't need to worry about forks prior to London because the decorator for this test says it is only valid from London.</p> <pre><code>        if fork in {\"london\", \"merge\"} and opc==0x5F:\n</code></pre> <p>Python has a set data structure. We use this structure when the order of the values are irrelevant, and we just want to be able to check if something is a member or not.</p> <p>Note that <code>if</code> statements are also followed by a colon (<code>:</code>) and the code inside them indented. That is the general Python syntax.</p> <pre><code>            return False\n</code></pre> <p>Boolean values in Python are either <code>True</code> or <code>False</code>.</p> <p>This test works by running an opcode and then does a <code>SSTORE</code>. Opcodes that terminate execution, such as <code>STOP</code> and <code>RETURN</code> also cause the <code>SSTORE</code> not to happen, so they must be treated as invalid. The same is true for <code>JUMP</code>.</p> <pre><code>        # Valid opcodes, but they are terminal, and so cause\n# the SSTORE not to happen\nif opc in {0x00, 0xF3, 0xFD, 0xFF}:\nreturn False\n# Jumps. If you jump to a random location, you skip the SSTORE\nif opc in {0x56}:\nreturn False\n</code></pre> <p>Next we return <code>True</code> for supported opcodes.</p> <pre><code>        # Opcodes that aren't part of a range\n# 0x20 - SHA3\n# 0xFA - STATICCALL\nif opc in {0x20, 0xFA}:\nreturn True\n</code></pre> <p>In Python, as in math, you can use <code>a &lt; b &lt; c</code> for <code>a &lt; b and b &lt; c</code>.</p> <pre><code>        # Arithmetic opcodes\nif 0x01 &lt;= opc &lt;= 0x0b:\nreturn True\n.\n.\n.\n</code></pre> <p>The last part the function returns <code>False</code>. If we got here, then this is not a valid opcode.</p> <pre><code>        return False\n# End of opc_valid\n</code></pre> <p>As this is the end of the function, the next code line is unindented (compared to the function definition code).</p> <p>This is a <code>for</code> loop. For loops iterate over a sequnce, and the <code>range</code> function, in this case, gives us the range 0..255. As with functions and <code>if</code> statements, the <code>for</code> loop has a colon and includes the indented code.</p> <pre><code>    # For every possible opcode\nfor opc in range(256):\n</code></pre> <p>We have two post states.  One, <code>post_valid</code>, has the value of <code>1</code> in storage location <code>0</code>. The other, <code>post_invalid</code> has the value of <code>0</code> in storage location <code>0</code>. But <code>SELFDESTRUCT</code> destroys the contract so there is no longer an account at that address.  Neither is valid, so we just skip that test case.</p> <pre><code>        # We can't check SELFDESTRUCT using this technique\nif opc in {0xFF}:\ncontinue\n</code></pre> <p>We need the opcode in hexadecimal.  The function <code>hex</code> gives us the hexadecimal number in hex. However, it also gives us a <code>0x</code> prefix, which we don't want, so we use a slice to remove the first two characters.</p> <pre><code>        opc_hex = hex(opc)[2:]\n</code></pre> <p>We need <code>opc_hex</code> to be two characters. If the length is only one, prepend a zero.</p> <pre><code>        if len(opc_hex) == 1:\nopc_hex = \"0\" + opc_hex\n</code></pre> <p>This is a <code>Template</code> string. This means we'll be able to substitute template variables (<code>${&lt;var name&gt;}</code>) with values to produce the actual code.</p> <pre><code>        yul_code = Template(\"\"\"\n        {\n</code></pre> <p>We start with a call <code>0x00...0060A7</code> (a.k.a. <code>goat_addr</code>) so we'll have some return data. Otherwise, <code>RETURNDATACOPY</code> will fail and appear like it is not an opcode.</p> <pre><code>           pop(call(gas(), 0x60A7, 0, 0, 0, 0, 0))\n// fails on opcodes with &gt;20 inputs\n// (currently dup16, at 17 inputs, is the\n// one that goes deepest)\n//\n// Follow with 32 NOPs (0x5B) to handle PUSH, which has an immediate\n// operand\n</code></pre> <p>Opcodes can have two types of operands:</p> <ul> <li>Immediate operands, which are part of the bytecode.   For example, <code>6001</code> is <code>PUSH1</code> with the value <code>0x01</code>.</li> <li>Implied operands (a.k.a. stack operands), which come from the stack.</li> </ul> <p>This <code>verbatim</code> code provides both operand types. The code, <code>${opcode}${nop32}</code> is the opcode we are testing, followed by 32 copies of 0x5B. When <code>0x5B</code> is not used as an operand, it is <code>JUMPDEST</code> and does nothing.</p> <pre><code>           verbatim_20i_0o(hex\"${opcode}${nop32}\",\n</code></pre> <p>The opcode string is followed by the input parameters (in this case, twenty of them). These can be Yul expressions, but for the sake of simplicity here we just use constant values.</p> <pre><code>              0x00, 0x00, 0x00, 0xFF, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF)\n</code></pre> <p>If the opcode terminates the smart contract execution (as invalid opcodes do), we don't get here. If we do get here, write to storage cell <code>0x00</code> to record that fact.</p> <p>Note the syntax <code>let &lt;var&gt; := &lt;value&gt;</code>. This is how you specify variables in Yul.</p> <pre><code>           // We only get here is the opcode is legit (and it doesn't terminate\n// execution like STOP and RETURN)\nlet zero := 0\nlet one := 1\nsstore(zero, one)\n}\n</code></pre> <p>Replace <code>${opcode}</code> with the one byte hex code, and <code>${nop32}</code> with 32 copies of <code>5b</code> (for NOP).</p> <pre><code>        \"\"\").substitute(opcode=opc_hex, nop32=\"5B\"*32)\n        pre = {\n           TestAddress: Account(balance=0x0BA1A9CE0BA1A9CE),\n           codeAddr: Account(\n        balance=0,\n        nonce=1,\n        code=Yul(yul_code)\n           ),\n</code></pre> <p>This is the account for <code>0x00..0060A7</code>.  It just returns data (all zeros).</p> <pre><code>           goat_addr: Account(\nbalance=0,\nnonce=1,\ncode=Yul(\"{ return(0, 0x100) }\"),\n)\n}\n</code></pre> <p>Every time the <code>for</code> loop gets here, it <code>yields</code> a separate test.  Over the entire for loop, it yields 255 different tests.</p> <pre><code>    yield StateTest(\nenv=env, \npre=pre, \ntxs=[tx],\npost=(post_valid if opc_valid(opc) else post_invalid),\n)\n</code></pre> <p>The Python format for the ternary operation is a bit different from C-like languages. In C like languages the syntax is <code>&lt;condition&gt; ? &lt;yes value&gt; : &lt;no value&gt;</code>. In Python it is <code>&lt;yes value&gt; if &lt;condition&gt; else &lt;no value&gt;</code>. </p>"},{"location":"tutorials/state_transition/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to state transition tests within a single block.</p>"}]}